struct  ifdef_options {
  int config_feature_vi_win_resize ;
  int config_feature_chat_tty_hifi ;
  int config_feature_modprobe_blacklist ;
  int config_feature_seamless_bz2 ;
  int config_feature_makedevs_leaf ;
  int config_pkill ;
  int config_tar ;
  int config_feature_ifupdown_mapping ;
  int config_feature_insmod_load_map ;
  int config_remove_shell ;
  int config_hd ;
  int config_feature_df_fancy ;
  int config_ash_builtin_printf ;
  int config_adduser ;
  int config_feature_tar_gnu_extensions ;
  int config_feature_find_links ;
  int config_feature_httpd_setuid ;
  int config_feature_klogd_klogctl ;
  int config_feature_ftp_write ;
  int config_sha1sum ;
  int config_use_portable_code ;
  int config_selinux ;
  int config_swaponoff ;
  int config_feature_non_posix_cp ;
  int config_feature_tar_nopreserve_time ;
  int config_feature_find_exec ;
  int config_flash_lock ;
  int config_softlimit ;
  int config_feature_find_perm ;
  int config_feature_httpd_basic_auth ;
  int config_feature_dc_libm ;
  int config_feature_ifconfig_hw ;
  int config_devfsd_verbose ;
  int config_feature_seamless_lzma ;
  int config_feature_chat_send_escapes ;
  int config_feature_ip_link ;
  int config_feature_xargs_support_termopt ;
  int config_feature_ar_create ;
  int config_killall5 ;
  int config_feature_loadfont_psf2 ;
  int config_feature_find_print0 ;
  int config_feature_mount_nfs ;
  int config_feature_grep_context ;
  int config_feature_umount_all ;
  int config_feature_insmod_version_checking ;
  int config_nommu ;
  int config_feature_ps_unusual_systems ;
  int config_feature_seamless_z ;
  int config_feature_volumeid_romfs ;
  int config_feature_run_parts_long_options ;
  int config_feature_ls_color_is_default ;
  int config_feature_ls_sortfiles ;
  int config_feature_crond_call_sendmail ;
  int config_feature_securetty ;
  int config_feature_ls_recursive ;
  int config_feature_grep_egrep_alias ;
  int config_feature_xargs_support_quotes ;
  int config_feature_ipcalc_long_options ;
  int config_feature_httpd_auth_md5 ;
  int config_feature_chat_clr_abort ;
  int config_tftp_debug ;
  int config_feature_find_xdev ;
  int config_feature_initrd ;
  int config_nandwrite ;
  int config_feature_volumeid_jfs ;
  int config_feature_mdev_load_firmware ;
  int config_test ;
  int config_cpio ;
  int config_feature_less_marks ;
  int config_md5sum ;
  int config_feature_syslogd_dup ;
  int config_feature_init_syslog ;
  int config_feature_ls_followlinks ;
  int config_feature_mdev_exec ;
  int config_feature_setconsole_long_options ;
  int config_du ;
  int config_use_bb_pwd_grp ;
  int config_unexpand ;
  int config_feature_ip_tunnel ;
  int config_feature_expand_long_options ;
  int config_unicode_using_locale ;
  int config_feature_inetd_support_builtin_chargen ;
  int config_unxz ;
  int config_feature_makedevs_table ;
  int config_feature_less_flags ;
  int config_feature_minix2 ;
  int config_feature_su_checks_shells ;
  int config_feature_float_sleep ;
  int config_feature_volumeid_reiserfs ;
  int config_feature_shared_busybox ;
  int config_feature_tftp_progress_bar ;
  int config_feature_date_nano ;
  int config_feature_hwib ;
  int config_feature_inetd_support_builtin_echo ;
  int config_setuidgid ;
  int config_feature_editing_savehistory ;
  int config_feature_insmod_loadinkmem ;
  int config_feature_insmod_load_map_full ;
  int config_lzop_compr_high ;
  int config_pam ;
  int config_feature_individual ;
  int config_unicode_preserve_broken ;
  int config_feature_bootchartd_bloated_header ;
  int config_ftpput ;
  int config_feature_vi_setopts ;
  int config_feature_lzma_fast ;
  int config_feature_clean_up ;
  int config_feature_traceroute_use_icmp ;
  int config_feature_vi_colon ;
  int config_base64 ;
  int config_feature_tee_use_block_io ;
  int config_feature_cp_long_options ;
  int config_feature_find_prune ;
  int config_use_bb_crypt ;
  int config_feature_tr_classes ;
  int config_feature_editing_vi ;
  int config_feature_chcon_long_options ;
  int config_feature_split_fancy ;
  int config_echo ;
  int config_feature_check_names ;
  int config_feature_cpio_o ;
  int config_feature_mount_cifs ;
  int config_feature_fbset_fancy ;
  int config_tftp ;
  int config_feature_volumeid_btrfs ;
  int config_feature_chat_var_abort_len ;
  int config_feature_volumeid_sysv ;
  int config_feature_mount_loop ;
  int config_ping6 ;
  int config_feature_osf_label ;
  int config_feature_volumeid_linuxswap ;
  int config_printf ;
  int config_feature_ar_long_filenames ;
  int config_feature_hdparm_hdio_getset_dma ;
  int config_feature_less_regexp ;
  int config_unlzma ;
  int config_feature_traceroute_source_route ;
  int config_feature_grep_fgrep_alias ;
  int config_feature_vi_dot_cmd ;
  int config_feature_preserve_hardlinks ;
  int config_feature_httpd_use_sendfile ;
  int config_feature_modprobe_small_options_on_cmdline ;
  int config_devfsd_modload ;
  int config_feature_topmem ;
  int config_hush ;
  int config_feature_stat_format ;
  int config_feature_fast_top ;
  int config_feature_tar_long_options ;
  int config_unicode_wide_wchars ;
  int config_feature_chat_swallow_opts ;
  int config_feature_seamless_xz ;
  int config_feature_fancy_head ;
  int config_lzma ;
  int config_feature_less_dashcmd ;
  int config_feature_logread_reduced_locking ;
  int config_setfont ;
  int config_feature_ls_filetypes ;
  int config_freeramdisk ;
  int config_feature_udhcp_rfc3397 ;
  int config_feature_mount_label ;
  int config_feature_mount_verbose ;
  int config_feature_seamless_gz ;
  int config_feature_ps_additional_columns ;
  int config_feature_top_decimals ;
  int config_feature_hdparm_hdio_drive_reset ;
  int config_feature_find_newer ;
  int config_feature_ftpgetput_long_options ;
  int config_feature_diff_long_options ;
  int config_feature_volumeid_iso9660 ;
  int config_feature_modutils_alias ;
  int config_feature_mount_flags ;
  int config_feature_less_linenums ;
  int config_pidof ;
  int config_ftpget ;
  int config_unicode_support ;
  int config_feature_insmod_try_mmap ;
  int config_feature_ipcalc_fancy ;
  int config_feature_autowidth ;
  int config_feature_top_smp_cpu ;
  int config_add_shell ;
  int config_feature_popmaildir_delivery ;
  int config_feature_ifconfig_memstart_ioaddr_irq ;
  int config_feature_bootchartd_config_file ;
  int config_feature_find_size ;
  int config_feature_ftpd_accept_broken_list ;
  int config_install_no_usr ;
  int config_feature_volumeid_ocfs2 ;
  int config_feature_buffers_go_on_stack ;
  int config_feature_tftp_get ;
  int config_feature_shadowpasswds ;
  int config_dpkg ;
  int config_debug ;
  int config_sha512sum ;
  int config_feature_telnet_ttype ;
  int config_feature_telnetd_inetd_wait ;
  int config_feature_volumeid_ext ;
  int config_feature_vi_yankmark ;
  int config_feature_volumeid_ntfs ;
  int config_feature_find_user ;
  int config_feature_find_mmin ;
  int config_feature_top_cpu_global_percents ;
  int config_feature_verbose_cp_message ;
  int config_feature_awk_libm ;
  int config_feature_taskset_fancy ;
  int config_ftpd ;
  int config_feature_buffers_go_in_bss ;
  int config_feature_etc_networks ;
  int config_feature_httpd_proxy ;
  int config_feature_wget_authentication ;
  int config_chpasswd ;
  int config_feature_httpd_gzip ;
  int config_feature_gzip_long_options ;
  int config_feature_vi_optimize_cursor ;
  int config_feature_tar_to_command ;
  int config_feature_find_path ;
  int config_feature_hdparm_get_identity ;
  int config_feature_install_long_options ;
  int config_feature_chat_implicit_cr ;
  int config_passwd ;
  int config_feature_netstat_prg ;
  int config_kill ;
  int config_feature_call_telinit ;
  int config_feature_mount_fstab ;
  int config_feature_ip_rule ;
  int config_feature_check_tainted_module ;
  int config_stty ;
  int config_feature_utmp ;
  int config_feature_cpio_p ;
  int config_feature_username_completion ;
  int config_feature_test_64 ;
  int config_feature_find_type ;
  int config_include_susv2 ;
  int config_feature_mkdir_long_options ;
  int config_gunzip ;
  int config_expr_math_support_64 ;
  int config_feature_tftp_blocksize ;
  int config_delgroup ;
  int config_feature_ntpd_server ;
  int config_feature_ifupdown_ipv4 ;
  int config_feature_ls_username ;
  int config_feature_tar_oldgnu_compatibility ;
  int config_feature_diff_dir ;
  int config_feature_date_isofmt ;
  int config_feature_allow_exec ;
  int config_envuidgid ;
  int config_lfs ;
  int config_loadfont ;
  int config_feature_extra_quiet ;
  int config_feature_editing_ask_terminal ;
  int config_feature_sgi_label ;
  int config_feature_del_user_from_group ;
  int config_feature_httpd_config_with_script_interpr ;
  int config_feature_runsvdir_log ;
  int config_feature_aix_label ;
  int config_feature_addgroup_long_options ;
  int config_nc_server ;
  int config_feature_tar_autodetect ;
  int config_feature_wget_statusbar ;
  int config_feature_ip_route ;
  int config_feature_httpd_cgi ;
  int config_feature_vi_search ;
  int config_feature_ipc_syslog ;
  int config_feature_editing_fancy_prompt ;
  int config_deluser ;
  int config_feature_init_sctty ;
  int config_feature_tar_uname_gname ;
  int config_feature_acpid_compat ;
  int config_feature_httpd_set_remote_port_to_env ;
  int config_feature_ifupdown_ip ;
  int config_feature_volumeid_hfs ;
  int config_bunzip2 ;
  int config_feature_pidfile ;
  int config_verbose_resolution_errors ;
  int config_feature_find_inum ;
  int config_ubiattach ;
  int config_login_scripts ;
  int config_udhcpc ;
  int config_feature_mdev_rename ;
  int config_feature_dmesg_pretty ;
  int config_pmap ;
  int config_feature_ifconfig_status ;
  int config_feature_httpd_error_pages ;
  int config_feature_find_maxdepth ;
  int config_feature_udhcpc_arping ;
  int config_feature_setfiles_check_option ;
  int config_feature_find_group ;
  int config_feature_find_regex ;
  int config_feature_start_stop_daemon_fancy ;
  int config_addgroup ;
  int config_feature_ps_time ;
  int config_feature_httpd_encode_url_str ;
  int config_flash_unlock ;
  int config_feature_ps_wide ;
  int config_feature_inetd_support_builtin_daytime ;
  int config_devfsd_fg_np ;
  int config_feature_adduser_to_group ;
  int config_feature_fancy_echo ;
  int config_feature_tab_completion ;
  int config_traceroute6 ;
  int config_feature_volumeid_cramfs ;
  int config_nc_extra ;
  int config_feature_ifconfig_slip ;
  int config_feature_inetd_support_builtin_time ;
  int config_feature_tar_oldsun_compatibility ;
  int config_feature_ifupdown_external_dhcp ;
  int config_xz ;
  int config_feature_netstat_wide ;
  int config_feature_mdev_conf ;
  int config_feature_ipv6 ;
  int config_feature_volumeid_fat ;
  int config_monotonic_syscall ;
  int config_feature_volumeid_xfs ;
  int config_feature_inetd_support_builtin_discard ;
  int config_killall ;
  int config_feature_volumeid_udf ;
  int config_feature_check_unicode_in_env ;
  int config_feature_dd_signal_handling ;
  int config_feature_tr_equiv ;
  int config_feature_rmdir_long_options ;
  int config_feature_loadfont_raw ;
  int config_feature_run_parts_fancy ;
  int config_feature_tunctl_ug ;
  int config_feature_su_syslog ;
  int config_feature_dd_ibs_obs ;
  int config_feature_less_winch ;
  int config_feature_xargs_support_confirmation ;
  int config_chown ;
  int config_ls ;
  int config_feature_mount_helpers ;
  int config_feature_tar_from ;
  int config_feature_md5_sha1_sum_check ;
  int config_long_opts ;
  int config_feature_xargs_support_zero_term ;
  int config_feature_nameif_extended ;
  int config_ioctl_hex2str_error ;
  int config_feature_2_4_modules ;
  int config_feature_devfs ;
  int config_feature_eject_scsi ;
  int config_feature_tar_create ;
  int config_feature_telnetd_standalone ;
  int config_feature_mtab_support ;
  int config_feature_tar_selinux ;
  int config_feature_brctl_show ;
  int config_fdisk_support_large_disks ;
  int config_feature_inetd_rpc ;
  int config_feature_wc_large ;
  int config_feature_dd_third_status_line ;
  int config_chpst ;
  int config_feature_telnet_autologin ;
  int config_use_bb_crypt_sha ;
  int config_feature_modprobe_small_check_already_loaded ;
  int config_feature_hdparm_hdio_scan_hwif ;
  int config_feature_lsmod_pretty_2_6_output ;
  int config_expand ;
  int config_feature_less_brackets ;
  int config_feature_compress_bbconfig ;
  int config_logger ;
  int config_route ;
  int config_nc_110_compat ;
  int config_feature_prefer_ipv4_address ;
  int config_feature_mv_long_options ;
  int config_feature_hwclock_adjtime_fhs ;
  int config_feature_tftp_put ;
  int config_feature_prefer_applets ;
  int config_feature_traceroute_verbose ;
  int config_feature_ifconfig_broadcast_plus ;
  int config_feature_mount_fake ;
  int config_feature_unexpand_long_options ;
  int config_feature_devpts ;
  int config_feature_mkswap_uuid ;
  int config_feature_hexdump_reverse ;
  int config_tftpd ;
  int config_uudecode ;
  int config_feature_reformime_compat ;
  int config_feature_find_delete ;
  int config_feature_mount_loop_create ;
  int config_feature_fancy_sleep ;
  int config_feature_ls_timestamps ;
  int config_feature_brctl_fancy ;
  int config_syslogd ;
  int config_feature_fbset_readmode ;
  int config_feature_pidof_omit ;
  int config_feature_use_inittab ;
  int config_feature_chown_long_options ;
  int config_locale_support ;
  int config_feature_ip_address ;
  int config_nanddump ;
  int config_feature_start_stop_daemon_long_options ;
  int config_feature_hdparm_hdio_unregister_hwif ;
  int config_feature_ip_rare_protocols ;
  int config_feature_hwclock_long_options ;
  int config_desktop ;
  int config_scriptreplay ;
  int config_feature_vi_8bit ;
  int config_feature_nologin ;
  int config_dpkg_deb ;
  int config_fdflush ;
  int config_feature_find_context ;
  int config_feature_volumeid_linuxraid ;
  int config_feature_fancy_ping ;
  int config_feature_fancy_tail ;
  int config_build_libbusybox ;
  int config_feature_init_coredumps ;
  int config_sha256sum ;
  int config_feature_runcon_long_options ;
  int config_feature_find_mtime ;
  int config_feature_resize_print ;
  int config_use_bb_shadow ;
  int config_feature_fdisk_writable ;
  int config_envdir ;
  int config_feature_kill_removed ;
  int config_feature_volumeid_luks ;
  int config_feature_rotate_logfile ;
  int config_feature_mdev_rename_regexp ;
  int config_pgrep ;
  int config_feature_adduser_long_options ;
  int config_feature_ls_color ;
  int config_feature_vi_set ;
  int config_feature_sun_label ;
  int config_feature_chat_nofail ;
  int config_feature_unix_local ;
  int config_feature_date_compat ;
  int config_feature_getopt_long ;
  int config_feature_env_long_options ;
  int config_feature_hdparm_hdio_tristate_hwif ;
  int config_feature_crond_d ;
  int config_feature_use_termios ;
  int config_feature_swapon_pri ;
  int config_feature_passwd_weak_check ;
  int config_feature_vi_readonly ;
  int config_feature_vi_use_signals ;
  int config_feature_fdisk_advanced ;
  int config_feature_readlink_follow ;
  int config_rpm2cpio ;
  int config_feature_sort_big ;
  int config_feature_human_readable ;
  int config_feature_find_not ;
  int config_feature_udhcp_port ;
  int config_feature_modutils_symbols ;
  int config_ubidetach ;
  int config_feature_top_cpu_usage_percentage ;
  int config_sh_math_support_64 ;
  int config_feature_vi_ask_terminal ;
  int config_feature_wget_timeout ;
  int config_rpm ;
  int config_feature_udhcpd_write_leases_early ;
  int config_feature_httpd_ranges ;
  int config_feature_du_default_blocksize_1k ;
  int config_feature_insmod_ksymoops_symbols ;
  int config_feature_show_threads ;
  int config_feature_syslog ;
  int config_uncompress ;
  int config_feature_top_smp_process ;
  int config_feature_ifupdown_ipv6 ;
  int config_feature_setfont_textual_map ;
  int config_sestatus ;
  int config_feature_remote_log ;
  int config_feature_find_depth ;
  int config_feature_pidof_single ;
  int config_feature_find_paren ;
}  id2i;
void id2i_init()  {
  (id2i.config_lzop_compr_high = 0);
  (id2i.config_feature_unix_local = 0);
  (id2i.config_feature_volumeid_xfs = 0);
  (id2i.config_feature_insmod_load_map = 0);
  (id2i.config_cpio = 0);
  (id2i.config_feature_mount_loop_create = 0);
  (id2i.config_feature_less_regexp = 0);
  (id2i.config_feature_mv_long_options = 0);
  (id2i.config_feature_du_default_blocksize_1k = 0);
  (id2i.config_feature_tftp_put = 0);
  (id2i.config_feature_grep_egrep_alias = 0);
  (id2i.config_feature_httpd_error_pages = 0);
  (id2i.config_feature_fbset_readmode = 0);
  (id2i.config_debug = 0);
  (id2i.config_feature_find_context = 0);
  (id2i.config_feature_runcon_long_options = 0);
  (id2i.config_feature_ls_followlinks = 0);
  (id2i.config_feature_buffers_go_in_bss = 0);
  (id2i.config_feature_utmp = 0);
  (id2i.config_feature_df_fancy = 0);
  (id2i.config_feature_vi_optimize_cursor = 0);
  (id2i.config_feature_volumeid_reiserfs = 0);
  (id2i.config_feature_volumeid_romfs = 0);
  (id2i.config_feature_ifupdown_ipv6 = 0);
  (id2i.config_feature_udhcpc_arping = 0);
  (id2i.config_feature_find_maxdepth = 0);
  (id2i.config_pgrep = 0);
  (id2i.config_feature_chat_implicit_cr = 0);
  (id2i.config_feature_tftp_progress_bar = 0);
  (id2i.config_feature_tar_from = 0);
  (id2i.config_feature_ftpgetput_long_options = 0);
  (id2i.config_lzma = 0);
  (id2i.config_feature_editing_ask_terminal = 0);
  (id2i.config_feature_extra_quiet = 0);
  (id2i.config_feature_find_inum = 0);
  (id2i.config_feature_autowidth = 0);
  (id2i.config_tftpd = 0);
  (id2i.config_feature_rmdir_long_options = 0);
  (id2i.config_feature_less_flags = 0);
  (id2i.config_feature_inetd_support_builtin_discard = 0);
  (id2i.config_feature_udhcp_rfc3397 = 0);
  (id2i.config_feature_insmod_ksymoops_symbols = 0);
  (id2i.config_feature_lsmod_pretty_2_6_output = 0);
  (id2i.config_feature_setconsole_long_options = 0);
  (id2i.config_feature_mount_flags = 0);
  (id2i.config_ftpd = 0);
  (id2i.config_feature_loadfont_psf2 = 0);
  (id2i.config_feature_grep_context = 0);
  (id2i.config_feature_mdev_conf = 0);
  (id2i.config_feature_ifconfig_slip = 0);
  (id2i.config_feature_vi_colon = 0);
  (id2i.config_feature_runsvdir_log = 0);
  (id2i.config_chpasswd = 0);
  (id2i.config_delgroup = 0);
  (id2i.config_feature_init_sctty = 0);
  (id2i.config_feature_sort_big = 0);
  (id2i.config_feature_tar_create = 0);
  (id2i.config_nandwrite = 0);
  (id2i.config_feature_inetd_support_builtin_echo = 0);
  (id2i.config_sh_math_support_64 = 0);
  (id2i.config_feature_find_user = 0);
  (id2i.config_nc_server = 0);
  (id2i.config_unicode_using_locale = 0);
  (id2i.config_feature_dc_libm = 0);
  (id2i.config_feature_ps_unusual_systems = 0);
  (id2i.config_feature_chown_long_options = 0);
  (id2i.config_feature_unexpand_long_options = 0);
  (id2i.config_feature_devfs = 0);
  (id2i.config_feature_insmod_try_mmap = 0);
  (id2i.config_stty = 0);
  (id2i.config_feature_editing_vi = 0);
  (id2i.config_setuidgid = 0);
  (id2i.config_feature_chat_var_abort_len = 0);
  (id2i.config_fdisk_support_large_disks = 0);
  (id2i.config_unicode_preserve_broken = 0);
  (id2i.config_feature_xargs_support_confirmation = 0);
  (id2i.config_feature_adduser_to_group = 0);
  (id2i.config_feature_mdev_rename_regexp = 0);
  (id2i.config_feature_vi_setopts = 0);
  (id2i.config_feature_tar_long_options = 0);
  (id2i.config_tftp_debug = 0);
  (id2i.config_feature_call_telinit = 0);
  (id2i.config_feature_run_parts_fancy = 0);
  (id2i.config_feature_setfiles_check_option = 0);
  (id2i.config_ftpput = 0);
  (id2i.config_feature_readlink_follow = 0);
  (id2i.config_feature_check_tainted_module = 0);
  (id2i.config_feature_find_links = 0);
  (id2i.config_feature_tab_completion = 0);
  (id2i.config_hush = 0);
  (id2i.config_feature_volumeid_linuxraid = 0);
  (id2i.config_feature_find_type = 0);
  (id2i.config_feature_ar_create = 0);
  (id2i.config_feature_httpd_gzip = 0);
  (id2i.config_feature_install_long_options = 0);
  (id2i.config_feature_top_cpu_usage_percentage = 0);
  (id2i.config_envdir = 0);
  (id2i.config_feature_volumeid_ext = 0);
  (id2i.config_feature_udhcpd_write_leases_early = 0);
  (id2i.config_feature_modprobe_small_options_on_cmdline = 0);
  (id2i.config_feature_vi_dot_cmd = 0);
  (id2i.config_pam = 0);
  (id2i.config_feature_less_linenums = 0);
  (id2i.config_logger = 0);
  (id2i.config_sha256sum = 0);
  (id2i.config_feature_pidfile = 0);
  (id2i.config_sestatus = 0);
  (id2i.config_feature_ifconfig_status = 0);
  (id2i.config_feature_hdparm_hdio_tristate_hwif = 0);
  (id2i.config_feature_inetd_support_builtin_daytime = 0);
  (id2i.config_feature_ls_timestamps = 0);
  (id2i.config_feature_ifupdown_mapping = 0);
  (id2i.config_feature_mount_label = 0);
  (id2i.config_feature_find_paren = 0);
  (id2i.config_feature_tar_gnu_extensions = 0);
  (id2i.config_feature_volumeid_sysv = 0);
  (id2i.config_feature_resize_print = 0);
  (id2i.config_feature_wget_authentication = 0);
  (id2i.config_feature_adduser_long_options = 0);
  (id2i.config_feature_sun_label = 0);
  (id2i.config_ubidetach = 0);
  (id2i.config_feature_fancy_tail = 0);
  (id2i.config_feature_mkswap_uuid = 0);
  (id2i.config_scriptreplay = 0);
  (id2i.config_feature_remote_log = 0);
  (id2i.config_include_susv2 = 0);
  (id2i.config_feature_traceroute_source_route = 0);
  (id2i.config_feature_shadowpasswds = 0);
  (id2i.config_feature_date_nano = 0);
  (id2i.config_softlimit = 0);
  (id2i.config_feature_awk_libm = 0);
  (id2i.config_feature_ifconfig_hw = 0);
  (id2i.config_hd = 0);
  (id2i.config_feature_ipcalc_long_options = 0);
  (id2i.config_feature_mkdir_long_options = 0);
  (id2i.config_feature_hdparm_hdio_unregister_hwif = 0);
  (id2i.config_feature_volumeid_jfs = 0);
  (id2i.config_bunzip2 = 0);
  (id2i.config_kill = 0);
  (id2i.config_verbose_resolution_errors = 0);
  (id2i.config_feature_ipv6 = 0);
  (id2i.config_feature_httpd_set_remote_port_to_env = 0);
  (id2i.config_feature_tar_uname_gname = 0);
  (id2i.config_feature_fast_top = 0);
  (id2i.config_feature_ls_color_is_default = 0);
  (id2i.config_feature_tunctl_ug = 0);
  (id2i.config_feature_shared_busybox = 0);
  (id2i.config_feature_aix_label = 0);
  (id2i.config_feature_vi_use_signals = 0);
  (id2i.config_feature_vi_win_resize = 0);
  (id2i.config_test = 0);
  (id2i.config_feature_osf_label = 0);
  (id2i.config_passwd = 0);
  (id2i.config_feature_seamless_gz = 0);
  (id2i.config_loadfont = 0);
  (id2i.config_feature_crond_call_sendmail = 0);
  (id2i.config_add_shell = 0);
  (id2i.config_feature_pidof_single = 0);
  (id2i.config_feature_httpd_ranges = 0);
  (id2i.config_feature_username_completion = 0);
  (id2i.config_feature_volumeid_luks = 0);
  (id2i.config_traceroute6 = 0);
  (id2i.config_feature_modutils_symbols = 0);
  (id2i.config_addgroup = 0);
  (id2i.config_feature_telnetd_inetd_wait = 0);
  (id2i.config_killall5 = 0);
  (id2i.config_feature_syslog = 0);
  (id2i.config_feature_tar_selinux = 0);
  (id2i.config_feature_httpd_cgi = 0);
  (id2i.config_feature_find_newer = 0);
  (id2i.config_feature_tftp_blocksize = 0);
  (id2i.config_feature_find_mmin = 0);
  (id2i.config_dpkg_deb = 0);
  (id2i.config_feature_find_path = 0);
  (id2i.config_feature_compress_bbconfig = 0);
  (id2i.config_ping6 = 0);
  (id2i.config_unxz = 0);
  (id2i.config_build_libbusybox = 0);
  (id2i.config_long_opts = 0);
  (id2i.config_ash_builtin_printf = 0);
  (id2i.config_feature_netstat_prg = 0);
  (id2i.config_rpm2cpio = 0);
  (id2i.config_feature_insmod_loadinkmem = 0);
  (id2i.config_feature_ip_link = 0);
  (id2i.config_feature_dd_signal_handling = 0);
  (id2i.config_feature_use_inittab = 0);
  (id2i.config_feature_top_smp_process = 0);
  (id2i.config_feature_nologin = 0);
  (id2i.config_feature_brctl_show = 0);
  (id2i.config_feature_grep_fgrep_alias = 0);
  (id2i.config_feature_ifupdown_ip = 0);
  (id2i.config_feature_httpd_setuid = 0);
  (id2i.config_fdflush = 0);
  (id2i.config_feature_reformime_compat = 0);
  (id2i.config_feature_hdparm_hdio_scan_hwif = 0);
  (id2i.config_ioctl_hex2str_error = 0);
  (id2i.config_feature_run_parts_long_options = 0);
  (id2i.config_feature_volumeid_iso9660 = 0);
  (id2i.config_feature_find_not = 0);
  (id2i.config_feature_inetd_rpc = 0);
  (id2i.config_feature_ls_recursive = 0);
  (id2i.config_devfsd_modload = 0);
  (id2i.config_feature_cpio_p = 0);
  (id2i.config_feature_tar_oldgnu_compatibility = 0);
  (id2i.config_feature_less_dashcmd = 0);
  (id2i.config_echo = 0);
  (id2i.config_feature_xargs_support_termopt = 0);
  (id2i.config_feature_tee_use_block_io = 0);
  (id2i.config_feature_ip_tunnel = 0);
  (id2i.config_use_bb_crypt_sha = 0);
  (id2i.config_feature_show_threads = 0);
  (id2i.config_feature_mdev_load_firmware = 0);
  (id2i.config_feature_udhcp_port = 0);
  (id2i.config_syslogd = 0);
  (id2i.config_ls = 0);
  (id2i.config_feature_mount_verbose = 0);
  (id2i.config_feature_swapon_pri = 0);
  (id2i.config_locale_support = 0);
  (id2i.config_feature_diff_dir = 0);
  (id2i.config_feature_chcon_long_options = 0);
  (id2i.config_feature_verbose_cp_message = 0);
  (id2i.config_feature_dd_ibs_obs = 0);
  (id2i.config_feature_popmaildir_delivery = 0);
  (id2i.config_feature_ip_rule = 0);
  (id2i.config_feature_chat_tty_hifi = 0);
  (id2i.config_feature_minix2 = 0);
  (id2i.config_feature_mount_fake = 0);
  (id2i.config_feature_vi_yankmark = 0);
  (id2i.config_feature_diff_long_options = 0);
  (id2i.config_feature_del_user_from_group = 0);
  (id2i.config_printf = 0);
  (id2i.config_nommu = 0);
  (id2i.config_feature_init_coredumps = 0);
  (id2i.config_gunzip = 0);
  (id2i.config_feature_find_exec = 0);
  (id2i.config_feature_human_readable = 0);
  (id2i.config_feature_seamless_lzma = 0);
  (id2i.config_feature_less_brackets = 0);
  (id2i.config_tftp = 0);
  (id2i.config_feature_2_4_modules = 0);
  (id2i.config_devfsd_verbose = 0);
  (id2i.config_feature_split_fancy = 0);
  (id2i.config_feature_xargs_support_quotes = 0);
  (id2i.config_feature_dmesg_pretty = 0);
  (id2i.config_feature_loadfont_raw = 0);
  (id2i.config_feature_top_cpu_global_percents = 0);
  (id2i.config_xz = 0);
  (id2i.config_feature_allow_exec = 0);
  (id2i.config_feature_fbset_fancy = 0);
  (id2i.config_feature_volumeid_cramfs = 0);
  (id2i.config_feature_volumeid_fat = 0);
  (id2i.config_udhcpc = 0);
  (id2i.config_feature_ifupdown_ipv4 = 0);
  (id2i.config_pkill = 0);
  (id2i.config_install_no_usr = 0);
  (id2i.config_feature_cp_long_options = 0);
  (id2i.config_rpm = 0);
  (id2i.config_feature_expand_long_options = 0);
  (id2i.config_feature_non_posix_cp = 0);
  (id2i.config_feature_prefer_ipv4_address = 0);
  (id2i.config_feature_volumeid_ntfs = 0);
  (id2i.config_feature_cpio_o = 0);
  (id2i.config_feature_less_marks = 0);
  (id2i.config_feature_mount_loop = 0);
  (id2i.config_feature_ipc_syslog = 0);
  (id2i.config_feature_prefer_applets = 0);
  (id2i.config_feature_seamless_xz = 0);
  (id2i.config_feature_insmod_version_checking = 0);
  (id2i.config_feature_ar_long_filenames = 0);
  (id2i.config_feature_tftp_get = 0);
  (id2i.config_feature_httpd_encode_url_str = 0);
  (id2i.config_setfont = 0);
  (id2i.config_feature_devpts = 0);
  (id2i.config_feature_ntpd_server = 0);
  (id2i.config_envuidgid = 0);
  (id2i.config_feature_mount_cifs = 0);
  (id2i.config_feature_makedevs_table = 0);
  (id2i.config_feature_ls_filetypes = 0);
  (id2i.config_feature_env_long_options = 0);
  (id2i.config_feature_vi_readonly = 0);
  (id2i.config_feature_nameif_extended = 0);
  (id2i.config_feature_bootchartd_config_file = 0);
  (id2i.config_feature_mdev_rename = 0);
  (id2i.config_feature_date_compat = 0);
  (id2i.config_login_scripts = 0);
  (id2i.config_feature_volumeid_btrfs = 0);
  (id2i.config_feature_ps_wide = 0);
  (id2i.config_expr_math_support_64 = 0);
  (id2i.config_feature_start_stop_daemon_fancy = 0);
  (id2i.config_feature_float_sleep = 0);
  (id2i.config_feature_klogd_klogctl = 0);
  (id2i.config_feature_tar_autodetect = 0);
  (id2i.config_route = 0);
  (id2i.config_freeramdisk = 0);
  (id2i.config_feature_lzma_fast = 0);
  (id2i.config_nc_extra = 0);
  (id2i.config_feature_mtab_support = 0);
  (id2i.config_du = 0);
  (id2i.config_feature_ls_username = 0);
  (id2i.config_feature_editing_savehistory = 0);
  (id2i.config_use_portable_code = 0);
  (id2i.config_feature_logread_reduced_locking = 0);
  (id2i.config_feature_telnet_autologin = 0);
  (id2i.config_feature_tar_to_command = 0);
  (id2i.config_feature_find_xdev = 0);
  (id2i.config_feature_httpd_proxy = 0);
  (id2i.config_chpst = 0);
  (id2i.config_feature_seamless_z = 0);
  (id2i.config_feature_chat_clr_abort = 0);
  (id2i.config_feature_bootchartd_bloated_header = 0);
  (id2i.config_feature_ftp_write = 0);
  (id2i.config_feature_use_termios = 0);
  (id2i.config_lfs = 0);
  (id2i.config_feature_mount_fstab = 0);
  (id2i.config_feature_ip_rare_protocols = 0);
  (id2i.config_deluser = 0);
  (id2i.config_feature_ps_time = 0);
  (id2i.config_feature_tr_equiv = 0);
  (id2i.config_feature_vi_set = 0);
  (id2i.config_base64 = 0);
  (id2i.config_pmap = 0);
  (id2i.config_feature_chat_swallow_opts = 0);
  (id2i.config_flash_lock = 0);
  (id2i.config_ftpget = 0);
  (id2i.config_feature_init_syslog = 0);
  (id2i.config_feature_ifconfig_memstart_ioaddr_irq = 0);
  (id2i.config_nanddump = 0);
  (id2i.config_unlzma = 0);
  (id2i.config_feature_insmod_load_map_full = 0);
  (id2i.config_feature_find_group = 0);
  (id2i.config_feature_wc_large = 0);
  (id2i.config_feature_ps_additional_columns = 0);
  (id2i.config_feature_inetd_support_builtin_time = 0);
  (id2i.config_unicode_support = 0);
  (id2i.config_feature_fancy_head = 0);
  (id2i.config_feature_etc_networks = 0);
  (id2i.config_chown = 0);
  (id2i.config_feature_stat_format = 0);
  (id2i.config_feature_acpid_compat = 0);
  (id2i.config_feature_vi_ask_terminal = 0);
  (id2i.config_feature_fdisk_advanced = 0);
  (id2i.config_feature_tr_classes = 0);
  (id2i.config_feature_top_decimals = 0);
  (id2i.config_feature_modprobe_small_check_already_loaded = 0);
  (id2i.config_feature_telnet_ttype = 0);
  (id2i.config_feature_passwd_weak_check = 0);
  (id2i.config_feature_seamless_bz2 = 0);
  (id2i.config_tar = 0);
  (id2i.config_use_bb_shadow = 0);
  (id2i.config_use_bb_pwd_grp = 0);
  (id2i.config_feature_traceroute_use_icmp = 0);
  (id2i.config_feature_httpd_use_sendfile = 0);
  (id2i.config_flash_unlock = 0);
  (id2i.config_feature_editing_fancy_prompt = 0);
  (id2i.config_feature_ifconfig_broadcast_plus = 0);
  (id2i.config_feature_ftpd_accept_broken_list = 0);
  (id2i.config_sha1sum = 0);
  (id2i.config_feature_hdparm_hdio_drive_reset = 0);
  (id2i.config_feature_inetd_support_builtin_chargen = 0);
  (id2i.config_feature_modutils_alias = 0);
  (id2i.config_feature_volumeid_hfs = 0);
  (id2i.config_killall = 0);
  (id2i.config_nc_110_compat = 0);
  (id2i.config_feature_httpd_config_with_script_interpr = 0);
  (id2i.config_uncompress = 0);
  (id2i.config_feature_find_mtime = 0);
  (id2i.config_feature_find_regex = 0);
  (id2i.config_feature_fdisk_writable = 0);
  (id2i.config_adduser = 0);
  (id2i.config_feature_vi_search = 0);
  (id2i.config_feature_wget_timeout = 0);
  (id2i.config_ubiattach = 0);
  (id2i.config_feature_test_64 = 0);
  (id2i.config_feature_su_checks_shells = 0);
  (id2i.config_feature_mdev_exec = 0);
  (id2i.config_feature_hwclock_long_options = 0);
  (id2i.config_use_bb_crypt = 0);
  (id2i.config_desktop = 0);
  (id2i.config_feature_check_unicode_in_env = 0);
  (id2i.config_feature_pidof_omit = 0);
  (id2i.config_feature_start_stop_daemon_long_options = 0);
  (id2i.config_feature_umount_all = 0);
  (id2i.config_sha512sum = 0);
  (id2i.config_feature_hdparm_hdio_getset_dma = 0);
  (id2i.config_feature_hexdump_reverse = 0);
  (id2i.config_feature_ip_route = 0);
  (id2i.config_feature_ipcalc_fancy = 0);
  (id2i.config_feature_taskset_fancy = 0);
  (id2i.config_feature_ifupdown_external_dhcp = 0);
  (id2i.config_feature_volumeid_ocfs2 = 0);
  (id2i.config_feature_tar_nopreserve_time = 0);
  (id2i.config_uudecode = 0);
  (id2i.config_feature_find_size = 0);
  (id2i.config_feature_preserve_hardlinks = 0);
  (id2i.config_feature_mount_nfs = 0);
  (id2i.config_feature_chat_send_escapes = 0);
  (id2i.config_md5sum = 0);
  (id2i.config_feature_individual = 0);
  (id2i.config_feature_sgi_label = 0);
  (id2i.config_feature_find_delete = 0);
  (id2i.config_feature_find_prune = 0);
  (id2i.config_feature_top_smp_cpu = 0);
  (id2i.config_feature_ip_address = 0);
  (id2i.config_feature_syslogd_dup = 0);
  (id2i.config_feature_check_names = 0);
  (id2i.config_feature_hwclock_adjtime_fhs = 0);
  (id2i.config_feature_buffers_go_on_stack = 0);
  (id2i.config_feature_ls_color = 0);
  (id2i.config_feature_getopt_long = 0);
  (id2i.config_pidof = 0);
  (id2i.config_unicode_wide_wchars = 0);
  (id2i.config_feature_fancy_sleep = 0);
  (id2i.config_feature_makedevs_leaf = 0);
  (id2i.config_feature_kill_removed = 0);
  (id2i.config_monotonic_syscall = 0);
  (id2i.config_feature_volumeid_udf = 0);
  (id2i.config_feature_find_depth = 0);
  (id2i.config_feature_gzip_long_options = 0);
  (id2i.config_feature_md5_sha1_sum_check = 0);
  (id2i.config_feature_less_winch = 0);
  (id2i.config_feature_mount_helpers = 0);
  (id2i.config_devfsd_fg_np = 0);
  (id2i.config_feature_fancy_echo = 0);
  (id2i.config_feature_find_print0 = 0);
  (id2i.config_unexpand = 0);
  (id2i.config_feature_su_syslog = 0);
  (id2i.config_feature_eject_scsi = 0);
  (id2i.config_dpkg = 0);
  (id2i.config_feature_setfont_textual_map = 0);
  (id2i.config_feature_topmem = 0);
  (id2i.config_feature_netstat_wide = 0);
  (id2i.config_feature_dd_third_status_line = 0);
  (id2i.config_feature_securetty = 0);
  (id2i.config_swaponoff = 0);
  (id2i.config_feature_vi_8bit = 0);
  (id2i.config_feature_rotate_logfile = 0);
  (id2i.config_remove_shell = 0);
  (id2i.config_feature_traceroute_verbose = 0);
  (id2i.config_feature_clean_up = 0);
  (id2i.config_feature_httpd_basic_auth = 0);
  (id2i.config_feature_date_isofmt = 0);
  (id2i.config_feature_hwib = 0);
  (id2i.config_selinux = 0);
  (id2i.config_feature_hdparm_get_identity = 0);
  (id2i.config_feature_chat_nofail = 0);
  (id2i.config_feature_volumeid_linuxswap = 0);
  (id2i.config_feature_addgroup_long_options = 0);
  (id2i.config_feature_crond_d = 0);
  (id2i.config_feature_tar_oldsun_compatibility = 0);
  (id2i.config_feature_telnetd_standalone = 0);
  (id2i.config_feature_httpd_auth_md5 = 0);
  (id2i.config_feature_modprobe_blacklist = 0);
  (id2i.config_feature_initrd = 0);
  (id2i.config_feature_find_perm = 0);
  (id2i.config_feature_wget_statusbar = 0);
  (id2i.config_feature_brctl_fancy = 0);
  (id2i.config_feature_ls_sortfiles = 0);
  (id2i.config_feature_xargs_support_zero_term = 0);
  (id2i.config_feature_fancy_ping = 0);
  (id2i.config_expand = 0);
}
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;
typedef long int int64_t;
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
typedef long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
typedef int bb__aliased_int __attribute__((__may_alias__));
typedef uint16_t bb__aliased_uint16_t __attribute__((__may_alias__));
typedef uint32_t bb__aliased_uint32_t __attribute__((__may_alias__));
typedef signed char smallint;
typedef unsigned char smalluint;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct   {
  int __val[2] ;
}  __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef long int __swblk_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void *__timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __ssize_t;
typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
enum  {
  _ISupper = ((0 < 8) ? ((1 << 0) << 8) : ((1 << 0) >> 8)),
  _ISlower = ((1 < 8) ? ((1 << 1) << 8) : ((1 << 1) >> 8)),
  _ISalpha = ((2 < 8) ? ((1 << 2) << 8) : ((1 << 2) >> 8)),
  _ISdigit = ((3 < 8) ? ((1 << 3) << 8) : ((1 << 3) >> 8)),
  _ISxdigit = ((4 < 8) ? ((1 << 4) << 8) : ((1 << 4) >> 8)),
  _ISspace = ((5 < 8) ? ((1 << 5) << 8) : ((1 << 5) >> 8)),
  _ISprint = ((6 < 8) ? ((1 << 6) << 8) : ((1 << 6) >> 8)),
  _ISgraph = ((7 < 8) ? ((1 << 7) << 8) : ((1 << 7) >> 8)),
  _ISblank = ((8 < 8) ? ((1 << 8) << 8) : ((1 << 8) >> 8)),
  _IScntrl = ((9 < 8) ? ((1 << 9) << 8) : ((1 << 9) >> 8)),
  _ISpunct = ((10 < 8) ? ((1 << 10) << 8) : ((1 << 10) >> 8)),
  _ISalnum = ((11 < 8) ? ((1 << 11) << 8) : ((1 << 11) >> 8))
} ;
extern const unsigned short int **__ctype_b_loc(void ) __attribute__((__nothrow__)) __attribute__((const));
extern const __int32_t **__ctype_tolower_loc(void ) __attribute__((__nothrow__)) __attribute__((const));
extern const __int32_t **__ctype_toupper_loc(void ) __attribute__((__nothrow__)) __attribute__((const));
extern int isalnum(int ) __attribute__((__nothrow__));
extern int isalpha(int ) __attribute__((__nothrow__));
extern int iscntrl(int ) __attribute__((__nothrow__));
extern int isdigit(int ) __attribute__((__nothrow__));
extern int islower(int ) __attribute__((__nothrow__));
extern int isgraph(int ) __attribute__((__nothrow__));
extern int isprint(int ) __attribute__((__nothrow__));
extern int ispunct(int ) __attribute__((__nothrow__));
extern int isspace(int ) __attribute__((__nothrow__));
extern int isupper(int ) __attribute__((__nothrow__));
extern int isxdigit(int ) __attribute__((__nothrow__));
extern int tolower(int __c ) __attribute__((__nothrow__));
extern int toupper(int __c ) __attribute__((__nothrow__));
extern int isblank(int ) __attribute__((__nothrow__));
extern int isctype(int __c , int __mask ) __attribute__((__nothrow__));
extern int isascii(int __c ) __attribute__((__nothrow__));
extern int toascii(int __c ) __attribute__((__nothrow__));
extern int _toupper(int ) __attribute__((__nothrow__));
extern int _tolower(int ) __attribute__((__nothrow__));
typedef struct  __locale_struct {
  struct  __locale_data   *__locales[13] ;
  const  unsigned  short  int *__ctype_b ;
  const  int *__ctype_tolower ;
  const  int *__ctype_toupper ;
  const  char *__names[13] ;
}  *__locale_t;
typedef __locale_t locale_t;
extern int isalnum_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isalpha_l(int , __locale_t ) __attribute__((__nothrow__));
extern int iscntrl_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isdigit_l(int , __locale_t ) __attribute__((__nothrow__));
extern int islower_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isgraph_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isprint_l(int , __locale_t ) __attribute__((__nothrow__));
extern int ispunct_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isspace_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isupper_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isxdigit_l(int , __locale_t ) __attribute__((__nothrow__));
extern int isblank_l(int , __locale_t ) __attribute__((__nothrow__));
extern int __tolower_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
extern int tolower_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
extern int __toupper_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
extern int toupper_l(int __c , __locale_t __l ) __attribute__((__nothrow__));
typedef __ino_t ino_t;
typedef __ino64_t ino64_t;
struct  dirent {
  __ino_t d_ino ;
  __off_t d_off ;
  unsigned  short  int d_reclen ;
  unsigned  char d_type ;
  char d_name[256] ;
}  ;
struct  dirent64 {
  __ino64_t d_ino ;
  __off64_t d_off ;
  unsigned  short  int d_reclen ;
  unsigned  char d_type ;
  char d_name[256] ;
}  ;
enum  {
  DT_UNKNOWN = 0,
  DT_FIFO = 1,
  DT_CHR = 2,
  DT_DIR = 4,
  DT_BLK = 6,
  DT_REG = 8,
  DT_LNK = 10,
  DT_SOCK = 12,
  DT_WHT = 14
} ;
typedef struct  __dirstream   DIR;
extern DIR *opendir(const  char *__name ) __attribute__((__nonnull__ (1)));
extern DIR *fdopendir(int __fd );
extern int closedir(DIR *__dirp ) __attribute__((__nonnull__ (1)));
extern struct  dirent   *readdir(DIR *__dirp ) __attribute__((__nonnull__ (1)));
extern struct  dirent64   *readdir64(DIR *__dirp ) __attribute__((__nonnull__ (1)));
extern int readdir_r(DIR *__restrict __dirp , struct  dirent   *__restrict __entry , struct  dirent   **__restrict __result ) __attribute__((__nonnull__ (1, 2, 3)));
extern int readdir64_r(DIR *__restrict __dirp , struct  dirent64   *__restrict __entry , struct  dirent64   **__restrict __result ) __attribute__((__nonnull__ (1, 2, 3)));
extern void rewinddir(DIR *__dirp ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void seekdir(DIR *__dirp , long  int __pos ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int telldir(DIR *__dirp ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int dirfd(DIR *__dirp ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
typedef long unsigned int size_t;
extern int scandir(const  char *__restrict __dir , struct  dirent   ***__restrict __namelist , int ( *__selector)(const  struct  dirent   * ) , int ( *__cmp)(const  struct  dirent   ** , const  struct  dirent   ** ) ) __attribute__((__nonnull__ (1, 2)));
extern int scandir64(const  char *__restrict __dir , struct  dirent64   ***__restrict __namelist , int ( *__selector)(const  struct  dirent64   * ) , int ( *__cmp)(const  struct  dirent64   ** , const  struct  dirent64   ** ) ) __attribute__((__nonnull__ (1, 2)));
extern int alphasort(const  struct  dirent   **__e1 , const  struct  dirent   **__e2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int alphasort64(const  struct  dirent64   **__e1 , const  struct  dirent64   **__e2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern __ssize_t getdirentries(int __fd , char *__restrict __buf , size_t __nbytes , __off_t *__restrict __basep ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern __ssize_t getdirentries64(int __fd , char *__restrict __buf , size_t __nbytes , __off64_t *__restrict __basep ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int versionsort(const  struct  dirent   **__e1 , const  struct  dirent   **__e2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int versionsort64(const  struct  dirent64   **__e1 , const  struct  dirent64   **__e2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int *__errno_location(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern char *program_invocation_name, *program_invocation_short_name;
typedef int error_t;
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;
typedef __loff_t loff_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __uid_t uid_t;
typedef __off_t off_t;
typedef __off64_t off64_t;
typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;
typedef __key_t key_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
typedef __clockid_t clockid_t;
typedef __timer_t timer_t;
typedef __useconds_t useconds_t;
typedef __suseconds_t suseconds_t;
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef unsigned int u_int8_t __attribute__((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__((__mode__ (__DI__)));
typedef int register_t __attribute__((__mode__ (__word__)));
typedef int __sig_atomic_t;
typedef struct   {
  unsigned  long  int __val[(1024 / (8 * sizeof(unsigned  long  int )))] ;
}  __sigset_t;
typedef __sigset_t sigset_t;
struct  timespec {
  __time_t tv_sec ;
  long  int tv_nsec ;
}  ;
struct  timeval {
  __time_t tv_sec ;
  __suseconds_t tv_usec ;
}  ;
typedef long int __fd_mask;
typedef struct   {
  __fd_mask fds_bits[(1024 / (8 * ((int ) sizeof(__fd_mask ))))] ;
}  fd_set;
typedef __fd_mask fd_mask;
extern int select(int __nfds , fd_set *__restrict __readfds , fd_set *__restrict __writefds , fd_set *__restrict __exceptfds , struct  timeval   *__restrict __timeout );
extern int pselect(int __nfds , fd_set *__restrict __readfds , fd_set *__restrict __writefds , fd_set *__restrict __exceptfds , const  struct  timespec   *__restrict __timeout , const  __sigset_t *__restrict __sigmask );
extern unsigned int gnu_dev_major(unsigned  long  long  int __dev ) __attribute__((__nothrow__));
extern unsigned int gnu_dev_minor(unsigned  long  long  int __dev ) __attribute__((__nothrow__));
extern unsigned long long int gnu_dev_makedev(unsigned  int __major , unsigned  int __minor ) __attribute__((__nothrow__));
typedef __blksize_t blksize_t;
typedef __blkcnt_t blkcnt_t;
typedef __fsblkcnt_t fsblkcnt_t;
typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
typedef unsigned long int pthread_t;
typedef union   {
  char __size[56] ;
  long  int __align ;
}  pthread_attr_t;
typedef struct  __pthread_internal_list {
  struct  __pthread_internal_list   *__prev ;
  struct  __pthread_internal_list   *__next ;
}  __pthread_list_t;
typedef union   {
  struct  __pthread_mutex_s {
    int __lock ;
    unsigned  int __count ;
    int __owner ;
    unsigned  int __nusers ;
    int __kind ;
    int __spins ;
    __pthread_list_t __list ;
  }  __data ;
  char __size[40] ;
  long  int __align ;
}  pthread_mutex_t;
typedef union   {
  char __size[4] ;
  int __align ;
}  pthread_mutexattr_t;
typedef union   {
  struct   {
    int __lock ;
    unsigned  int __futex ;
    unsigned  long  long  int __total_seq ;
    unsigned  long  long  int __wakeup_seq ;
    unsigned  long  long  int __woken_seq ;
    void *__mutex ;
    unsigned  int __nwaiters ;
    unsigned  int __broadcast_seq ;
  }  __data ;
  char __size[48] ;
  long  long  int __align ;
}  pthread_cond_t;
typedef union   {
  char __size[4] ;
  int __align ;
}  pthread_condattr_t;
typedef unsigned int pthread_key_t;
typedef int pthread_once_t;
typedef union   {
  struct   {
    int __lock ;
    unsigned  int __nr_readers ;
    unsigned  int __readers_wakeup ;
    unsigned  int __writer_wakeup ;
    unsigned  int __nr_readers_queued ;
    unsigned  int __nr_writers_queued ;
    int __writer ;
    int __shared ;
    unsigned  long  int __pad1 ;
    unsigned  long  int __pad2 ;
    unsigned  int __flags ;
  }  __data ;
  char __size[56] ;
  long  int __align ;
}  pthread_rwlock_t;
typedef union   {
  char __size[8] ;
  long  int __align ;
}  pthread_rwlockattr_t;
typedef volatile int pthread_spinlock_t;
typedef union   {
  char __size[32] ;
  long  int __align ;
}  pthread_barrier_t;
typedef union   {
  char __size[4] ;
  int __align ;
}  pthread_barrierattr_t;
struct  iovec {
  void *iov_base ;
  size_t iov_len ;
}  ;
struct  flock {
  short  int l_type ;
  short  int l_whence ;
  __off_t l_start ;
  __off_t l_len ;
  __pid_t l_pid ;
}  ;
struct  flock64 {
  short  int l_type ;
  short  int l_whence ;
  __off64_t l_start ;
  __off64_t l_len ;
  __pid_t l_pid ;
}  ;
enum __pid_type {
  F_OWNER_TID = 0,
  F_OWNER_PID,
  F_OWNER_PGRP,
  F_OWNER_GID = F_OWNER_PGRP
} ;
struct  f_owner_ex {
  enum __pid_type type ;
  __pid_t pid ;
}  ;
extern ssize_t readahead(int __fd , __off64_t __offset , size_t __count ) __attribute__((__nothrow__));
extern int sync_file_range(int __fd , __off64_t __offset , __off64_t __count , unsigned  int __flags );
extern ssize_t vmsplice(int __fdout , const  struct  iovec   *__iov , size_t __count , unsigned  int __flags );
extern ssize_t splice(int __fdin , __off64_t *__offin , int __fdout , __off64_t *__offout , size_t __len , unsigned  int __flags );
extern ssize_t tee(int __fdin , int __fdout , size_t __len , unsigned  int __flags );
extern int fallocate(int __fd , int __mode , __off_t __offset , __off_t __len );
extern int fallocate64(int __fd , int __mode , __off64_t __offset , __off64_t __len );
struct  stat {
  __dev_t st_dev ;
  __ino_t st_ino ;
  __nlink_t st_nlink ;
  __mode_t st_mode ;
  __uid_t st_uid ;
  __gid_t st_gid ;
  int __pad0 ;
  __dev_t st_rdev ;
  __off_t st_size ;
  __blksize_t st_blksize ;
  __blkcnt_t st_blocks ;
  struct  timespec   st_atim ;
  struct  timespec   st_mtim ;
  struct  timespec   st_ctim ;
  long  int __unused[3] ;
}  ;
struct  stat64 {
  __dev_t st_dev ;
  __ino64_t st_ino ;
  __nlink_t st_nlink ;
  __mode_t st_mode ;
  __uid_t st_uid ;
  __gid_t st_gid ;
  int __pad0 ;
  __dev_t st_rdev ;
  __off_t st_size ;
  __blksize_t st_blksize ;
  __blkcnt64_t st_blocks ;
  struct  timespec   st_atim ;
  struct  timespec   st_mtim ;
  struct  timespec   st_ctim ;
  long  int __unused[3] ;
}  ;
extern int fcntl(int __fd , int __cmd , ...);
extern int open(const  char *__file , int __oflag , ...) __attribute__((__nonnull__ (1)));
extern int open64(const  char *__file , int __oflag , ...) __attribute__((__nonnull__ (1)));
extern int openat(int __fd , const  char *__file , int __oflag , ...) __attribute__((__nonnull__ (2)));
extern int openat64(int __fd , const  char *__file , int __oflag , ...) __attribute__((__nonnull__ (2)));
extern int creat(const  char *__file , __mode_t __mode ) __attribute__((__nonnull__ (1)));
extern int creat64(const  char *__file , __mode_t __mode ) __attribute__((__nonnull__ (1)));
extern int lockf(int __fd , int __cmd , __off_t __len );
extern int lockf64(int __fd , int __cmd , __off64_t __len );
extern int posix_fadvise(int __fd , __off_t __offset , __off_t __len , int __advise ) __attribute__((__nothrow__));
extern int posix_fadvise64(int __fd , __off64_t __offset , __off64_t __len , int __advise ) __attribute__((__nothrow__));
extern int posix_fallocate(int __fd , __off_t __offset , __off_t __len );
extern int posix_fallocate64(int __fd , __off64_t __offset , __off64_t __len );
typedef int __gwchar_t;
typedef struct   {
  long  int quot ;
  long  int rem ;
}  imaxdiv_t;
extern intmax_t imaxabs(intmax_t __n ) __attribute__((__nothrow__)) __attribute__((__const__));
extern imaxdiv_t imaxdiv(intmax_t __numer , intmax_t __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern intmax_t strtoimax(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__));
extern uintmax_t strtoumax(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__));
extern intmax_t wcstoimax(const  __gwchar_t *__restrict __nptr , __gwchar_t **__restrict __endptr , int __base ) __attribute__((__nothrow__));
extern uintmax_t wcstoumax(const  __gwchar_t *__restrict __nptr , __gwchar_t **__restrict __endptr , int __base ) __attribute__((__nothrow__));
extern ssize_t readv(int __fd , const  struct  iovec   *__iovec , int __count );
extern ssize_t writev(int __fd , const  struct  iovec   *__iovec , int __count );
extern ssize_t preadv(int __fd , const  struct  iovec   *__iovec , int __count , __off_t __offset );
extern ssize_t pwritev(int __fd , const  struct  iovec   *__iovec , int __count , __off_t __offset );
extern ssize_t preadv64(int __fd , const  struct  iovec   *__iovec , int __count , __off64_t __offset );
extern ssize_t pwritev64(int __fd , const  struct  iovec   *__iovec , int __count , __off64_t __offset );
typedef __socklen_t socklen_t;
enum __socket_type {
  SOCK_STREAM = 1,
  SOCK_DGRAM = 2,
  SOCK_RAW = 3,
  SOCK_RDM = 4,
  SOCK_SEQPACKET = 5,
  SOCK_DCCP = 6,
  SOCK_PACKET = 10,
  SOCK_CLOEXEC = 02000000,
  SOCK_NONBLOCK = 04000
} ;
typedef unsigned short int sa_family_t;
struct  sockaddr {
  sa_family_t sa_family ;
  char sa_data[14] ;
}  ;
struct  sockaddr_storage {
  sa_family_t ss_family ;
  unsigned  long  int __ss_align ;
  char __ss_padding[(128 - (2 * sizeof(unsigned  long  int )))] ;
}  ;
enum  {
  MSG_OOB = 0x01,
  MSG_PEEK = 0x02,
  MSG_DONTROUTE = 0x04,
  MSG_TRYHARD = MSG_DONTROUTE,
  MSG_CTRUNC = 0x08,
  MSG_PROXY = 0x10,
  MSG_TRUNC = 0x20,
  MSG_DONTWAIT = 0x40,
  MSG_EOR = 0x80,
  MSG_WAITALL = 0x100,
  MSG_FIN = 0x200,
  MSG_SYN = 0x400,
  MSG_CONFIRM = 0x800,
  MSG_RST = 0x1000,
  MSG_ERRQUEUE = 0x2000,
  MSG_NOSIGNAL = 0x4000,
  MSG_MORE = 0x8000,
  MSG_WAITFORONE = 0x10000,
  MSG_CMSG_CLOEXEC = 0x40000000
} ;
struct  msghdr {
  void *msg_name ;
  socklen_t msg_namelen ;
  struct  iovec   *msg_iov ;
  size_t msg_iovlen ;
  void *msg_control ;
  size_t msg_controllen ;
  int msg_flags ;
}  ;
struct  mmsghdr {
  struct  msghdr   msg_hdr ;
  unsigned  int msg_len ;
}  ;
struct  cmsghdr {
  size_t cmsg_len ;
  int cmsg_level ;
  int cmsg_type ;
  unsigned  char __cmsg_data[] ;
}  ;
extern struct  cmsghdr   *__cmsg_nxthdr(struct  msghdr   *__mhdr , struct  cmsghdr   *__cmsg ) __attribute__((__nothrow__));
enum  {
  SCM_RIGHTS = 0x01,
  SCM_CREDENTIALS = 0x02
} ;
struct  ucred {
  pid_t pid ;
  uid_t uid ;
  gid_t gid ;
}  ;
struct  linger {
  int l_onoff ;
  int l_linger ;
}  ;
extern int recvmmsg(int __fd , struct  mmsghdr   *__vmessages , unsigned  int __vlen , int __flags , const  struct  timespec   *__tmo );
struct  osockaddr {
  unsigned  short  int sa_family ;
  unsigned  char sa_data[14] ;
}  ;
enum  {
  SHUT_RD = 0,
  SHUT_WR,
  SHUT_RDWR
} ;
typedef union   {
  struct  sockaddr   *__restrict __sockaddr__ ;
  struct  sockaddr_at   *__restrict __sockaddr_at__ ;
  struct  sockaddr_ax25   *__restrict __sockaddr_ax25__ ;
  struct  sockaddr_dl   *__restrict __sockaddr_dl__ ;
  struct  sockaddr_eon   *__restrict __sockaddr_eon__ ;
  struct  sockaddr_in   *__restrict __sockaddr_in__ ;
  struct  sockaddr_in6   *__restrict __sockaddr_in6__ ;
  struct  sockaddr_inarp   *__restrict __sockaddr_inarp__ ;
  struct  sockaddr_ipx   *__restrict __sockaddr_ipx__ ;
  struct  sockaddr_iso   *__restrict __sockaddr_iso__ ;
  struct  sockaddr_ns   *__restrict __sockaddr_ns__ ;
  struct  sockaddr_un   *__restrict __sockaddr_un__ ;
  struct  sockaddr_x25   *__restrict __sockaddr_x25__ ;
}  __SOCKADDR_ARG __attribute__((__transparent_union__));
typedef union   {
  const  struct  sockaddr   *__restrict __sockaddr__ ;
  const  struct  sockaddr_at   *__restrict __sockaddr_at__ ;
  const  struct  sockaddr_ax25   *__restrict __sockaddr_ax25__ ;
  const  struct  sockaddr_dl   *__restrict __sockaddr_dl__ ;
  const  struct  sockaddr_eon   *__restrict __sockaddr_eon__ ;
  const  struct  sockaddr_in   *__restrict __sockaddr_in__ ;
  const  struct  sockaddr_in6   *__restrict __sockaddr_in6__ ;
  const  struct  sockaddr_inarp   *__restrict __sockaddr_inarp__ ;
  const  struct  sockaddr_ipx   *__restrict __sockaddr_ipx__ ;
  const  struct  sockaddr_iso   *__restrict __sockaddr_iso__ ;
  const  struct  sockaddr_ns   *__restrict __sockaddr_ns__ ;
  const  struct  sockaddr_un   *__restrict __sockaddr_un__ ;
  const  struct  sockaddr_x25   *__restrict __sockaddr_x25__ ;
}  __CONST_SOCKADDR_ARG __attribute__((__transparent_union__));
extern int socket(int __domain , int __type , int __protocol ) __attribute__((__nothrow__));
extern int socketpair(int __domain , int __type , int __protocol , int __fds[2] ) __attribute__((__nothrow__));
extern int bind(int __fd , __CONST_SOCKADDR_ARG __addr , socklen_t __len ) __attribute__((__nothrow__));
extern int getsockname(int __fd , __SOCKADDR_ARG __addr , socklen_t *__restrict __len ) __attribute__((__nothrow__));
extern int connect(int __fd , __CONST_SOCKADDR_ARG __addr , socklen_t __len );
extern int getpeername(int __fd , __SOCKADDR_ARG __addr , socklen_t *__restrict __len ) __attribute__((__nothrow__));
extern ssize_t send(int __fd , const  void *__buf , size_t __n , int __flags );
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags );
extern ssize_t sendto(int __fd , const  void *__buf , size_t __n , int __flags , __CONST_SOCKADDR_ARG __addr , socklen_t __addr_len );
extern ssize_t recvfrom(int __fd , void *__restrict __buf , size_t __n , int __flags , __SOCKADDR_ARG __addr , socklen_t *__restrict __addr_len );
extern ssize_t sendmsg(int __fd , const  struct  msghdr   *__message , int __flags );
extern ssize_t recvmsg(int __fd , struct  msghdr   *__message , int __flags );
extern int getsockopt(int __fd , int __level , int __optname , void *__restrict __optval , socklen_t *__restrict __optlen ) __attribute__((__nothrow__));
extern int setsockopt(int __fd , int __level , int __optname , const  void *__optval , socklen_t __optlen ) __attribute__((__nothrow__));
extern int listen(int __fd , int __n ) __attribute__((__nothrow__));
extern int accept(int __fd , __SOCKADDR_ARG __addr , socklen_t *__restrict __addr_len );
extern int accept4(int __fd , __SOCKADDR_ARG __addr , socklen_t *__restrict __addr_len , int __flags );
extern int shutdown(int __fd , int __how ) __attribute__((__nothrow__));
extern int sockatmark(int __fd ) __attribute__((__nothrow__));
extern int isfdtype(int __fd , int __fdtype ) __attribute__((__nothrow__));
enum  {
  IPPROTO_IP = 0,
  IPPROTO_HOPOPTS = 0,
  IPPROTO_ICMP = 1,
  IPPROTO_IGMP = 2,
  IPPROTO_IPIP = 4,
  IPPROTO_TCP = 6,
  IPPROTO_EGP = 8,
  IPPROTO_PUP = 12,
  IPPROTO_UDP = 17,
  IPPROTO_IDP = 22,
  IPPROTO_TP = 29,
  IPPROTO_DCCP = 33,
  IPPROTO_IPV6 = 41,
  IPPROTO_ROUTING = 43,
  IPPROTO_FRAGMENT = 44,
  IPPROTO_RSVP = 46,
  IPPROTO_GRE = 47,
  IPPROTO_ESP = 50,
  IPPROTO_AH = 51,
  IPPROTO_ICMPV6 = 58,
  IPPROTO_NONE = 59,
  IPPROTO_DSTOPTS = 60,
  IPPROTO_MTP = 92,
  IPPROTO_ENCAP = 98,
  IPPROTO_PIM = 103,
  IPPROTO_COMP = 108,
  IPPROTO_SCTP = 132,
  IPPROTO_UDPLITE = 136,
  IPPROTO_RAW = 255,
  IPPROTO_MAX
} ;
typedef uint16_t in_port_t;
enum  {
  IPPORT_ECHO = 7,
  IPPORT_DISCARD = 9,
  IPPORT_SYSTAT = 11,
  IPPORT_DAYTIME = 13,
  IPPORT_NETSTAT = 15,
  IPPORT_FTP = 21,
  IPPORT_TELNET = 23,
  IPPORT_SMTP = 25,
  IPPORT_TIMESERVER = 37,
  IPPORT_NAMESERVER = 42,
  IPPORT_WHOIS = 43,
  IPPORT_MTP = 57,
  IPPORT_TFTP = 69,
  IPPORT_RJE = 77,
  IPPORT_FINGER = 79,
  IPPORT_TTYLINK = 87,
  IPPORT_SUPDUP = 95,
  IPPORT_EXECSERVER = 512,
  IPPORT_LOGINSERVER = 513,
  IPPORT_CMDSERVER = 514,
  IPPORT_EFSSERVER = 520,
  IPPORT_BIFFUDP = 512,
  IPPORT_WHOSERVER = 513,
  IPPORT_ROUTESERVER = 520,
  IPPORT_RESERVED = 1024,
  IPPORT_USERRESERVED = 5000
} ;
typedef uint32_t in_addr_t;
struct  in_addr {
  in_addr_t s_addr ;
}  ;
struct  in6_addr {
  union   {
    uint8_t __u6_addr8[16] ;
    uint16_t __u6_addr16[8] ;
    uint32_t __u6_addr32[4] ;
  }  __in6_u ;
}  ;
extern const struct  in6_addr   in6addr_any;
extern const struct  in6_addr   in6addr_loopback;
struct  sockaddr_in {
  sa_family_t sin_family ;
  in_port_t sin_port ;
  struct  in_addr   sin_addr ;
  unsigned  char sin_zero[(sizeof(struct  sockaddr   ) - sizeof(unsigned  short  int ) - sizeof(in_port_t ) - sizeof(struct  in_addr   ))] ;
}  ;
struct  sockaddr_in6 {
  sa_family_t sin6_family ;
  in_port_t sin6_port ;
  uint32_t sin6_flowinfo ;
  struct  in6_addr   sin6_addr ;
  uint32_t sin6_scope_id ;
}  ;
struct  ip_mreq {
  struct  in_addr   imr_multiaddr ;
  struct  in_addr   imr_interface ;
}  ;
struct  ip_mreq_source {
  struct  in_addr   imr_multiaddr ;
  struct  in_addr   imr_interface ;
  struct  in_addr   imr_sourceaddr ;
}  ;
struct  ipv6_mreq {
  struct  in6_addr   ipv6mr_multiaddr ;
  unsigned  int ipv6mr_interface ;
}  ;
struct  group_req {
  uint32_t gr_interface ;
  struct  sockaddr_storage   gr_group ;
}  ;
struct  group_source_req {
  uint32_t gsr_interface ;
  struct  sockaddr_storage   gsr_group ;
  struct  sockaddr_storage   gsr_source ;
}  ;
struct  ip_msfilter {
  struct  in_addr   imsf_multiaddr ;
  struct  in_addr   imsf_interface ;
  uint32_t imsf_fmode ;
  uint32_t imsf_numsrc ;
  struct  in_addr   imsf_slist[1] ;
}  ;
struct  group_filter {
  uint32_t gf_interface ;
  struct  sockaddr_storage   gf_group ;
  uint32_t gf_fmode ;
  uint32_t gf_numsrc ;
  struct  sockaddr_storage   gf_slist[1] ;
}  ;
struct  ip_opts {
  struct  in_addr   ip_dst ;
  char ip_opts[40] ;
}  ;
struct  ip_mreqn {
  struct  in_addr   imr_multiaddr ;
  struct  in_addr   imr_address ;
  int imr_ifindex ;
}  ;
struct  in_pktinfo {
  int ipi_ifindex ;
  struct  in_addr   ipi_spec_dst ;
  struct  in_addr   ipi_addr ;
}  ;
extern uint32_t ntohl(uint32_t __netlong ) __attribute__((__nothrow__)) __attribute__((__const__));
extern uint16_t ntohs(uint16_t __netshort ) __attribute__((__nothrow__)) __attribute__((__const__));
extern uint32_t htonl(uint32_t __hostlong ) __attribute__((__nothrow__)) __attribute__((__const__));
extern uint16_t htons(uint16_t __hostshort ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int bindresvport(int __sockfd , struct  sockaddr_in   *__sock_in ) __attribute__((__nothrow__));
extern int bindresvport6(int __sockfd , struct  sockaddr_in6   *__sock_in ) __attribute__((__nothrow__));
struct  in6_pktinfo {
  struct  in6_addr   ipi6_addr ;
  unsigned  int ipi6_ifindex ;
}  ;
struct  ip6_mtuinfo {
  struct  sockaddr_in6   ip6m_addr ;
  uint32_t ip6m_mtu ;
}  ;
extern int inet6_option_space(int __nbytes ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int inet6_option_init(void *__bp , struct  cmsghdr   **__cmsgp , int __type ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int inet6_option_append(struct  cmsghdr   *__cmsg , const  uint8_t *__typep , int __multx , int __plusy ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern uint8_t *inet6_option_alloc(struct  cmsghdr   *__cmsg , int __datalen , int __multx , int __plusy ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int inet6_option_next(const  struct  cmsghdr   *__cmsg , uint8_t **__tptrp ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int inet6_option_find(const  struct  cmsghdr   *__cmsg , uint8_t **__tptrp , int __type ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int inet6_opt_init(void *__extbuf , socklen_t __extlen ) __attribute__((__nothrow__));
extern int inet6_opt_append(void *__extbuf , socklen_t __extlen , int __offset , uint8_t __type , socklen_t __len , uint8_t __align , void **__databufp ) __attribute__((__nothrow__));
extern int inet6_opt_finish(void *__extbuf , socklen_t __extlen , int __offset ) __attribute__((__nothrow__));
extern int inet6_opt_set_val(void *__databuf , int __offset , void *__val , socklen_t __vallen ) __attribute__((__nothrow__));
extern int inet6_opt_next(void *__extbuf , socklen_t __extlen , int __offset , uint8_t *__typep , socklen_t *__lenp , void **__databufp ) __attribute__((__nothrow__));
extern int inet6_opt_find(void *__extbuf , socklen_t __extlen , int __offset , uint8_t __type , socklen_t *__lenp , void **__databufp ) __attribute__((__nothrow__));
extern int inet6_opt_get_val(void *__databuf , int __offset , void *__val , socklen_t __vallen ) __attribute__((__nothrow__));
extern socklen_t inet6_rth_space(int __type , int __segments ) __attribute__((__nothrow__));
extern void *inet6_rth_init(void *__bp , socklen_t __bp_len , int __type , int __segments ) __attribute__((__nothrow__));
extern int inet6_rth_add(void *__bp , const  struct  in6_addr   *__addr ) __attribute__((__nothrow__));
extern int inet6_rth_reverse(const  void *__in , void *__out ) __attribute__((__nothrow__));
extern int inet6_rth_segments(const  void *__bp ) __attribute__((__nothrow__));
extern struct  in6_addr   *inet6_rth_getaddr(const  void *__bp , int __index ) __attribute__((__nothrow__));
extern int getipv4sourcefilter(int __s , struct  in_addr   __interface_addr , struct  in_addr   __group , uint32_t *__fmode , uint32_t *__numsrc , struct  in_addr   *__slist ) __attribute__((__nothrow__));
extern int setipv4sourcefilter(int __s , struct  in_addr   __interface_addr , struct  in_addr   __group , uint32_t __fmode , uint32_t __numsrc , const  struct  in_addr   *__slist ) __attribute__((__nothrow__));
extern int getsourcefilter(int __s , uint32_t __interface_addr , const  struct  sockaddr   *__group , socklen_t __grouplen , uint32_t *__fmode , uint32_t *__numsrc , struct  sockaddr_storage   *__slist ) __attribute__((__nothrow__));
extern int setsourcefilter(int __s , uint32_t __interface_addr , const  struct  sockaddr   *__group , socklen_t __grouplen , uint32_t __fmode , uint32_t __numsrc , const  struct  sockaddr_storage   *__slist ) __attribute__((__nothrow__));
struct  rpcent {
  char *r_name ;
  char **r_aliases ;
  int r_number ;
}  ;
extern void setrpcent(int __stayopen ) __attribute__((__nothrow__));
extern void endrpcent(void ) __attribute__((__nothrow__));
extern struct  rpcent   *getrpcbyname(const  char *__name ) __attribute__((__nothrow__));
extern struct  rpcent   *getrpcbynumber(int __number ) __attribute__((__nothrow__));
extern struct  rpcent   *getrpcent(void ) __attribute__((__nothrow__));
extern int getrpcbyname_r(const  char *__name , struct  rpcent   *__result_buf , char *__buffer , size_t __buflen , struct  rpcent   **__result ) __attribute__((__nothrow__));
extern int getrpcbynumber_r(int __number , struct  rpcent   *__result_buf , char *__buffer , size_t __buflen , struct  rpcent   **__result ) __attribute__((__nothrow__));
extern int getrpcent_r(struct  rpcent   *__result_buf , char *__buffer , size_t __buflen , struct  rpcent   **__result ) __attribute__((__nothrow__));
typedef union  sigval {
  int sival_int ;
  void *sival_ptr ;
}  sigval_t;
typedef struct  sigevent {
  sigval_t sigev_value ;
  int sigev_signo ;
  int sigev_notify ;
  union   {
    int _pad[((64 / sizeof(int )) - 4)] ;
    __pid_t _tid ;
    struct   {
      void ( *_function)(sigval_t ) ;
      void *_attribute ;
    }  _sigev_thread ;
  }  _sigev_un ;
}  sigevent_t;
enum  {
  SIGEV_SIGNAL = 0,
  SIGEV_NONE,
  SIGEV_THREAD,
  SIGEV_THREAD_ID = 4
} ;
struct  netent {
  char *n_name ;
  char **n_aliases ;
  int n_addrtype ;
  uint32_t n_net ;
}  ;
extern int *__h_errno_location(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern void herror(const  char *__str ) __attribute__((__nothrow__));
extern const char *hstrerror(int __err_num ) __attribute__((__nothrow__));
struct  hostent {
  char *h_name ;
  char **h_aliases ;
  int h_addrtype ;
  int h_length ;
  char **h_addr_list ;
}  ;
extern void sethostent(int __stay_open );
extern void endhostent(void );
extern struct  hostent   *gethostent(void );
extern struct  hostent   *gethostbyaddr(const  void *__addr , __socklen_t __len , int __type );
extern struct  hostent   *gethostbyname(const  char *__name );
extern struct  hostent   *gethostbyname2(const  char *__name , int __af );
extern int gethostent_r(struct  hostent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  hostent   **__restrict __result , int *__restrict __h_errnop );
extern int gethostbyaddr_r(const  void *__restrict __addr , __socklen_t __len , int __type , struct  hostent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  hostent   **__restrict __result , int *__restrict __h_errnop );
extern int gethostbyname_r(const  char *__restrict __name , struct  hostent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  hostent   **__restrict __result , int *__restrict __h_errnop );
extern int gethostbyname2_r(const  char *__restrict __name , int __af , struct  hostent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  hostent   **__restrict __result , int *__restrict __h_errnop );
extern void setnetent(int __stay_open );
extern void endnetent(void );
extern struct  netent   *getnetent(void );
extern struct  netent   *getnetbyaddr(uint32_t __net , int __type );
extern struct  netent   *getnetbyname(const  char *__name );
extern int getnetent_r(struct  netent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  netent   **__restrict __result , int *__restrict __h_errnop );
extern int getnetbyaddr_r(uint32_t __net , int __type , struct  netent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  netent   **__restrict __result , int *__restrict __h_errnop );
extern int getnetbyname_r(const  char *__restrict __name , struct  netent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  netent   **__restrict __result , int *__restrict __h_errnop );
struct  servent {
  char *s_name ;
  char **s_aliases ;
  int s_port ;
  char *s_proto ;
}  ;
extern void setservent(int __stay_open );
extern void endservent(void );
extern struct  servent   *getservent(void );
extern struct  servent   *getservbyname(const  char *__name , const  char *__proto );
extern struct  servent   *getservbyport(int __port , const  char *__proto );
extern int getservent_r(struct  servent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  servent   **__restrict __result );
extern int getservbyname_r(const  char *__restrict __name , const  char *__restrict __proto , struct  servent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  servent   **__restrict __result );
extern int getservbyport_r(int __port , const  char *__restrict __proto , struct  servent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  servent   **__restrict __result );
struct  protoent {
  char *p_name ;
  char **p_aliases ;
  int p_proto ;
}  ;
extern void setprotoent(int __stay_open );
extern void endprotoent(void );
extern struct  protoent   *getprotoent(void );
extern struct  protoent   *getprotobyname(const  char *__name );
extern struct  protoent   *getprotobynumber(int __proto );
extern int getprotoent_r(struct  protoent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  protoent   **__restrict __result );
extern int getprotobyname_r(const  char *__restrict __name , struct  protoent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  protoent   **__restrict __result );
extern int getprotobynumber_r(int __proto , struct  protoent   *__restrict __result_buf , char *__restrict __buf , size_t __buflen , struct  protoent   **__restrict __result );
extern int setnetgrent(const  char *__netgroup );
extern void endnetgrent(void );
extern int getnetgrent(char **__restrict __hostp , char **__restrict __userp , char **__restrict __domainp );
extern int innetgr(const  char *__netgroup , const  char *__host , const  char *__user , const  char *__domain );
extern int getnetgrent_r(char **__restrict __hostp , char **__restrict __userp , char **__restrict __domainp , char *__restrict __buffer , size_t __buflen );
extern int rcmd(char **__restrict __ahost , unsigned  short  int __rport , const  char *__restrict __locuser , const  char *__restrict __remuser , const  char *__restrict __cmd , int *__restrict __fd2p );
extern int rcmd_af(char **__restrict __ahost , unsigned  short  int __rport , const  char *__restrict __locuser , const  char *__restrict __remuser , const  char *__restrict __cmd , int *__restrict __fd2p , sa_family_t __af );
extern int rexec(char **__restrict __ahost , int __rport , const  char *__restrict __name , const  char *__restrict __pass , const  char *__restrict __cmd , int *__restrict __fd2p );
extern int rexec_af(char **__restrict __ahost , int __rport , const  char *__restrict __name , const  char *__restrict __pass , const  char *__restrict __cmd , int *__restrict __fd2p , sa_family_t __af );
extern int ruserok(const  char *__rhost , int __suser , const  char *__remuser , const  char *__locuser );
extern int ruserok_af(const  char *__rhost , int __suser , const  char *__remuser , const  char *__locuser , sa_family_t __af );
extern int iruserok(uint32_t __raddr , int __suser , const  char *__remuser , const  char *__locuser );
extern int iruserok_af(const  void *__raddr , int __suser , const  char *__remuser , const  char *__locuser , sa_family_t __af );
extern int rresvport(int *__alport );
extern int rresvport_af(int *__alport , sa_family_t __af );
struct  addrinfo {
  int ai_flags ;
  int ai_family ;
  int ai_socktype ;
  int ai_protocol ;
  socklen_t ai_addrlen ;
  struct  sockaddr   *ai_addr ;
  char *ai_canonname ;
  struct  addrinfo   *ai_next ;
}  ;
struct  gaicb {
  const  char *ar_name ;
  const  char *ar_service ;
  const  struct  addrinfo   *ar_request ;
  struct  addrinfo   *ar_result ;
  int __return ;
  int __unused[5] ;
}  ;
extern int getaddrinfo(const  char *__restrict __name , const  char *__restrict __service , const  struct  addrinfo   *__restrict __req , struct  addrinfo   **__restrict __pai );
extern void freeaddrinfo(struct  addrinfo   *__ai ) __attribute__((__nothrow__));
extern const char *gai_strerror(int __ecode ) __attribute__((__nothrow__));
extern int getnameinfo(const  struct  sockaddr   *__restrict __sa , socklen_t __salen , char *__restrict __host , socklen_t __hostlen , char *__restrict __serv , socklen_t __servlen , unsigned  int __flags );
extern int getaddrinfo_a(int __mode , struct  gaicb   *__list[] , int __ent , struct  sigevent   *__restrict __sig );
extern int gai_suspend(const  struct  gaicb   *const __list[] , int __ent , const  struct  timespec   *__timeout );
extern int gai_error(struct  gaicb   *__req ) __attribute__((__nothrow__));
extern int gai_cancel(struct  gaicb   *__gaicbp ) __attribute__((__nothrow__));
typedef long int __jmp_buf[8];
struct  __jmp_buf_tag {
  __jmp_buf __jmpbuf ;
  int __mask_was_saved ;
  __sigset_t __saved_mask ;
}  ;
typedef struct  __jmp_buf_tag   jmp_buf[1];
extern int setjmp(jmp_buf __env ) __attribute__((__nothrow__));
extern int __sigsetjmp(struct  __jmp_buf_tag   __env[1] , int __savemask ) __attribute__((__nothrow__));
extern int _setjmp(struct  __jmp_buf_tag   __env[1] ) __attribute__((__nothrow__));
extern void longjmp(struct  __jmp_buf_tag   __env[1] , int __val ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern void _longjmp(struct  __jmp_buf_tag   __env[1] , int __val ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
typedef struct  __jmp_buf_tag   sigjmp_buf[1];
extern void siglongjmp(sigjmp_buf __env , int __val ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern int __sigismember(const  __sigset_t * , int );
extern int __sigaddset(__sigset_t * , int );
extern int __sigdelset(__sigset_t * , int );
typedef __sig_atomic_t sig_atomic_t;
typedef struct  siginfo {
  int si_signo ;
  int si_errno ;
  int si_code ;
  union   {
    int _pad[((128 / sizeof(int )) - 4)] ;
    struct   {
      __pid_t si_pid ;
      __uid_t si_uid ;
    }  _kill ;
    struct   {
      int si_tid ;
      int si_overrun ;
      sigval_t si_sigval ;
    }  _timer ;
    struct   {
      __pid_t si_pid ;
      __uid_t si_uid ;
      sigval_t si_sigval ;
    }  _rt ;
    struct   {
      __pid_t si_pid ;
      __uid_t si_uid ;
      int si_status ;
      __clock_t si_utime ;
      __clock_t si_stime ;
    }  _sigchld ;
    struct   {
      void *si_addr ;
    }  _sigfault ;
    struct   {
      long  int si_band ;
      int si_fd ;
    }  _sigpoll ;
  }  _sifields ;
}  siginfo_t;
enum  {
  SI_ASYNCNL = (- 60),
  SI_TKILL = (- 6),
  SI_SIGIO,
  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,
  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
} ;
enum  {
  ILL_ILLOPC = 1,
  ILL_ILLOPN,
  ILL_ILLADR,
  ILL_ILLTRP,
  ILL_PRVOPC,
  ILL_PRVREG,
  ILL_COPROC,
  ILL_BADSTK
} ;
enum  {
  FPE_INTDIV = 1,
  FPE_INTOVF,
  FPE_FLTDIV,
  FPE_FLTOVF,
  FPE_FLTUND,
  FPE_FLTRES,
  FPE_FLTINV,
  FPE_FLTSUB
} ;
enum  {
  SEGV_MAPERR = 1,
  SEGV_ACCERR
} ;
enum  {
  BUS_ADRALN = 1,
  BUS_ADRERR,
  BUS_OBJERR
} ;
enum  {
  TRAP_BRKPT = 1,
  TRAP_TRACE
} ;
enum  {
  CLD_EXITED = 1,
  CLD_KILLED,
  CLD_DUMPED,
  CLD_TRAPPED,
  CLD_STOPPED,
  CLD_CONTINUED
} ;
enum  {
  POLL_IN = 1,
  POLL_OUT,
  POLL_MSG,
  POLL_ERR,
  POLL_PRI,
  POLL_HUP
} ;
typedef void ( *__sighandler_t)(int );
extern __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler ) __attribute__((__nothrow__));
extern __sighandler_t sysv_signal(int __sig , __sighandler_t __handler ) __attribute__((__nothrow__));
extern __sighandler_t signal(int __sig , __sighandler_t __handler ) __attribute__((__nothrow__));
extern __sighandler_t bsd_signal(int __sig , __sighandler_t __handler ) __attribute__((__nothrow__));
extern int kill(__pid_t __pid , int __sig ) __attribute__((__nothrow__));
extern int killpg(__pid_t __pgrp , int __sig ) __attribute__((__nothrow__));
extern int raise(int __sig ) __attribute__((__nothrow__));
extern __sighandler_t ssignal(int __sig , __sighandler_t __handler ) __attribute__((__nothrow__));
extern int gsignal(int __sig ) __attribute__((__nothrow__));
extern void psignal(int __sig , const  char *__s );
extern void psiginfo(const  siginfo_t *__pinfo , const  char *__s );
extern int __sigpause(int __sig_or_mask , int __is_sig );
extern int sigpause(int __sig ) __asm__( "__xpg_sigpause");
extern int sigblock(int __mask ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int sigsetmask(int __mask ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int siggetmask(void ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
typedef __sighandler_t sighandler_t;
typedef __sighandler_t sig_t;
extern int sigemptyset(sigset_t *__set ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigfillset(sigset_t *__set ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigaddset(sigset_t *__set , int __signo ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigdelset(sigset_t *__set , int __signo ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigismember(const  sigset_t *__set , int __signo ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigisemptyset(const  sigset_t *__set ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigandset(sigset_t *__set , const  sigset_t *__left , const  sigset_t *__right ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2, 3)));
extern int sigorset(sigset_t *__set , const  sigset_t *__left , const  sigset_t *__right ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2, 3)));
struct  sigaction {
  union   {
    __sighandler_t sa_handler ;
    void ( *sa_sigaction)(int , siginfo_t * , void * ) ;
  }  __sigaction_handler ;
  __sigset_t sa_mask ;
  int sa_flags ;
  void ( *sa_restorer)(void ) ;
}  ;
extern int sigprocmask(int __how , const  sigset_t *__restrict __set , sigset_t *__restrict __oset ) __attribute__((__nothrow__));
extern int sigsuspend(const  sigset_t *__set ) __attribute__((__nonnull__ (1)));
extern int sigaction(int __sig , const  struct  sigaction   *__restrict __act , struct  sigaction   *__restrict __oact ) __attribute__((__nothrow__));
extern int sigpending(sigset_t *__set ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sigwait(const  sigset_t *__restrict __set , int *__restrict __sig ) __attribute__((__nonnull__ (1, 2)));
extern int sigwaitinfo(const  sigset_t *__restrict __set , siginfo_t *__restrict __info ) __attribute__((__nonnull__ (1)));
extern int sigtimedwait(const  sigset_t *__restrict __set , siginfo_t *__restrict __info , const  struct  timespec   *__restrict __timeout ) __attribute__((__nonnull__ (1)));
extern int sigqueue(__pid_t __pid , int __sig , const  union  sigval   __val ) __attribute__((__nothrow__));
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];
struct  sigvec {
  __sighandler_t sv_handler ;
  int sv_mask ;
  int sv_flags ;
}  ;
extern int sigvec(int __sig , const  struct  sigvec   *__vec , struct  sigvec   *__ovec ) __attribute__((__nothrow__));
struct  _fpreg {
  unsigned  short significand[4] ;
  unsigned  short exponent ;
}  ;
struct  _fpxreg {
  unsigned  short significand[4] ;
  unsigned  short exponent ;
  unsigned  short padding[3] ;
}  ;
struct  _xmmreg {
  __uint32_t element[4] ;
}  ;
struct  _fpstate {
  __uint16_t cwd ;
  __uint16_t swd ;
  __uint16_t ftw ;
  __uint16_t fop ;
  __uint64_t rip ;
  __uint64_t rdp ;
  __uint32_t mxcsr ;
  __uint32_t mxcr_mask ;
  struct  _fpxreg   _st[8] ;
  struct  _xmmreg   _xmm[16] ;
  __uint32_t padding[24] ;
}  ;
struct  sigcontext {
  unsigned  long r8 ;
  unsigned  long r9 ;
  unsigned  long r10 ;
  unsigned  long r11 ;
  unsigned  long r12 ;
  unsigned  long r13 ;
  unsigned  long r14 ;
  unsigned  long r15 ;
  unsigned  long rdi ;
  unsigned  long rsi ;
  unsigned  long rbp ;
  unsigned  long rbx ;
  unsigned  long rdx ;
  unsigned  long rax ;
  unsigned  long rcx ;
  unsigned  long rsp ;
  unsigned  long rip ;
  unsigned  long eflags ;
  unsigned  short cs ;
  unsigned  short gs ;
  unsigned  short fs ;
  unsigned  short __pad0 ;
  unsigned  long err ;
  unsigned  long trapno ;
  unsigned  long oldmask ;
  unsigned  long cr2 ;
  struct  _fpstate   *fpstate ;
  unsigned  long __reserved1[8] ;
}  ;
extern int sigreturn(struct  sigcontext   *__scp ) __attribute__((__nothrow__));
extern int siginterrupt(int __sig , int __interrupt ) __attribute__((__nothrow__));
struct  sigstack {
  void *ss_sp ;
  int ss_onstack ;
}  ;
enum  {
  SS_ONSTACK = 1,
  SS_DISABLE
} ;
typedef struct  sigaltstack {
  void *ss_sp ;
  int ss_flags ;
  size_t ss_size ;
}  stack_t;
typedef long int greg_t;
typedef greg_t gregset_t[23];
enum  {
  REG_R8 = 0,
  REG_R9,
  REG_R10,
  REG_R11,
  REG_R12,
  REG_R13,
  REG_R14,
  REG_R15,
  REG_RDI,
  REG_RSI,
  REG_RBP,
  REG_RBX,
  REG_RDX,
  REG_RAX,
  REG_RCX,
  REG_RSP,
  REG_RIP,
  REG_EFL,
  REG_CSGSFS,
  REG_ERR,
  REG_TRAPNO,
  REG_OLDMASK,
  REG_CR2
} ;
struct  _libc_fpxreg {
  unsigned  short  int significand[4] ;
  unsigned  short  int exponent ;
  unsigned  short  int padding[3] ;
}  ;
struct  _libc_xmmreg {
  __uint32_t element[4] ;
}  ;
struct  _libc_fpstate {
  __uint16_t cwd ;
  __uint16_t swd ;
  __uint16_t ftw ;
  __uint16_t fop ;
  __uint64_t rip ;
  __uint64_t rdp ;
  __uint32_t mxcsr ;
  __uint32_t mxcr_mask ;
  struct  _libc_fpxreg   _st[8] ;
  struct  _libc_xmmreg   _xmm[16] ;
  __uint32_t padding[24] ;
}  ;
typedef struct  _libc_fpstate   *fpregset_t;
typedef struct   {
  gregset_t gregs ;
  fpregset_t fpregs ;
  unsigned  long __reserved1[8] ;
}  mcontext_t;
typedef struct  ucontext {
  unsigned  long  int uc_flags ;
  struct  ucontext   *uc_link ;
  stack_t uc_stack ;
  mcontext_t uc_mcontext ;
  __sigset_t uc_sigmask ;
  struct  _libc_fpstate   __fpregs_mem ;
}  ucontext_t;
extern int sigstack(struct  sigstack   *__ss , struct  sigstack   *__oss ) __attribute__((__nothrow__)) __attribute__((__deprecated__));
extern int sigaltstack(const  struct  sigaltstack   *__restrict __ss , struct  sigaltstack   *__restrict __oss ) __attribute__((__nothrow__));
extern int sighold(int __sig ) __attribute__((__nothrow__));
extern int sigrelse(int __sig ) __attribute__((__nothrow__));
extern int sigignore(int __sig ) __attribute__((__nothrow__));
extern __sighandler_t sigset(int __sig , __sighandler_t __disp ) __attribute__((__nothrow__));
extern int pthread_sigmask(int __how , const  __sigset_t *__restrict __newmask , __sigset_t *__restrict __oldmask ) __attribute__((__nothrow__));
extern int pthread_kill(pthread_t __threadid , int __signo ) __attribute__((__nothrow__));
extern int pthread_sigqueue(pthread_t __threadid , int __signo , const  union  sigval   __value ) __attribute__((__nothrow__));
extern int __libc_current_sigrtmin(void ) __attribute__((__nothrow__));
extern int __libc_current_sigrtmax(void ) __attribute__((__nothrow__));
struct  _IO_FILE   ;
typedef struct  _IO_FILE   FILE;
typedef struct  _IO_FILE   __FILE;
typedef struct   {
  int __count ;
  union   {
    unsigned  int __wch ;
    char __wchb[4] ;
  }  __value ;
}  __mbstate_t;
typedef struct   {
  __off_t __pos ;
  __mbstate_t __state ;
}  _G_fpos_t;
typedef struct   {
  __off64_t __pos ;
  __mbstate_t __state ;
}  _G_fpos64_t;
typedef int _G_int16_t __attribute__((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__((__mode__ (__SI__)));
typedef __builtin_va_list __gnuc_va_list;
struct  _IO_jump_t   ;
struct  _IO_FILE   ;
typedef void _IO_lock_t;
struct  _IO_marker {
  struct  _IO_marker   *_next ;
  struct  _IO_FILE   *_sbuf ;
  int _pos ;
}  ;
enum __codecvt_result {
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
} ;
struct  _IO_FILE {
  int _flags ;
  char *_IO_read_ptr ;
  char *_IO_read_end ;
  char *_IO_read_base ;
  char *_IO_write_base ;
  char *_IO_write_ptr ;
  char *_IO_write_end ;
  char *_IO_buf_base ;
  char *_IO_buf_end ;
  char *_IO_save_base ;
  char *_IO_backup_base ;
  char *_IO_save_end ;
  struct  _IO_marker   *_markers ;
  struct  _IO_FILE   *_chain ;
  int _fileno ;
  int _flags2 ;
  __off_t _old_offset ;
  unsigned  short _cur_column ;
  signed  char _vtable_offset ;
  char _shortbuf[1] ;
  _IO_lock_t *_lock ;
  __off64_t _offset ;
  void *__pad1 ;
  void *__pad2 ;
  void *__pad3 ;
  void *__pad4 ;
  size_t __pad5 ;
  int _mode ;
  char _unused2[((15 * sizeof(int )) - (4 * sizeof(void *)) - sizeof(size_t ))] ;
}  ;
typedef struct  _IO_FILE   _IO_FILE;
struct  _IO_FILE_plus   ;
extern struct  _IO_FILE_plus   _IO_2_1_stdin_;
extern struct  _IO_FILE_plus   _IO_2_1_stdout_;
extern struct  _IO_FILE_plus   _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn(void *__cookie , char *__buf , size_t __nbytes );
typedef __ssize_t __io_write_fn(void *__cookie , const  char *__buf , size_t __n );
typedef int __io_seek_fn(void *__cookie , __off64_t *__pos , int __w );
typedef int __io_close_fn(void *__cookie );
typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;
typedef struct   {
  __io_read_fn *read ;
  __io_write_fn *write ;
  __io_seek_fn *seek ;
  __io_close_fn *close ;
}  _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;
struct  _IO_cookie_file   ;
extern void _IO_cookie_init(struct  _IO_cookie_file   *__cfile , int __read_write , void *__cookie , _IO_cookie_io_functions_t __fns );
extern int __underflow(_IO_FILE * );
extern int __uflow(_IO_FILE * );
extern int __overflow(_IO_FILE * , int );
extern int _IO_getc(_IO_FILE *__fp );
extern int _IO_putc(int __c , _IO_FILE *__fp );
extern int _IO_feof(_IO_FILE *__fp ) __attribute__((__nothrow__));
extern int _IO_ferror(_IO_FILE *__fp ) __attribute__((__nothrow__));
extern int _IO_peekc_locked(_IO_FILE *__fp );
extern void _IO_flockfile(_IO_FILE * ) __attribute__((__nothrow__));
extern void _IO_funlockfile(_IO_FILE * ) __attribute__((__nothrow__));
extern int _IO_ftrylockfile(_IO_FILE * ) __attribute__((__nothrow__));
extern int _IO_vfscanf(_IO_FILE *__restrict  , const  char *__restrict  , __gnuc_va_list , int *__restrict  );
extern int _IO_vfprintf(_IO_FILE *__restrict  , const  char *__restrict  , __gnuc_va_list );
extern __ssize_t _IO_padn(_IO_FILE * , int , __ssize_t );
extern size_t _IO_sgetn(_IO_FILE * , void * , size_t );
extern __off64_t _IO_seekoff(_IO_FILE * , __off64_t , int , int );
extern __off64_t _IO_seekpos(_IO_FILE * , __off64_t , int );
extern void _IO_free_backup_area(_IO_FILE * ) __attribute__((__nothrow__));
typedef __gnuc_va_list va_list;
typedef _G_fpos_t fpos_t;
typedef _G_fpos64_t fpos64_t;
extern struct  _IO_FILE   *stdin;
extern struct  _IO_FILE   *stdout;
extern struct  _IO_FILE   *stderr;
extern int remove(const  char *__filename ) __attribute__((__nothrow__));
extern int rename(const  char *__old , const  char *__new ) __attribute__((__nothrow__));
extern int renameat(int __oldfd , const  char *__old , int __newfd , const  char *__new ) __attribute__((__nothrow__));
extern FILE *tmpfile(void );
extern FILE *tmpfile64(void );
extern char *tmpnam(char *__s ) __attribute__((__nothrow__));
extern char *tmpnam_r(char *__s ) __attribute__((__nothrow__));
extern char *tempnam(const  char *__dir , const  char *__pfx ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern int fclose(FILE *__stream );
extern int fflush(FILE *__stream );
extern int fflush_unlocked(FILE *__stream );
extern int fcloseall(void );
extern FILE *fopen(const  char *__restrict __filename , const  char *__restrict __modes );
extern FILE *freopen(const  char *__restrict __filename , const  char *__restrict __modes , FILE *__restrict __stream );
extern FILE *fopen64(const  char *__restrict __filename , const  char *__restrict __modes );
extern FILE *freopen64(const  char *__restrict __filename , const  char *__restrict __modes , FILE *__restrict __stream );
extern FILE *fdopen(int __fd , const  char *__modes ) __attribute__((__nothrow__));
extern FILE *fopencookie(void *__restrict __magic_cookie , const  char *__restrict __modes , _IO_cookie_io_functions_t __io_funcs ) __attribute__((__nothrow__));
extern FILE *fmemopen(void *__s , size_t __len , const  char *__modes ) __attribute__((__nothrow__));
extern FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) __attribute__((__nothrow__));
extern void setbuf(FILE *__restrict __stream , char *__restrict __buf ) __attribute__((__nothrow__));
extern int setvbuf(FILE *__restrict __stream , char *__restrict __buf , int __modes , size_t __n ) __attribute__((__nothrow__));
extern void setbuffer(FILE *__restrict __stream , char *__restrict __buf , size_t __size ) __attribute__((__nothrow__));
extern void setlinebuf(FILE *__stream ) __attribute__((__nothrow__));
extern int fprintf(FILE *__restrict __stream , const  char *__restrict __format , ...);
extern int printf(const  char *__restrict __format , ...);
extern int sprintf(char *__restrict __s , const  char *__restrict __format , ...) __attribute__((__nothrow__));
extern int vfprintf(FILE *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg );
extern int vprintf(const  char *__restrict __format , __gnuc_va_list __arg );
extern int vsprintf(char *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__));
extern int snprintf(char *__restrict __s , size_t __maxlen , const  char *__restrict __format , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 3, 4)));
extern int vsnprintf(char *__restrict __s , size_t __maxlen , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 3, 0)));
extern int vasprintf(char **__restrict __ptr , const  char *__restrict __f , __gnuc_va_list __arg ) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 0)));
extern int __asprintf(char **__restrict __ptr , const  char *__restrict __fmt , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 3)));
extern int asprintf(char **__restrict __ptr , const  char *__restrict __fmt , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 3)));
extern int vdprintf(int __fd , const  char *__restrict __fmt , __gnuc_va_list __arg ) __attribute__((__format__ (__printf__, 2, 0)));
extern int dprintf(int __fd , const  char *__restrict __fmt , ...) __attribute__((__format__ (__printf__, 2, 3)));
extern int fscanf(FILE *__restrict __stream , const  char *__restrict __format , ...);
extern int scanf(const  char *__restrict __format , ...);
extern int sscanf(const  char *__restrict __s , const  char *__restrict __format , ...) __attribute__((__nothrow__));
extern int vfscanf(FILE *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__format__ (__scanf__, 2, 0)));
extern int vscanf(const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__format__ (__scanf__, 1, 0)));
extern int vsscanf(const  char *__restrict __s , const  char *__restrict __format , __gnuc_va_list __arg ) __attribute__((__nothrow__)) __attribute__((__format__ (__scanf__, 2, 0)));
extern int fgetc(FILE *__stream );
extern int getc(FILE *__stream );
extern int getchar(void );
extern int getc_unlocked(FILE *__stream );
extern int getchar_unlocked(void );
extern int fgetc_unlocked(FILE *__stream );
extern int fputc(int __c , FILE *__stream );
extern int putc(int __c , FILE *__stream );
extern int putchar(int __c );
extern int fputc_unlocked(int __c , FILE *__stream );
extern int putc_unlocked(int __c , FILE *__stream );
extern int putchar_unlocked(int __c );
extern int getw(FILE *__stream );
extern int putw(int __w , FILE *__stream );
extern char *fgets(char *__restrict __s , int __n , FILE *__restrict __stream );
extern char *gets(char *__s );
extern char *fgets_unlocked(char *__restrict __s , int __n , FILE *__restrict __stream );
extern __ssize_t __getdelim(char **__restrict __lineptr , size_t *__restrict __n , int __delimiter , FILE *__restrict __stream );
extern __ssize_t getdelim(char **__restrict __lineptr , size_t *__restrict __n , int __delimiter , FILE *__restrict __stream );
extern __ssize_t getline(char **__restrict __lineptr , size_t *__restrict __n , FILE *__restrict __stream );
extern int fputs(const  char *__restrict __s , FILE *__restrict __stream );
extern int puts(const  char *__s );
extern int ungetc(int __c , FILE *__stream );
extern size_t fread(void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __stream );
extern size_t fwrite(const  void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __s );
extern int fputs_unlocked(const  char *__restrict __s , FILE *__restrict __stream );
extern size_t fread_unlocked(void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __stream );
extern size_t fwrite_unlocked(const  void *__restrict __ptr , size_t __size , size_t __n , FILE *__restrict __stream );
extern int fseek(FILE *__stream , long  int __off , int __whence );
extern long int ftell(FILE *__stream );
extern void rewind(FILE *__stream );
extern int fseeko(FILE *__stream , __off_t __off , int __whence );
extern __off_t ftello(FILE *__stream );
extern int fgetpos(FILE *__restrict __stream , fpos_t *__restrict __pos );
extern int fsetpos(FILE *__stream , const  fpos_t *__pos );
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence );
extern __off64_t ftello64(FILE *__stream );
extern int fgetpos64(FILE *__restrict __stream , fpos64_t *__restrict __pos );
extern int fsetpos64(FILE *__stream , const  fpos64_t *__pos );
extern void clearerr(FILE *__stream ) __attribute__((__nothrow__));
extern int feof(FILE *__stream ) __attribute__((__nothrow__));
extern int ferror(FILE *__stream ) __attribute__((__nothrow__));
extern void clearerr_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern int feof_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern int ferror_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern void perror(const  char *__s );
extern int sys_nerr;
extern const char *const sys_errlist[];
extern int _sys_nerr;
extern const char *const _sys_errlist[];
extern int fileno(FILE *__stream ) __attribute__((__nothrow__));
extern int fileno_unlocked(FILE *__stream ) __attribute__((__nothrow__));
extern FILE *popen(const  char *__command , const  char *__modes );
extern int pclose(FILE *__stream );
extern char *ctermid(char *__s ) __attribute__((__nothrow__));
extern char *cuserid(char *__s );
struct  obstack   ;
extern int obstack_printf(struct  obstack   *__restrict __obstack , const  char *__restrict __format , ...) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf(struct  obstack   *__restrict __obstack , const  char *__restrict __format , __gnuc_va_list __args ) __attribute__((__nothrow__)) __attribute__((__format__ (__printf__, 2, 0)));
extern void flockfile(FILE *__stream ) __attribute__((__nothrow__));
extern int ftrylockfile(FILE *__stream ) __attribute__((__nothrow__));
extern void funlockfile(FILE *__stream ) __attribute__((__nothrow__));
typedef int wchar_t;
union  wait {
  int w_status ;
  struct   {
    unsigned  int __w_termsig: 7 ;
    unsigned  int __w_coredump: 1 ;
    unsigned  int __w_retcode: 8 ;
    unsigned  int : 16 ;
  }  __wait_terminated ;
  struct   {
    unsigned  int __w_stopval: 8 ;
    unsigned  int __w_stopsig: 8 ;
    unsigned  int : 16 ;
  }  __wait_stopped ;
}  ;
typedef union   {
  union  wait   *__uptr ;
  int *__iptr ;
}  __WAIT_STATUS __attribute__((__transparent_union__));
typedef struct   {
  int quot ;
  int rem ;
}  div_t;
typedef struct   {
  long  int quot ;
  long  int rem ;
}  ldiv_t;
typedef struct   {
  long  long  int quot ;
  long  long  int rem ;
}  lldiv_t;
extern size_t __ctype_get_mb_cur_max(void ) __attribute__((__nothrow__));
extern double atof(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern int atoi(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern long int atol(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern long long int atoll(const  char *__nptr ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern double strtod(const  char *__restrict __nptr , char **__restrict __endptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern float strtof(const  char *__restrict __nptr , char **__restrict __endptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long double strtold(const  char *__restrict __nptr , char **__restrict __endptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int strtol(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern unsigned long int strtoul(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long long int strtoq(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern unsigned long long int strtouq(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long long int strtoll(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern unsigned long long int strtoull(const  char *__restrict __nptr , char **__restrict __endptr , int __base ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int strtol_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern long long int strtoll_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern unsigned long long int strtoull_l(const  char *__restrict __nptr , char **__restrict __endptr , int __base , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 4)));
extern double strtod_l(const  char *__restrict __nptr , char **__restrict __endptr , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern float strtof_l(const  char *__restrict __nptr , char **__restrict __endptr , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern long double strtold_l(const  char *__restrict __nptr , char **__restrict __endptr , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern char *l64a(long  int __n ) __attribute__((__nothrow__));
extern long int a64l(const  char *__s ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern long int random(void ) __attribute__((__nothrow__));
extern void srandom(unsigned  int __seed ) __attribute__((__nothrow__));
extern char *initstate(unsigned  int __seed , char *__statebuf , size_t __statelen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern char *setstate(char *__statebuf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
struct  random_data {
  int32_t *fptr ;
  int32_t *rptr ;
  int32_t *state ;
  int rand_type ;
  int rand_deg ;
  int rand_sep ;
  int32_t *end_ptr ;
}  ;
extern int random_r(struct  random_data   *__restrict __buf , int32_t *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int srandom_r(unsigned  int __seed , struct  random_data   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int initstate_r(unsigned  int __seed , char *__restrict __statebuf , size_t __statelen , struct  random_data   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int setstate_r(char *__restrict __statebuf , struct  random_data   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int rand(void ) __attribute__((__nothrow__));
extern void srand(unsigned  int __seed ) __attribute__((__nothrow__));
extern int rand_r(unsigned  int *__seed ) __attribute__((__nothrow__));
extern double drand48(void ) __attribute__((__nothrow__));
extern double erand48(unsigned  short  int __xsubi[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int lrand48(void ) __attribute__((__nothrow__));
extern long int nrand48(unsigned  short  int __xsubi[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int mrand48(void ) __attribute__((__nothrow__));
extern long int jrand48(unsigned  short  int __xsubi[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void srand48(long  int __seedval ) __attribute__((__nothrow__));
extern unsigned short int *seed48(unsigned  short  int __seed16v[3] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void lcong48(unsigned  short  int __param[7] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
struct  drand48_data {
  unsigned  short  int __x[3] ;
  unsigned  short  int __old_x[3] ;
  unsigned  short  int __c ;
  unsigned  short  int __init ;
  unsigned  long  long  int __a ;
}  ;
extern int drand48_r(struct  drand48_data   *__restrict __buffer , double *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int erand48_r(unsigned  short  int __xsubi[3] , struct  drand48_data   *__restrict __buffer , double *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int lrand48_r(struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int nrand48_r(unsigned  short  int __xsubi[3] , struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int mrand48_r(struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int jrand48_r(unsigned  short  int __xsubi[3] , struct  drand48_data   *__restrict __buffer , long  int *__restrict __result ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int srand48_r(long  int __seedval , struct  drand48_data   *__buffer ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int seed48_r(unsigned  short  int __seed16v[3] , struct  drand48_data   *__buffer ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int lcong48_r(unsigned  short  int __param[7] , struct  drand48_data   *__buffer ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *malloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *calloc(size_t __nmemb , size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern void *realloc(void *__ptr , size_t __size ) __attribute__((__nothrow__)) __attribute__((__warn_unused_result__));
extern void free(void *__ptr ) __attribute__((__nothrow__));
extern void cfree(void *__ptr ) __attribute__((__nothrow__));
extern void *alloca(size_t __size ) __attribute__((__nothrow__));
extern void *valloc(size_t __size ) __attribute__((__nothrow__)) __attribute__((__malloc__));
extern int posix_memalign(void **__memptr , size_t __alignment , size_t __size ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void abort(void ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern int atexit(void ( *__func)(void ) ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int at_quick_exit(void ( *__func)(void ) ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int on_exit(void ( *__func)(int __status , void *__arg ) , void *__arg ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void exit(int __status ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern void quick_exit(int __status ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern void _Exit(int __status ) __attribute__((__nothrow__)) __attribute__((__noreturn__));
extern char *getenv(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *__secure_getenv(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int putenv(char *__string ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int setenv(const  char *__name , const  char *__value , int __replace ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int unsetenv(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int clearenv(void ) __attribute__((__nothrow__));
extern char *mktemp(char *__template ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkstemp(char *__template ) __attribute__((__nonnull__ (1)));
extern int mkstemp64(char *__template ) __attribute__((__nonnull__ (1)));
extern int mkstemps(char *__template , int __suffixlen ) __attribute__((__nonnull__ (1)));
extern int mkstemps64(char *__template , int __suffixlen ) __attribute__((__nonnull__ (1)));
extern char *mkdtemp(char *__template ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkostemp(char *__template , int __flags ) __attribute__((__nonnull__ (1)));
extern int mkostemp64(char *__template , int __flags ) __attribute__((__nonnull__ (1)));
extern int mkostemps(char *__template , int __suffixlen , int __flags ) __attribute__((__nonnull__ (1)));
extern int mkostemps64(char *__template , int __suffixlen , int __flags ) __attribute__((__nonnull__ (1)));
extern int system(const  char *__command );
extern char *canonicalize_file_name(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *realpath(const  char *__restrict __name , char *__restrict __resolved ) __attribute__((__nothrow__));
typedef int ( *__compar_fn_t)(const  void * , const  void * );
typedef __compar_fn_t comparison_fn_t;
typedef int ( *__compar_d_fn_t)(const  void * , const  void * , void * );
extern void *bsearch(const  void *__key , const  void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) __attribute__((__nonnull__ (1, 2, 5)));
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) __attribute__((__nonnull__ (1, 4)));
extern void qsort_r(void *__base , size_t __nmemb , size_t __size , __compar_d_fn_t __compar , void *__arg ) __attribute__((__nonnull__ (1, 4)));
extern int abs(int __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long int labs(long  int __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern long long int llabs(long  long  int __x ) __attribute__((__nothrow__)) __attribute__((__const__));
extern div_t div(int __numer , int __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern ldiv_t ldiv(long  int __numer , long  int __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern lldiv_t lldiv(long  long  int __numer , long  long  int __denom ) __attribute__((__nothrow__)) __attribute__((__const__));
extern char *ecvt(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *fcvt(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *gcvt(double __value , int __ndigit , char *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern char *qecvt(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *qfcvt(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern char *qgcvt(long  double __value , int __ndigit , char *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern int ecvt_r(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int fcvt_r(double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int qecvt_r(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int qfcvt_r(long  double __value , int __ndigit , int *__restrict __decpt , int *__restrict __sign , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4, 5)));
extern int mblen(const  char *__s , size_t __n ) __attribute__((__nothrow__));
extern int mbtowc(wchar_t *__restrict __pwc , const  char *__restrict __s , size_t __n ) __attribute__((__nothrow__));
extern int wctomb(char *__s , wchar_t __wchar ) __attribute__((__nothrow__));
extern size_t mbstowcs(wchar_t *__restrict __pwcs , const  char *__restrict __s , size_t __n ) __attribute__((__nothrow__));
extern size_t wcstombs(char *__restrict __s , const  wchar_t *__restrict __pwcs , size_t __n ) __attribute__((__nothrow__));
extern int rpmatch(const  char *__response ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int getsubopt(char **__restrict __optionp , char *const *__restrict __tokens , char **__restrict __valuep ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2, 3)));
extern void setkey(const  char *__key ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int posix_openpt(int __oflag );
extern int grantpt(int __fd ) __attribute__((__nothrow__));
extern int unlockpt(int __fd ) __attribute__((__nothrow__));
extern char *ptsname(int __fd ) __attribute__((__nothrow__));
extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int getpt(void );
extern int getloadavg(double __loadavg[] , int __nelem ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
typedef long int ptrdiff_t;
extern void *memcpy(void *__restrict __dest , const  void *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *memmove(void *__dest , const  void *__src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *memccpy(void *__restrict __dest , const  void *__restrict __src , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *memset(void *__s , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int memcmp(const  void *__s1 , const  void *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern void *memchr(const  void *__s , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern void *rawmemchr(const  void *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern void *memrchr(const  void *__s , int __c , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strcpy(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strncpy(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strcat(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strncat(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int strcmp(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strncmp(const  char *__s1 , const  char *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strcoll(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern size_t strxfrm(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int strcoll_l(const  char *__s1 , const  char *__s2 , __locale_t __l ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2, 3)));
extern size_t strxfrm_l(char *__dest , const  char *__src , size_t __n , __locale_t __l ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern char *strdup(const  char *__s ) __attribute__((__nothrow__)) __attribute__((__malloc__)) __attribute__((__nonnull__ (1)));
extern char *strndup(const  char *__string , size_t __n ) __attribute__((__nothrow__)) __attribute__((__malloc__)) __attribute__((__nonnull__ (1)));
extern char *strchr(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strrchr(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strchrnul(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern size_t strcspn(const  char *__s , const  char *__reject ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern size_t strspn(const  char *__s , const  char *__accept ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strpbrk(const  char *__s , const  char *__accept ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strstr(const  char *__haystack , const  char *__needle ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strtok(char *__restrict __s , const  char *__restrict __delim ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern char *__strtok_r(char *__restrict __s , const  char *__restrict __delim , char **__restrict __save_ptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern char *strtok_r(char *__restrict __s , const  char *__restrict __delim , char **__restrict __save_ptr ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern char *strcasestr(const  char *__haystack , const  char *__needle ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern void *memmem(const  void *__haystack , size_t __haystacklen , const  void *__needle , size_t __needlelen ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 3)));
extern void *__mempcpy(void *__restrict __dest , const  void *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void *mempcpy(void *__restrict __dest , const  void *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern size_t strlen(const  char *__s ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern size_t strnlen(const  char *__string , size_t __maxlen ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *strerror(int __errnum ) __attribute__((__nothrow__));
extern char *strerror_r(int __errnum , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern char *strerror_l(int __errnum , __locale_t __l ) __attribute__((__nothrow__));
extern void __bzero(void *__s , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void bcopy(const  void *__src , void *__dest , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void bzero(void *__s , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int bcmp(const  void *__s1 , const  void *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *index(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern char *rindex(const  char *__s , int __c ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1)));
extern int ffs(int __i ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int ffsl(long  int __l ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int ffsll(long  long  int __ll ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int strcasecmp(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strncasecmp(const  char *__s1 , const  char *__s2 , size_t __n ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern int strcasecmp_l(const  char *__s1 , const  char *__s2 , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2, 3)));
extern int strncasecmp_l(const  char *__s1 , const  char *__s2 , size_t __n , __locale_t __loc ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2, 4)));
extern char *strsep(char **__restrict __stringp , const  char *__restrict __delim ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *strsignal(int __sig ) __attribute__((__nothrow__));
extern char *__stpcpy(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *stpcpy(char *__restrict __dest , const  char *__restrict __src ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *__stpncpy(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *stpncpy(char *__restrict __dest , const  char *__restrict __src , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int strverscmp(const  char *__s1 , const  char *__s2 ) __attribute__((__nothrow__)) __attribute__((__pure__)) __attribute__((__nonnull__ (1, 2)));
extern char *strfry(char *__string ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void *memfrob(void *__s , size_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *basename(const  char *__filename ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
typedef unsigned long int nfds_t;
struct  pollfd {
  int fd ;
  short  int events ;
  short  int revents ;
}  ;
extern int poll(struct  pollfd   *__fds , nfds_t __nfds , int __timeout );
extern int ppoll(struct  pollfd   *__fds , nfds_t __nfds , const  struct  timespec   *__timeout , const  __sigset_t *__ss );
struct  winsize {
  unsigned  short  int ws_row ;
  unsigned  short  int ws_col ;
  unsigned  short  int ws_xpixel ;
  unsigned  short  int ws_ypixel ;
}  ;
struct  termio {
  unsigned  short  int c_iflag ;
  unsigned  short  int c_oflag ;
  unsigned  short  int c_cflag ;
  unsigned  short  int c_lflag ;
  unsigned  char c_line ;
  unsigned  char c_cc[8] ;
}  ;
extern int ioctl(int __fd , unsigned  long  int __request , ...) __attribute__((__nothrow__));
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd , __off_t __offset ) __attribute__((__nothrow__));
extern void *mmap64(void *__addr , size_t __len , int __prot , int __flags , int __fd , __off64_t __offset ) __attribute__((__nothrow__));
extern int munmap(void *__addr , size_t __len ) __attribute__((__nothrow__));
extern int mprotect(void *__addr , size_t __len , int __prot ) __attribute__((__nothrow__));
extern int msync(void *__addr , size_t __len , int __flags );
extern int madvise(void *__addr , size_t __len , int __advice ) __attribute__((__nothrow__));
extern int posix_madvise(void *__addr , size_t __len , int __advice ) __attribute__((__nothrow__));
extern int mlock(const  void *__addr , size_t __len ) __attribute__((__nothrow__));
extern int munlock(const  void *__addr , size_t __len ) __attribute__((__nothrow__));
extern int mlockall(int __flags ) __attribute__((__nothrow__));
extern int munlockall(void ) __attribute__((__nothrow__));
extern int mincore(void *__start , size_t __len , unsigned  char *__vec ) __attribute__((__nothrow__));
extern void *mremap(void *__addr , size_t __old_len , size_t __new_len , int __flags , ...) __attribute__((__nothrow__));
extern int remap_file_pages(void *__start , size_t __size , int __prot , size_t __pgoff , int __flags ) __attribute__((__nothrow__));
extern int shm_open(const  char *__name , int __oflag , mode_t __mode );
extern int shm_unlink(const  char *__name );
extern int stat(const  char *__restrict __file , struct  stat   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fstat(int __fd , struct  stat   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int stat64(const  char *__restrict __file , struct  stat64   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fstat64(int __fd , struct  stat64   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int fstatat(int __fd , const  char *__restrict __file , struct  stat   *__restrict __buf , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int fstatat64(int __fd , const  char *__restrict __file , struct  stat64   *__restrict __buf , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int lstat(const  char *__restrict __file , struct  stat   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int lstat64(const  char *__restrict __file , struct  stat64   *__restrict __buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int chmod(const  char *__file , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int lchmod(const  char *__file , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchmod(int __fd , __mode_t __mode ) __attribute__((__nothrow__));
extern int fchmodat(int __fd , const  char *__file , __mode_t __mode , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern __mode_t umask(__mode_t __mask ) __attribute__((__nothrow__));
extern __mode_t getumask(void ) __attribute__((__nothrow__));
extern int mkdir(const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkdirat(int __fd , const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int mknod(const  char *__path , __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mknodat(int __fd , const  char *__path , __mode_t __mode , __dev_t __dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int mkfifo(const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int mkfifoat(int __fd , const  char *__path , __mode_t __mode ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int utimensat(int __fd , const  char *__path , const  struct  timespec   __times[2] , int __flags ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int futimens(int __fd , const  struct  timespec   __times[2] ) __attribute__((__nothrow__));
extern int __fxstat(int __ver , int __fildes , struct  stat   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern int __xstat(int __ver , const  char *__filename , struct  stat   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __lxstat(int __ver , const  char *__filename , struct  stat   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __fxstatat(int __ver , int __fildes , const  char *__filename , struct  stat   *__stat_buf , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern int __fxstat64(int __ver , int __fildes , struct  stat64   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3)));
extern int __xstat64(int __ver , const  char *__filename , struct  stat64   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __lxstat64(int __ver , const  char *__filename , struct  stat64   *__stat_buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int __fxstatat64(int __ver , int __fildes , const  char *__filename , struct  stat64   *__stat_buf , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 4)));
extern int __xmknod(int __ver , const  char *__path , __mode_t __mode , __dev_t *__dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int __xmknodat(int __ver , int __fd , const  char *__path , __mode_t __mode , __dev_t *__dev ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (3, 5)));
struct  timezone {
  int tz_minuteswest ;
  int tz_dsttime ;
}  ;
typedef struct  timezone   *__restrict __timezone_ptr_t;
extern int gettimeofday(struct  timeval   *__restrict __tv , __timezone_ptr_t __tz ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int settimeofday(const  struct  timeval   *__tv , const  struct  timezone   *__tz ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int adjtime(const  struct  timeval   *__delta , struct  timeval   *__olddelta ) __attribute__((__nothrow__));
enum __itimer_which {
  ITIMER_REAL = 0,
  ITIMER_VIRTUAL = 1,
  ITIMER_PROF = 2
} ;
struct  itimerval {
  struct  timeval   it_interval ;
  struct  timeval   it_value ;
}  ;
typedef enum __itimer_which __itimer_which_t;
extern int getitimer(__itimer_which_t __which , struct  itimerval   *__value ) __attribute__((__nothrow__));
extern int setitimer(__itimer_which_t __which , const  struct  itimerval   *__restrict __new , struct  itimerval   *__restrict __old ) __attribute__((__nothrow__));
extern int utimes(const  char *__file , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int lutimes(const  char *__file , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int futimes(int __fd , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__));
extern int futimesat(int __fd , const  char *__file , const  struct  timeval   __tvp[2] ) __attribute__((__nothrow__));
enum __rlimit_resource {
  RLIMIT_CPU = 0,
  RLIMIT_FSIZE = 1,
  RLIMIT_DATA = 2,
  RLIMIT_STACK = 3,
  RLIMIT_CORE = 4,
  __RLIMIT_RSS = 5,
  RLIMIT_NOFILE = 7,
  __RLIMIT_OFILE = RLIMIT_NOFILE,
  RLIMIT_AS = 9,
  __RLIMIT_NPROC = 6,
  __RLIMIT_MEMLOCK = 8,
  __RLIMIT_LOCKS = 10,
  __RLIMIT_SIGPENDING = 11,
  __RLIMIT_MSGQUEUE = 12,
  __RLIMIT_NICE = 13,
  __RLIMIT_RTPRIO = 14,
  __RLIMIT_NLIMITS = 15,
  __RLIM_NLIMITS = __RLIMIT_NLIMITS
} ;
typedef __rlim_t rlim_t;
typedef __rlim64_t rlim64_t;
struct  rlimit {
  rlim_t rlim_cur ;
  rlim_t rlim_max ;
}  ;
struct  rlimit64 {
  rlim64_t rlim_cur ;
  rlim64_t rlim_max ;
}  ;
enum __rusage_who {
  RUSAGE_SELF = 0,
  RUSAGE_CHILDREN = (- 1),
  RUSAGE_THREAD = 1
} ;
struct  rusage {
  struct  timeval   ru_utime ;
  struct  timeval   ru_stime ;
  long  int ru_maxrss ;
  long  int ru_ixrss ;
  long  int ru_idrss ;
  long  int ru_isrss ;
  long  int ru_minflt ;
  long  int ru_majflt ;
  long  int ru_nswap ;
  long  int ru_inblock ;
  long  int ru_oublock ;
  long  int ru_msgsnd ;
  long  int ru_msgrcv ;
  long  int ru_nsignals ;
  long  int ru_nvcsw ;
  long  int ru_nivcsw ;
}  ;
enum __priority_which {
  PRIO_PROCESS = 0,
  PRIO_PGRP = 1,
  PRIO_USER = 2
} ;
typedef enum __rlimit_resource __rlimit_resource_t;
typedef enum __rusage_who __rusage_who_t;
typedef enum __priority_which __priority_which_t;
extern int getrlimit(__rlimit_resource_t __resource , struct  rlimit   *__rlimits ) __attribute__((__nothrow__));
extern int getrlimit64(__rlimit_resource_t __resource , struct  rlimit64   *__rlimits ) __attribute__((__nothrow__));
extern int setrlimit(__rlimit_resource_t __resource , const  struct  rlimit   *__rlimits ) __attribute__((__nothrow__));
extern int setrlimit64(__rlimit_resource_t __resource , const  struct  rlimit64   *__rlimits ) __attribute__((__nothrow__));
extern int getrusage(__rusage_who_t __who , struct  rusage   *__usage ) __attribute__((__nothrow__));
extern int getpriority(__priority_which_t __which , id_t __who ) __attribute__((__nothrow__));
extern int setpriority(__priority_which_t __which , id_t __who , int __prio ) __attribute__((__nothrow__));
typedef enum  {
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
extern __pid_t wait(__WAIT_STATUS __stat_loc );
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options );
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options );
struct  rusage   ;
extern __pid_t wait3(__WAIT_STATUS __stat_loc , int __options , struct  rusage   *__usage ) __attribute__((__nothrow__));
extern __pid_t wait4(__pid_t __pid , __WAIT_STATUS __stat_loc , int __options , struct  rusage   *__usage ) __attribute__((__nothrow__));
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct  termios {
  tcflag_t c_iflag ;
  tcflag_t c_oflag ;
  tcflag_t c_cflag ;
  tcflag_t c_lflag ;
  cc_t c_line ;
  cc_t c_cc[32] ;
  speed_t c_ispeed ;
  speed_t c_ospeed ;
}  ;
extern speed_t cfgetospeed(const  struct  termios   *__termios_p ) __attribute__((__nothrow__));
extern speed_t cfgetispeed(const  struct  termios   *__termios_p ) __attribute__((__nothrow__));
extern int cfsetospeed(struct  termios   *__termios_p , speed_t __speed ) __attribute__((__nothrow__));
extern int cfsetispeed(struct  termios   *__termios_p , speed_t __speed ) __attribute__((__nothrow__));
extern int cfsetspeed(struct  termios   *__termios_p , speed_t __speed ) __attribute__((__nothrow__));
extern int tcgetattr(int __fd , struct  termios   *__termios_p ) __attribute__((__nothrow__));
extern int tcsetattr(int __fd , int __optional_actions , const  struct  termios   *__termios_p ) __attribute__((__nothrow__));
extern void cfmakeraw(struct  termios   *__termios_p ) __attribute__((__nothrow__));
extern int tcsendbreak(int __fd , int __duration ) __attribute__((__nothrow__));
extern int tcdrain(int __fd );
extern int tcflush(int __fd , int __queue_selector ) __attribute__((__nothrow__));
extern int tcflow(int __fd , int __action ) __attribute__((__nothrow__));
extern __pid_t tcgetsid(int __fd ) __attribute__((__nothrow__));
struct  tm {
  int tm_sec ;
  int tm_min ;
  int tm_hour ;
  int tm_mday ;
  int tm_mon ;
  int tm_year ;
  int tm_wday ;
  int tm_yday ;
  int tm_isdst ;
  long  int tm_gmtoff ;
  const  char *tm_zone ;
}  ;
struct  itimerspec {
  struct  timespec   it_interval ;
  struct  timespec   it_value ;
}  ;
struct  sigevent   ;
extern clock_t clock(void ) __attribute__((__nothrow__));
extern time_t time(time_t *__timer ) __attribute__((__nothrow__));
extern double difftime(time_t __time1 , time_t __time0 ) __attribute__((__nothrow__)) __attribute__((__const__));
extern time_t mktime(struct  tm   *__tp ) __attribute__((__nothrow__));
extern size_t strftime(char *__restrict __s , size_t __maxsize , const  char *__restrict __format , const  struct  tm   *__restrict __tp ) __attribute__((__nothrow__));
extern char *strptime(const  char *__restrict __s , const  char *__restrict __fmt , struct  tm   *__tp ) __attribute__((__nothrow__));
extern size_t strftime_l(char *__restrict __s , size_t __maxsize , const  char *__restrict __format , const  struct  tm   *__restrict __tp , __locale_t __loc ) __attribute__((__nothrow__));
extern char *strptime_l(const  char *__restrict __s , const  char *__restrict __fmt , struct  tm   *__tp , __locale_t __loc ) __attribute__((__nothrow__));
extern struct  tm   *gmtime(const  time_t *__timer ) __attribute__((__nothrow__));
extern struct  tm   *localtime(const  time_t *__timer ) __attribute__((__nothrow__));
extern struct  tm   *gmtime_r(const  time_t *__restrict __timer , struct  tm   *__restrict __tp ) __attribute__((__nothrow__));
extern struct  tm   *localtime_r(const  time_t *__restrict __timer , struct  tm   *__restrict __tp ) __attribute__((__nothrow__));
extern char *asctime(const  struct  tm   *__tp ) __attribute__((__nothrow__));
extern char *ctime(const  time_t *__timer ) __attribute__((__nothrow__));
extern char *asctime_r(const  struct  tm   *__restrict __tp , char *__restrict __buf ) __attribute__((__nothrow__));
extern char *ctime_r(const  time_t *__restrict __timer , char *__restrict __buf ) __attribute__((__nothrow__));
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;
extern char *tzname[2];
extern void tzset(void ) __attribute__((__nothrow__));
extern int daylight;
extern long int timezone;
extern int stime(const  time_t *__when ) __attribute__((__nothrow__));
extern time_t timegm(struct  tm   *__tp ) __attribute__((__nothrow__));
extern time_t timelocal(struct  tm   *__tp ) __attribute__((__nothrow__));
extern int dysize(int __year ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int nanosleep(const  struct  timespec   *__requested_time , struct  timespec   *__remaining );
extern int clock_getres(clockid_t __clock_id , struct  timespec   *__res ) __attribute__((__nothrow__));
extern int clock_gettime(clockid_t __clock_id , struct  timespec   *__tp ) __attribute__((__nothrow__));
extern int clock_settime(clockid_t __clock_id , const  struct  timespec   *__tp ) __attribute__((__nothrow__));
extern int clock_nanosleep(clockid_t __clock_id , int __flags , const  struct  timespec   *__req , struct  timespec   *__rem );
extern int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) __attribute__((__nothrow__));
extern int timer_create(clockid_t __clock_id , struct  sigevent   *__restrict __evp , timer_t *__restrict __timerid ) __attribute__((__nothrow__));
extern int timer_delete(timer_t __timerid ) __attribute__((__nothrow__));
extern int timer_settime(timer_t __timerid , int __flags , const  struct  itimerspec   *__restrict __value , struct  itimerspec   *__restrict __ovalue ) __attribute__((__nothrow__));
extern int timer_gettime(timer_t __timerid , struct  itimerspec   *__value ) __attribute__((__nothrow__));
extern int timer_getoverrun(timer_t __timerid ) __attribute__((__nothrow__));
extern int getdate_err;
extern struct  tm   *getdate(const  char *__string );
extern int getdate_r(const  char *__restrict __string , struct  tm   *__restrict __resbufp );
extern int access(const  char *__name , int __type ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int euidaccess(const  char *__name , int __type ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int eaccess(const  char *__name , int __type ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int faccessat(int __fd , const  char *__file , int __type , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern __off_t lseek(int __fd , __off_t __offset , int __whence ) __attribute__((__nothrow__));
extern __off64_t lseek64(int __fd , __off64_t __offset , int __whence ) __attribute__((__nothrow__));
extern int close(int __fd );
extern ssize_t read(int __fd , void *__buf , size_t __nbytes );
extern ssize_t write(int __fd , const  void *__buf , size_t __n );
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset );
extern ssize_t pwrite(int __fd , const  void *__buf , size_t __n , __off_t __offset );
extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset );
extern ssize_t pwrite64(int __fd , const  void *__buf , size_t __n , __off64_t __offset );
extern int pipe(int __pipedes[2] ) __attribute__((__nothrow__));
extern int pipe2(int __pipedes[2] , int __flags ) __attribute__((__nothrow__));
extern unsigned int alarm(unsigned  int __seconds ) __attribute__((__nothrow__));
extern unsigned int sleep(unsigned  int __seconds );
extern __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) __attribute__((__nothrow__));
extern int usleep(__useconds_t __useconds );
extern int pause(void );
extern int chown(const  char *__file , __uid_t __owner , __gid_t __group ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchown(int __fd , __uid_t __owner , __gid_t __group ) __attribute__((__nothrow__));
extern int lchown(const  char *__file , __uid_t __owner , __gid_t __group ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchownat(int __fd , const  char *__file , __uid_t __owner , __gid_t __group , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int chdir(const  char *__path ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int fchdir(int __fd ) __attribute__((__nothrow__));
extern char *getcwd(char *__buf , size_t __size ) __attribute__((__nothrow__));
extern char *get_current_dir_name(void ) __attribute__((__nothrow__));
extern char *getwd(char *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1))) __attribute__((__deprecated__));
extern int dup(int __fd ) __attribute__((__nothrow__));
extern int dup2(int __fd , int __fd2 ) __attribute__((__nothrow__));
extern int dup3(int __fd , int __fd2 , int __flags ) __attribute__((__nothrow__));
extern char **__environ;
extern char **environ;
extern int execve(const  char *__path , char *const __argv[] , char *const __envp[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fexecve(int __fd , char *const __argv[] , char *const __envp[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int execv(const  char *__path , char *const __argv[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execle(const  char *__path , const  char *__arg , ...) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execl(const  char *__path , const  char *__arg , ...) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execvp(const  char *__file , char *const __argv[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execlp(const  char *__file , const  char *__arg , ...) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int execvpe(const  char *__file , char *const __argv[] , char *const __envp[] ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int nice(int __inc ) __attribute__((__nothrow__));
extern void _exit(int __status ) __attribute__((__noreturn__));
enum  {
  _PC_LINK_MAX,
  _PC_MAX_CANON,
  _PC_MAX_INPUT,
  _PC_NAME_MAX,
  _PC_PATH_MAX,
  _PC_PIPE_BUF,
  _PC_CHOWN_RESTRICTED,
  _PC_NO_TRUNC,
  _PC_VDISABLE,
  _PC_SYNC_IO,
  _PC_ASYNC_IO,
  _PC_PRIO_IO,
  _PC_SOCK_MAXBUF,
  _PC_FILESIZEBITS,
  _PC_REC_INCR_XFER_SIZE,
  _PC_REC_MAX_XFER_SIZE,
  _PC_REC_MIN_XFER_SIZE,
  _PC_REC_XFER_ALIGN,
  _PC_ALLOC_SIZE_MIN,
  _PC_SYMLINK_MAX,
  _PC_2_SYMLINKS
} ;
enum  {
  _SC_ARG_MAX,
  _SC_CHILD_MAX,
  _SC_CLK_TCK,
  _SC_NGROUPS_MAX,
  _SC_OPEN_MAX,
  _SC_STREAM_MAX,
  _SC_TZNAME_MAX,
  _SC_JOB_CONTROL,
  _SC_SAVED_IDS,
  _SC_REALTIME_SIGNALS,
  _SC_PRIORITY_SCHEDULING,
  _SC_TIMERS,
  _SC_ASYNCHRONOUS_IO,
  _SC_PRIORITIZED_IO,
  _SC_SYNCHRONIZED_IO,
  _SC_FSYNC,
  _SC_MAPPED_FILES,
  _SC_MEMLOCK,
  _SC_MEMLOCK_RANGE,
  _SC_MEMORY_PROTECTION,
  _SC_MESSAGE_PASSING,
  _SC_SEMAPHORES,
  _SC_SHARED_MEMORY_OBJECTS,
  _SC_AIO_LISTIO_MAX,
  _SC_AIO_MAX,
  _SC_AIO_PRIO_DELTA_MAX,
  _SC_DELAYTIMER_MAX,
  _SC_MQ_OPEN_MAX,
  _SC_MQ_PRIO_MAX,
  _SC_VERSION,
  _SC_PAGESIZE,
  _SC_RTSIG_MAX,
  _SC_SEM_NSEMS_MAX,
  _SC_SEM_VALUE_MAX,
  _SC_SIGQUEUE_MAX,
  _SC_TIMER_MAX,
  _SC_BC_BASE_MAX,
  _SC_BC_DIM_MAX,
  _SC_BC_SCALE_MAX,
  _SC_BC_STRING_MAX,
  _SC_COLL_WEIGHTS_MAX,
  _SC_EQUIV_CLASS_MAX,
  _SC_EXPR_NEST_MAX,
  _SC_LINE_MAX,
  _SC_RE_DUP_MAX,
  _SC_CHARCLASS_NAME_MAX,
  _SC_2_VERSION,
  _SC_2_C_BIND,
  _SC_2_C_DEV,
  _SC_2_FORT_DEV,
  _SC_2_FORT_RUN,
  _SC_2_SW_DEV,
  _SC_2_LOCALEDEF,
  _SC_PII,
  _SC_PII_XTI,
  _SC_PII_SOCKET,
  _SC_PII_INTERNET,
  _SC_PII_OSI,
  _SC_POLL,
  _SC_SELECT,
  _SC_UIO_MAXIOV,
  _SC_IOV_MAX = _SC_UIO_MAXIOV,
  _SC_PII_INTERNET_STREAM,
  _SC_PII_INTERNET_DGRAM,
  _SC_PII_OSI_COTS,
  _SC_PII_OSI_CLTS,
  _SC_PII_OSI_M,
  _SC_T_IOV_MAX,
  _SC_THREADS,
  _SC_THREAD_SAFE_FUNCTIONS,
  _SC_GETGR_R_SIZE_MAX,
  _SC_GETPW_R_SIZE_MAX,
  _SC_LOGIN_NAME_MAX,
  _SC_TTY_NAME_MAX,
  _SC_THREAD_DESTRUCTOR_ITERATIONS,
  _SC_THREAD_KEYS_MAX,
  _SC_THREAD_STACK_MIN,
  _SC_THREAD_THREADS_MAX,
  _SC_THREAD_ATTR_STACKADDR,
  _SC_THREAD_ATTR_STACKSIZE,
  _SC_THREAD_PRIORITY_SCHEDULING,
  _SC_THREAD_PRIO_INHERIT,
  _SC_THREAD_PRIO_PROTECT,
  _SC_THREAD_PROCESS_SHARED,
  _SC_NPROCESSORS_CONF,
  _SC_NPROCESSORS_ONLN,
  _SC_PHYS_PAGES,
  _SC_AVPHYS_PAGES,
  _SC_ATEXIT_MAX,
  _SC_PASS_MAX,
  _SC_XOPEN_VERSION,
  _SC_XOPEN_XCU_VERSION,
  _SC_XOPEN_UNIX,
  _SC_XOPEN_CRYPT,
  _SC_XOPEN_ENH_I18N,
  _SC_XOPEN_SHM,
  _SC_2_CHAR_TERM,
  _SC_2_C_VERSION,
  _SC_2_UPE,
  _SC_XOPEN_XPG2,
  _SC_XOPEN_XPG3,
  _SC_XOPEN_XPG4,
  _SC_CHAR_BIT,
  _SC_CHAR_MAX,
  _SC_CHAR_MIN,
  _SC_INT_MAX,
  _SC_INT_MIN,
  _SC_LONG_BIT,
  _SC_WORD_BIT,
  _SC_MB_LEN_MAX,
  _SC_NZERO,
  _SC_SSIZE_MAX,
  _SC_SCHAR_MAX,
  _SC_SCHAR_MIN,
  _SC_SHRT_MAX,
  _SC_SHRT_MIN,
  _SC_UCHAR_MAX,
  _SC_UINT_MAX,
  _SC_ULONG_MAX,
  _SC_USHRT_MAX,
  _SC_NL_ARGMAX,
  _SC_NL_LANGMAX,
  _SC_NL_MSGMAX,
  _SC_NL_NMAX,
  _SC_NL_SETMAX,
  _SC_NL_TEXTMAX,
  _SC_XBS5_ILP32_OFF32,
  _SC_XBS5_ILP32_OFFBIG,
  _SC_XBS5_LP64_OFF64,
  _SC_XBS5_LPBIG_OFFBIG,
  _SC_XOPEN_LEGACY,
  _SC_XOPEN_REALTIME,
  _SC_XOPEN_REALTIME_THREADS,
  _SC_ADVISORY_INFO,
  _SC_BARRIERS,
  _SC_BASE,
  _SC_C_LANG_SUPPORT,
  _SC_C_LANG_SUPPORT_R,
  _SC_CLOCK_SELECTION,
  _SC_CPUTIME,
  _SC_THREAD_CPUTIME,
  _SC_DEVICE_IO,
  _SC_DEVICE_SPECIFIC,
  _SC_DEVICE_SPECIFIC_R,
  _SC_FD_MGMT,
  _SC_FIFO,
  _SC_PIPE,
  _SC_FILE_ATTRIBUTES,
  _SC_FILE_LOCKING,
  _SC_FILE_SYSTEM,
  _SC_MONOTONIC_CLOCK,
  _SC_MULTI_PROCESS,
  _SC_SINGLE_PROCESS,
  _SC_NETWORKING,
  _SC_READER_WRITER_LOCKS,
  _SC_SPIN_LOCKS,
  _SC_REGEXP,
  _SC_REGEX_VERSION,
  _SC_SHELL,
  _SC_SIGNALS,
  _SC_SPAWN,
  _SC_SPORADIC_SERVER,
  _SC_THREAD_SPORADIC_SERVER,
  _SC_SYSTEM_DATABASE,
  _SC_SYSTEM_DATABASE_R,
  _SC_TIMEOUTS,
  _SC_TYPED_MEMORY_OBJECTS,
  _SC_USER_GROUPS,
  _SC_USER_GROUPS_R,
  _SC_2_PBS,
  _SC_2_PBS_ACCOUNTING,
  _SC_2_PBS_LOCATE,
  _SC_2_PBS_MESSAGE,
  _SC_2_PBS_TRACK,
  _SC_SYMLOOP_MAX,
  _SC_STREAMS,
  _SC_2_PBS_CHECKPOINT,
  _SC_V6_ILP32_OFF32,
  _SC_V6_ILP32_OFFBIG,
  _SC_V6_LP64_OFF64,
  _SC_V6_LPBIG_OFFBIG,
  _SC_HOST_NAME_MAX,
  _SC_TRACE,
  _SC_TRACE_EVENT_FILTER,
  _SC_TRACE_INHERIT,
  _SC_TRACE_LOG,
  _SC_LEVEL1_ICACHE_SIZE,
  _SC_LEVEL1_ICACHE_ASSOC,
  _SC_LEVEL1_ICACHE_LINESIZE,
  _SC_LEVEL1_DCACHE_SIZE,
  _SC_LEVEL1_DCACHE_ASSOC,
  _SC_LEVEL1_DCACHE_LINESIZE,
  _SC_LEVEL2_CACHE_SIZE,
  _SC_LEVEL2_CACHE_ASSOC,
  _SC_LEVEL2_CACHE_LINESIZE,
  _SC_LEVEL3_CACHE_SIZE,
  _SC_LEVEL3_CACHE_ASSOC,
  _SC_LEVEL3_CACHE_LINESIZE,
  _SC_LEVEL4_CACHE_SIZE,
  _SC_LEVEL4_CACHE_ASSOC,
  _SC_LEVEL4_CACHE_LINESIZE,
  _SC_IPV6 = (_SC_LEVEL1_ICACHE_SIZE + 50),
  _SC_RAW_SOCKETS,
  _SC_V7_ILP32_OFF32,
  _SC_V7_ILP32_OFFBIG,
  _SC_V7_LP64_OFF64,
  _SC_V7_LPBIG_OFFBIG,
  _SC_SS_REPL_MAX,
  _SC_TRACE_EVENT_NAME_MAX,
  _SC_TRACE_NAME_MAX,
  _SC_TRACE_SYS_MAX,
  _SC_TRACE_USER_EVENT_MAX,
  _SC_XOPEN_STREAMS,
  _SC_THREAD_ROBUST_PRIO_INHERIT,
  _SC_THREAD_ROBUST_PRIO_PROTECT
} ;
enum  {
  _CS_PATH,
  _CS_V6_WIDTH_RESTRICTED_ENVS,
  _CS_GNU_LIBC_VERSION,
  _CS_GNU_LIBPTHREAD_VERSION,
  _CS_V5_WIDTH_RESTRICTED_ENVS,
  _CS_V7_WIDTH_RESTRICTED_ENVS,
  _CS_LFS_CFLAGS = 1000,
  _CS_LFS_LDFLAGS,
  _CS_LFS_LIBS,
  _CS_LFS_LINTFLAGS,
  _CS_LFS64_CFLAGS,
  _CS_LFS64_LDFLAGS,
  _CS_LFS64_LIBS,
  _CS_LFS64_LINTFLAGS,
  _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
  _CS_XBS5_ILP32_OFF32_LDFLAGS,
  _CS_XBS5_ILP32_OFF32_LIBS,
  _CS_XBS5_ILP32_OFF32_LINTFLAGS,
  _CS_XBS5_ILP32_OFFBIG_CFLAGS,
  _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
  _CS_XBS5_ILP32_OFFBIG_LIBS,
  _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
  _CS_XBS5_LP64_OFF64_CFLAGS,
  _CS_XBS5_LP64_OFF64_LDFLAGS,
  _CS_XBS5_LP64_OFF64_LIBS,
  _CS_XBS5_LP64_OFF64_LINTFLAGS,
  _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
  _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
  _CS_XBS5_LPBIG_OFFBIG_LIBS,
  _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,
  _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
  _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
  _CS_POSIX_V6_ILP32_OFF32_LIBS,
  _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
  _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
  _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
  _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
  _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
  _CS_POSIX_V6_LP64_OFF64_CFLAGS,
  _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
  _CS_POSIX_V6_LP64_OFF64_LIBS,
  _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
  _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
  _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
  _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
  _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
  _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
  _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
  _CS_POSIX_V7_ILP32_OFF32_LIBS,
  _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
  _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
  _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
  _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
  _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
  _CS_POSIX_V7_LP64_OFF64_CFLAGS,
  _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
  _CS_POSIX_V7_LP64_OFF64_LIBS,
  _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
  _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
  _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
  _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
  _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
  _CS_V6_ENV,
  _CS_V7_ENV
} ;
extern long int pathconf(const  char *__path , int __name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern long int fpathconf(int __fd , int __name ) __attribute__((__nothrow__));
extern long int sysconf(int __name ) __attribute__((__nothrow__));
extern size_t confstr(int __name , char *__buf , size_t __len ) __attribute__((__nothrow__));
extern __pid_t getpid(void ) __attribute__((__nothrow__));
extern __pid_t getppid(void ) __attribute__((__nothrow__));
extern __pid_t getpgrp(void ) __attribute__((__nothrow__));
extern __pid_t __getpgid(__pid_t __pid ) __attribute__((__nothrow__));
extern __pid_t getpgid(__pid_t __pid ) __attribute__((__nothrow__));
extern int setpgid(__pid_t __pid , __pid_t __pgid ) __attribute__((__nothrow__));
extern int setpgrp(void ) __attribute__((__nothrow__));
extern __pid_t setsid(void ) __attribute__((__nothrow__));
extern __pid_t getsid(__pid_t __pid ) __attribute__((__nothrow__));
extern __uid_t getuid(void ) __attribute__((__nothrow__));
extern __uid_t geteuid(void ) __attribute__((__nothrow__));
extern __gid_t getgid(void ) __attribute__((__nothrow__));
extern __gid_t getegid(void ) __attribute__((__nothrow__));
extern int getgroups(int __size , __gid_t __list[] ) __attribute__((__nothrow__));
extern int group_member(__gid_t __gid ) __attribute__((__nothrow__));
extern int setuid(__uid_t __uid ) __attribute__((__nothrow__));
extern int setreuid(__uid_t __ruid , __uid_t __euid ) __attribute__((__nothrow__));
extern int seteuid(__uid_t __uid ) __attribute__((__nothrow__));
extern int setgid(__gid_t __gid ) __attribute__((__nothrow__));
extern int setregid(__gid_t __rgid , __gid_t __egid ) __attribute__((__nothrow__));
extern int setegid(__gid_t __gid ) __attribute__((__nothrow__));
extern int getresuid(__uid_t *__ruid , __uid_t *__euid , __uid_t *__suid ) __attribute__((__nothrow__));
extern int getresgid(__gid_t *__rgid , __gid_t *__egid , __gid_t *__sgid ) __attribute__((__nothrow__));
extern int setresuid(__uid_t __ruid , __uid_t __euid , __uid_t __suid ) __attribute__((__nothrow__));
extern int setresgid(__gid_t __rgid , __gid_t __egid , __gid_t __sgid ) __attribute__((__nothrow__));
extern __pid_t fork(void ) __attribute__((__nothrow__));
extern __pid_t vfork(void ) __attribute__((__nothrow__));
extern char *ttyname(int __fd ) __attribute__((__nothrow__));
extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int isatty(int __fd ) __attribute__((__nothrow__));
extern int ttyslot(void ) __attribute__((__nothrow__));
extern int link(const  char *__from , const  char *__to ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int linkat(int __fromfd , const  char *__from , int __tofd , const  char *__to , int __flags ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 4)));
extern int symlink(const  char *__from , const  char *__to ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern ssize_t readlink(const  char *__restrict __path , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int symlinkat(const  char *__from , int __tofd , const  char *__to ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 3)));
extern ssize_t readlinkat(int __fd , const  char *__restrict __path , char *__restrict __buf , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2, 3)));
extern int unlink(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int unlinkat(int __fd , const  char *__name , int __flag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int rmdir(const  char *__path ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern __pid_t tcgetpgrp(int __fd ) __attribute__((__nothrow__));
extern int tcsetpgrp(int __fd , __pid_t __pgrp_id ) __attribute__((__nothrow__));
extern char *getlogin(void );
extern int getlogin_r(char *__name , size_t __name_len ) __attribute__((__nonnull__ (1)));
extern int setlogin(const  char *__name ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *optarg;
extern int optind;
extern int opterr;
extern int optopt;
extern int getopt(int ___argc , char *const *___argv , const  char *__shortopts ) __attribute__((__nothrow__));
extern int gethostname(char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sethostname(const  char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int sethostid(long  int __id ) __attribute__((__nothrow__));
extern int getdomainname(char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int setdomainname(const  char *__name , size_t __len ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int vhangup(void ) __attribute__((__nothrow__));
extern int revoke(const  char *__file ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int profil(unsigned  short  int *__sample_buffer , size_t __size , size_t __offset , unsigned  int __scale ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int acct(const  char *__name ) __attribute__((__nothrow__));
extern char *getusershell(void ) __attribute__((__nothrow__));
extern void endusershell(void ) __attribute__((__nothrow__));
extern void setusershell(void ) __attribute__((__nothrow__));
extern int daemon(int __nochdir , int __noclose ) __attribute__((__nothrow__));
extern int chroot(const  char *__path ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern char *getpass(const  char *__prompt ) __attribute__((__nonnull__ (1)));
extern int fsync(int __fd );
extern long int gethostid(void );
extern void sync(void ) __attribute__((__nothrow__));
extern int getpagesize(void ) __attribute__((__nothrow__)) __attribute__((__const__));
extern int getdtablesize(void ) __attribute__((__nothrow__));
extern int truncate(const  char *__file , __off_t __length ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int truncate64(const  char *__file , __off64_t __length ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern int ftruncate(int __fd , __off_t __length ) __attribute__((__nothrow__));
extern int ftruncate64(int __fd , __off64_t __length ) __attribute__((__nothrow__));
extern int brk(void *__addr ) __attribute__((__nothrow__));
extern void *sbrk(intptr_t __delta ) __attribute__((__nothrow__));
extern long int syscall(long  int __sysno , ...) __attribute__((__nothrow__));
extern int fdatasync(int __fildes );
extern char *crypt(const  char *__key , const  char *__salt ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern void encrypt(char *__block , int __edflag ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1)));
extern void swab(const  void *__restrict __from , void *__restrict __to , ssize_t __n ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern char *ctermid(char *__s ) __attribute__((__nothrow__));
struct  mntent {
  char *mnt_fsname ;
  char *mnt_dir ;
  char *mnt_type ;
  char *mnt_opts ;
  int mnt_freq ;
  int mnt_passno ;
}  ;
extern FILE *setmntent(const  char *__file , const  char *__mode ) __attribute__((__nothrow__));
extern struct  mntent   *getmntent(FILE *__stream ) __attribute__((__nothrow__));
extern struct  mntent   *getmntent_r(FILE *__restrict __stream , struct  mntent   *__restrict __result , char *__restrict __buffer , int __bufsize ) __attribute__((__nothrow__));
extern int addmntent(FILE *__restrict __stream , const  struct  mntent   *__restrict __mnt ) __attribute__((__nothrow__));
extern int endmntent(FILE *__stream ) __attribute__((__nothrow__));
extern char *hasmntopt(const  struct  mntent   *__mnt , const  char *__opt ) __attribute__((__nothrow__));
struct  statfs {
  long  int f_type ;
  long  int f_bsize ;
  __fsblkcnt_t f_blocks ;
  __fsblkcnt_t f_bfree ;
  __fsblkcnt_t f_bavail ;
  __fsfilcnt_t f_files ;
  __fsfilcnt_t f_ffree ;
  __fsid_t f_fsid ;
  long  int f_namelen ;
  long  int f_frsize ;
  long  int f_spare[5] ;
}  ;
struct  statfs64 {
  long  int f_type ;
  long  int f_bsize ;
  __fsblkcnt64_t f_blocks ;
  __fsblkcnt64_t f_bfree ;
  __fsblkcnt64_t f_bavail ;
  __fsfilcnt64_t f_files ;
  __fsfilcnt64_t f_ffree ;
  __fsid_t f_fsid ;
  long  int f_namelen ;
  long  int f_frsize ;
  long  int f_spare[5] ;
}  ;
extern int statfs(const  char *__file , struct  statfs   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int statfs64(const  char *__file , struct  statfs64   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (1, 2)));
extern int fstatfs(int __fildes , struct  statfs   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int fstatfs64(int __fildes , struct  statfs64   *__buf ) __attribute__((__nothrow__)) __attribute__((__nonnull__ (2)));
extern int _1_is_selinux_enabled(void );
extern int _1_is_selinux_mls_enabled(void );
typedef char *_1_security_context_t;
extern void _1_freecon(_1_security_context_t con );
extern void _1_freeconary(_1_security_context_t *con );
extern int _1_getcon(_1_security_context_t *con );
extern int _1_getcon_raw(_1_security_context_t *con );
extern int _1_setcon(_1_security_context_t con );
extern int _1_setcon_raw(_1_security_context_t con );
extern int _1_getpidcon(pid_t pid , _1_security_context_t *con );
extern int _1_getpidcon_raw(pid_t pid , _1_security_context_t *con );
extern int _1_getprevcon(_1_security_context_t *con );
extern int _1_getprevcon_raw(_1_security_context_t *con );
extern int _1_getexeccon(_1_security_context_t *con );
extern int _1_getexeccon_raw(_1_security_context_t *con );
extern int _1_setexeccon(_1_security_context_t con );
extern int _1_setexeccon_raw(_1_security_context_t con );
extern int _1_getfscreatecon(_1_security_context_t *con );
extern int _1_getfscreatecon_raw(_1_security_context_t *con );
extern int _1_setfscreatecon(_1_security_context_t context );
extern int _1_setfscreatecon_raw(_1_security_context_t context );
extern int _1_getkeycreatecon(_1_security_context_t *con );
extern int _1_getkeycreatecon_raw(_1_security_context_t *con );
extern int _1_setkeycreatecon(_1_security_context_t context );
extern int _1_setkeycreatecon_raw(_1_security_context_t context );
extern int _1_getsockcreatecon(_1_security_context_t *con );
extern int _1_getsockcreatecon_raw(_1_security_context_t *con );
extern int _1_setsockcreatecon(_1_security_context_t context );
extern int _1_setsockcreatecon_raw(_1_security_context_t context );
extern int _1_getfilecon(const  char *path , _1_security_context_t *con );
extern int _1_getfilecon_raw(const  char *path , _1_security_context_t *con );
extern int _1_lgetfilecon(const  char *path , _1_security_context_t *con );
extern int _1_lgetfilecon_raw(const  char *path , _1_security_context_t *con );
extern int _1_fgetfilecon(int fd , _1_security_context_t *con );
extern int _1_fgetfilecon_raw(int fd , _1_security_context_t *con );
extern int _1_setfilecon(const  char *path , _1_security_context_t con );
extern int _1_setfilecon_raw(const  char *path , _1_security_context_t con );
extern int _1_lsetfilecon(const  char *path , _1_security_context_t con );
extern int _1_lsetfilecon_raw(const  char *path , _1_security_context_t con );
extern int _1_fsetfilecon(int fd , _1_security_context_t con );
extern int _1_fsetfilecon_raw(int fd , _1_security_context_t con );
extern int _1_getpeercon(int fd , _1_security_context_t *con );
extern int _1_getpeercon_raw(int fd , _1_security_context_t *con );
typedef unsigned int _1_access_vector_t;
typedef unsigned short _1_security_class_t;
struct  _1_av_decision {
  _1_access_vector_t allowed ;
  _1_access_vector_t decided ;
  _1_access_vector_t auditallow ;
  _1_access_vector_t auditdeny ;
  unsigned  int seqno ;
  unsigned  int flags ;
}  ;
struct  _1_selinux_opt {
  int type ;
  const  char *value ;
}  ;
union  _1_selinux_callback {
  int  __attribute__((format (printf, 2, 3))) ( *func_log)(int type , const  char *fmt , ...) ;
  int ( *func_audit)(void *auditdata , _1_security_class_t cls , char *msgbuf , size_t msgbufsize ) ;
  int ( *func_validate)(_1_security_context_t *ctx ) ;
  int ( *func_setenforce)(int enforcing ) ;
  int ( *func_policyload)(int seqno ) ;
}  ;
extern union  _1_selinux_callback   _1_selinux_get_callback(int type );
extern void _1_selinux_set_callback(int type , union  _1_selinux_callback   cb );
extern int _1_security_compute_av(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_access_vector_t requested , struct  _1_av_decision   *avd );
extern int _1_security_compute_av_raw(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_access_vector_t requested , struct  _1_av_decision   *avd );
extern int _1_security_compute_av_flags(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_access_vector_t requested , struct  _1_av_decision   *avd );
extern int _1_security_compute_av_flags_raw(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_access_vector_t requested , struct  _1_av_decision   *avd );
extern int _1_security_compute_create(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_security_context_t *newcon );
extern int _1_security_compute_create_raw(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_security_context_t *newcon );
extern int _1_security_compute_relabel(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_security_context_t *newcon );
extern int _1_security_compute_relabel_raw(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_security_context_t *newcon );
extern int _1_security_compute_member(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_security_context_t *newcon );
extern int _1_security_compute_member_raw(_1_security_context_t scon , _1_security_context_t tcon , _1_security_class_t tclass , _1_security_context_t *newcon );
extern int _1_security_compute_user(_1_security_context_t scon , const  char *username , _1_security_context_t **con );
extern int _1_security_compute_user_raw(_1_security_context_t scon , const  char *username , _1_security_context_t **con );
extern int _1_security_load_policy(void *data , size_t len );
extern int _1_security_get_initial_context(const  char *name , _1_security_context_t *con );
extern int _1_security_get_initial_context_raw(const  char *name , _1_security_context_t *con );
extern int _1_selinux_mkload_policy(int preservebools );
extern int _1_selinux_init_load_policy(int *enforce );
typedef struct   {
  char *name ;
  int value ;
}  _1_SELboolean;
extern int _1_security_set_boolean_list(size_t boolcnt , _1_SELboolean *boollist , int permanent );
extern int _1_security_load_booleans(char *path );
extern int _1_security_check_context(_1_security_context_t con );
extern int _1_security_check_context_raw(_1_security_context_t con );
extern int _1_security_canonicalize_context(_1_security_context_t con , _1_security_context_t *canoncon );
extern int _1_security_canonicalize_context_raw(_1_security_context_t con , _1_security_context_t *canoncon );
extern int _1_security_getenforce(void );
extern int _1_security_setenforce(int value );
extern int _1_security_deny_unknown(void );
extern int _1_security_disable(void );
extern int _1_security_policyvers(void );
extern int _1_security_get_boolean_names(char ***names , int *len );
extern int _1_security_get_boolean_pending(const  char *name );
extern int _1_security_get_boolean_active(const  char *name );
extern int _1_security_set_boolean(const  char *name , int value );
extern int _1_security_commit_booleans(void );
struct  _1_security_class_mapping {
  const  char *name ;
  const  char *perms[((sizeof(_1_access_vector_t ) * 8) + 1)] ;
}  ;
extern int _1_selinux_set_mapping(struct  _1_security_class_mapping   *map );
extern _1_security_class_t _1_string_to_security_class(const  char *name );
extern const char *_1_security_class_to_string(_1_security_class_t cls );
extern const char *_1_security_av_perm_to_string(_1_security_class_t tclass , _1_access_vector_t perm );
extern _1_access_vector_t _1_string_to_av_perm(_1_security_class_t tclass , const  char *name );
extern int _1_security_av_string(_1_security_class_t tclass , _1_access_vector_t av , char **result );
extern void _1_print_access_vector(_1_security_class_t tclass , _1_access_vector_t av );
extern void _1_set_matchpathcon_printf(void ( *f)(const  char *fmt , ...) );
extern void _1_set_matchpathcon_invalidcon(int ( *f)(const  char *path , unsigned lineno , char *context ) );
extern void _1_set_matchpathcon_canoncon(int ( *f)(const  char *path , unsigned lineno , char **context ) );
extern void _1_set_matchpathcon_flags(unsigned  int flags );
extern int _1_matchpathcon_init(const  char *path );
extern int _1_matchpathcon_init_prefix(const  char *path , const  char *prefix );
extern void _1_matchpathcon_fini(void );
extern int _1_matchpathcon(const  char *path , mode_t mode , _1_security_context_t *con );
extern int _1_matchpathcon_index(const  char *path , mode_t mode , _1_security_context_t *con );
extern int _1_matchpathcon_filespec_add(ino_t ino , int specind , const  char *file );
extern void _1_matchpathcon_filespec_destroy(void );
extern void _1_matchpathcon_filespec_eval(void );
extern void _1_matchpathcon_checkmatches(char *str );
extern int _1_matchmediacon(const  char *media , _1_security_context_t *con );
extern int _1_selinux_getenforcemode(int *enforce );
extern int _1_selinux_getpolicytype(char **policytype );
extern const char *_1_selinux_policy_root(void );
extern const char *_1_selinux_binary_policy_path(void );
extern const char *_1_selinux_failsafe_context_path(void );
extern const char *_1_selinux_removable_context_path(void );
extern const char *_1_selinux_default_context_path(void );
extern const char *_1_selinux_user_contexts_path(void );
extern const char *_1_selinux_file_context_path(void );
extern const char *_1_selinux_file_context_homedir_path(void );
extern const char *_1_selinux_file_context_local_path(void );
extern const char *_1_selinux_file_context_subs_path(void );
extern const char *_1_selinux_homedir_context_path(void );
extern const char *_1_selinux_media_context_path(void );
extern const char *_1_selinux_virtual_domain_context_path(void );
extern const char *_1_selinux_virtual_image_context_path(void );
extern const char *_1_selinux_x_context_path(void );
extern const char *_1_selinux_sepgsql_context_path(void );
extern const char *_1_selinux_contexts_path(void );
extern const char *_1_selinux_securetty_types_path(void );
extern const char *_1_selinux_booleans_path(void );
extern const char *_1_selinux_customizable_types_path(void );
extern const char *_1_selinux_users_path(void );
extern const char *_1_selinux_usersconf_path(void );
extern const char *_1_selinux_translations_path(void );
extern const char *_1_selinux_colors_path(void );
extern const char *_1_selinux_netfilter_context_path(void );
extern const char *_1_selinux_path(void );
extern int _1_selinux_check_passwd_access(_1_access_vector_t requested );
extern int _1_checkPasswdAccess(_1_access_vector_t requested );
extern int _1_selinux_check_securetty_context(_1_security_context_t tty_context );
void _1_set_selinuxmnt(char *mnt );
extern int _1_rpm_execcon(unsigned  int verified , const  char *filename , char *const argv[] , char *const envp[] );
extern int _1_is_context_customizable(_1_security_context_t scontext );
extern int _1_selinux_trans_to_raw_context(_1_security_context_t trans , _1_security_context_t *rawp );
extern int _1_selinux_raw_to_trans_context(_1_security_context_t raw , _1_security_context_t *transp );
extern int _1_selinux_raw_context_to_color(_1_security_context_t raw , char **color_str );
extern int _1_getseuserbyname(const  char *linuxuser , char **seuser , char **level );
extern int _1_getseuser(const  char *username , const  char *service , char **r_seuser , char **r_level );
extern int _1_selinux_file_context_cmp(const  _1_security_context_t a , const  _1_security_context_t b );
extern int _1_selinux_file_context_verify(const  char *path , mode_t mode );
extern int _1_selinux_lsetfilecon_default(const  char *path );
extern void _1_selinux_reset_config(void );
typedef struct   {
  void *ptr ;
}  _1_context_s_t;
typedef _1_context_s_t *_1_context_t;
extern _1_context_t _1_context_new(const  char * );
extern char *_1_context_str(_1_context_t );
extern void _1_context_free(_1_context_t );
extern const char *_1_context_type_get(_1_context_t );
extern const char *_1_context_range_get(_1_context_t );
extern const char *_1_context_role_get(_1_context_t );
extern const char *_1_context_user_get(_1_context_t );
extern int _1_context_type_set(_1_context_t , const  char * );
extern int _1_context_range_set(_1_context_t , const  char * );
extern int _1_context_role_set(_1_context_t , const  char * );
extern int _1_context_user_set(_1_context_t , const  char * );
enum  {
  _2___LC_CTYPE = 0,
  _2___LC_NUMERIC = 1,
  _2___LC_TIME = 2,
  _2___LC_COLLATE = 3,
  _2___LC_MONETARY = 4,
  _2___LC_MESSAGES = 5,
  _2___LC_ALL = 6,
  _2___LC_PAPER = 7,
  _2___LC_NAME = 8,
  _2___LC_ADDRESS = 9,
  _2___LC_TELEPHONE = 10,
  _2___LC_MEASUREMENT = 11,
  _2___LC_IDENTIFICATION = 12
} ;
struct  _2_lconv {
  char *decimal_point ;
  char *thousands_sep ;
  char *grouping ;
  char *int_curr_symbol ;
  char *currency_symbol ;
  char *mon_decimal_point ;
  char *mon_thousands_sep ;
  char *mon_grouping ;
  char *positive_sign ;
  char *negative_sign ;
  char int_frac_digits ;
  char frac_digits ;
  char p_cs_precedes ;
  char p_sep_by_space ;
  char n_cs_precedes ;
  char n_sep_by_space ;
  char p_sign_posn ;
  char n_sign_posn ;
  char int_p_cs_precedes ;
  char int_p_sep_by_space ;
  char int_n_cs_precedes ;
  char int_n_sep_by_space ;
  char int_p_sign_posn ;
  char int_n_sign_posn ;
}  ;
extern char *_2_setlocale(int __category , const  char *__locale ) __attribute__((__nothrow__));
extern struct  _2_lconv   *_2_localeconv(void ) __attribute__((__nothrow__));
extern __locale_t _2_newlocale(int __category_mask , const  char *__locale , __locale_t __base ) __attribute__((__nothrow__));
extern __locale_t _2_duplocale(__locale_t __dataset ) __attribute__((__nothrow__));
extern void _2_freelocale(__locale_t __dataset ) __attribute__((__nothrow__));
extern __locale_t _2_uselocale(__locale_t __dataset ) __attribute__((__nothrow__));
struct  passwd {
  char *pw_name ;
  char *pw_passwd ;
  __uid_t pw_uid ;
  __gid_t pw_gid ;
  char *pw_gecos ;
  char *pw_dir ;
  char *pw_shell ;
}  ;
extern void setpwent(void );
extern void endpwent(void );
extern struct  passwd   *getpwent(void );
extern struct  passwd   *fgetpwent(FILE *__stream );
extern int putpwent(const  struct  passwd   *__restrict __p , FILE *__restrict __f );
extern struct  passwd   *getpwuid(__uid_t __uid );
extern struct  passwd   *getpwnam(const  char *__name );
extern int getpwent_r(struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int getpwuid_r(__uid_t __uid , struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int getpwnam_r(const  char *__restrict __name , struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int fgetpwent_r(FILE *__restrict __stream , struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int getpw(__uid_t __uid , char *__buffer );
struct  group {
  char *gr_name ;
  char *gr_passwd ;
  __gid_t gr_gid ;
  char **gr_mem ;
}  ;
extern void setgrent(void );
extern void endgrent(void );
extern struct  group   *getgrent(void );
extern struct  group   *fgetgrent(FILE *__stream );
extern int putgrent(const  struct  group   *__restrict __p , FILE *__restrict __f );
extern struct  group   *getgrgid(__gid_t __gid );
extern struct  group   *getgrnam(const  char *__name );
extern int getgrent_r(struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int getgrgid_r(__gid_t __gid , struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int getgrnam_r(const  char *__restrict __name , struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int fgetgrent_r(FILE *__restrict __stream , struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int setgroups(size_t __n , const  __gid_t *__groups ) __attribute__((__nothrow__));
extern int getgrouplist(const  char *__user , __gid_t __group , __gid_t *__groups , int *__ngroups );
extern int initgroups(const  char *__user , __gid_t __group );
struct  _3_spwd {
  char *sp_namp ;
  char *sp_pwdp ;
  long  int sp_lstchg ;
  long  int sp_min ;
  long  int sp_max ;
  long  int sp_warn ;
  long  int sp_inact ;
  long  int sp_expire ;
  unsigned  long  int sp_flag ;
}  ;
extern void _3_setspent(void );
extern void _3_endspent(void );
extern struct  _3_spwd   *_3_getspent(void );
extern struct  _3_spwd   *_3_getspnam(const  char *__name );
extern struct  _3_spwd   *_3_sgetspent(const  char *__string );
extern struct  _3_spwd   *_3_fgetspent(FILE *__stream );
extern int _3_putspent(const  struct  _3_spwd   *__p , FILE *__stream );
extern int _3_getspent_r(struct  _3_spwd   *__result_buf , char *__buffer , size_t __buflen , struct  _3_spwd   **__result );
extern int _3_getspnam_r(const  char *__name , struct  _3_spwd   *__result_buf , char *__buffer , size_t __buflen , struct  _3_spwd   **__result );
extern int _3_sgetspent_r(const  char *__string , struct  _3_spwd   *__result_buf , char *__buffer , size_t __buflen , struct  _3_spwd   **__result );
extern int _3_fgetspent_r(FILE *__stream , struct  _3_spwd   *__result_buf , char *__buffer , size_t __buflen , struct  _3_spwd   **__result );
extern int _3_lckpwdf(void ) __attribute__((__nothrow__));
extern int _3_ulckpwdf(void ) __attribute__((__nothrow__));
extern in_addr_t inet_addr(const  char *__cp ) __attribute__((__nothrow__));
extern in_addr_t inet_lnaof(struct  in_addr   __in ) __attribute__((__nothrow__));
extern struct  in_addr   inet_makeaddr(in_addr_t __net , in_addr_t __host ) __attribute__((__nothrow__));
extern in_addr_t inet_netof(struct  in_addr   __in ) __attribute__((__nothrow__));
extern in_addr_t inet_network(const  char *__cp ) __attribute__((__nothrow__));
extern char *inet_ntoa(struct  in_addr   __in ) __attribute__((__nothrow__));
extern int inet_pton(int __af , const  char *__restrict __cp , void *__restrict __buf ) __attribute__((__nothrow__));
extern const char *inet_ntop(int __af , const  void *__restrict __cp , char *__restrict __buf , socklen_t __len ) __attribute__((__nothrow__));
extern int inet_aton(const  char *__cp , struct  in_addr   *__inp ) __attribute__((__nothrow__));
extern char *inet_neta(in_addr_t __net , char *__buf , size_t __len ) __attribute__((__nothrow__));
extern char *inet_net_ntop(int __af , const  void *__cp , int __bits , char *__buf , size_t __len ) __attribute__((__nothrow__));
extern int inet_net_pton(int __af , const  char *__cp , void *__buf , size_t __len ) __attribute__((__nothrow__));
extern unsigned int inet_nsap_addr(const  char *__cp , unsigned  char *__buf , int __len ) __attribute__((__nothrow__));
extern char *inet_nsap_ntoa(int __len , const  unsigned  char *__cp , char *__buf ) __attribute__((__nothrow__));
extern char **environ;
int klogctl(int type , char *b , int len );
char *dirname(char *path );
struct  sysinfo {
  long uptime ;
  unsigned  long loads[3] ;
  unsigned  long totalram ;
  unsigned  long freeram ;
  unsigned  long sharedram ;
  unsigned  long bufferram ;
  unsigned  long totalswap ;
  unsigned  long freeswap ;
  unsigned  short procs ;
  unsigned  short pad ;
  unsigned  long totalhigh ;
  unsigned  long freehigh ;
  unsigned  int mem_unit ;
  char _f[(20 - (2 * sizeof(long )) - sizeof(int ))] ;
}  ;
int sysinfo(struct  sysinfo   *info );
_Pragma("GCC visibility push(hidden)")
_Pragma("GCC visibility push(hidden)")
extern void _4_bb_internal_setpwent(void );
extern void _4_bb_internal_endpwent(void );
extern struct  passwd   *_4_bb_internal_getpwuid(uid_t __uid );
extern struct  passwd   *_4_bb_internal_getpwnam(const  char *__name );
extern int _4_bb_internal_getpwent_r(struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int _4_bb_internal_getpwuid_r(uid_t __uid , struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int _4_bb_internal_getpwnam_r(const  char *__restrict __name , struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
extern int _4_bb_internal_fgetpwent_r(FILE *__restrict __stream , struct  passwd   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  passwd   **__restrict __result );
_Pragma("GCC visibility pop")
_Pragma("GCC visibility push(hidden)")
extern void _4_bb_internal_setgrent(void );
extern void _4_bb_internal_endgrent(void );
extern struct  group   *_4_bb_internal_getgrgid(gid_t __gid );
extern struct  group   *_4_bb_internal_getgrnam(const  char *__name );
extern int _4_bb_internal_getgrent_r(struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int _4_bb_internal_getgrgid_r(gid_t __gid , struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int _4_bb_internal_getgrnam_r(const  char *__restrict __name , struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int _4_bb_internal_fgetgrent_r(FILE *__restrict __stream , struct  group   *__restrict __resultbuf , char *__restrict __buffer , size_t __buflen , struct  group   **__restrict __result );
extern int _4_bb_internal_getgrouplist(const  char *__user , gid_t __group , gid_t *__groups , int *__ngroups );
extern int _4_bb_internal_initgroups(const  char *__user , gid_t __group );
_Pragma("GCC visibility pop")
_Pragma("GCC visibility push(hidden)")
struct  _5_spwd {
  char *sp_namp ;
  char *sp_pwdp ;
  long sp_lstchg ;
  long sp_min ;
  long sp_max ;
  long sp_warn ;
  long sp_inact ;
  long sp_expire ;
  unsigned  long sp_flag ;
}  ;
extern int _5_bb_internal_getspnam_r(const  char *__name , struct  _5_spwd   *__result_buf , char *__buffer , size_t __buflen , struct  _5_spwd   **__result );
_Pragma("GCC visibility pop")
typedef unsigned long long _6_uoff_t;
typedef unsigned long _7_uoff_t;
extern int *const bb_errno;
uint64_t bb_bswap_64(uint64_t x );
unsigned long long monotonic_ns(void );
unsigned long long monotonic_us(void );
unsigned long long monotonic_ms(void );
unsigned monotonic_sec(void );
extern void chomp(char *s );
extern void trim(char *s );
extern char *skip_whitespace(const  char * );
extern char *skip_non_whitespace(const  char * );
extern char *skip_dev_pfx(const  char *tty_name );
extern char *strrstr(const  char *haystack , const  char *needle );
extern const char *bb_mode_string(mode_t mode );
extern int is_directory(const  char *name , int followLinks , struct  stat   *statBuf );
enum  {
  FILEUTILS_PRESERVE_STATUS = (1 << 0),
  FILEUTILS_DEREFERENCE = (1 << 1),
  FILEUTILS_RECUR = (1 << 2),
  FILEUTILS_FORCE = (1 << 3),
  FILEUTILS_INTERACTIVE = (1 << 4),
  FILEUTILS_MAKE_HARDLINK = (1 << 5),
  FILEUTILS_MAKE_SOFTLINK = (1 << 6),
  FILEUTILS_DEREF_SOFTLINK = (1 << 7),
  FILEUTILS_DEREFERENCE_L0 = (1 << 8),
  _1_FILEUTILS_PRESERVE_SECURITY_CONTEXT = (1 << 9),
  _1_FILEUTILS_SET_SECURITY_CONTEXT = (1 << 10)
} ;
extern int remove_file(const  char *path , int flags );
extern int copy_file(const  char *source , const  char *dest , int flags );
enum  {
  ACTION_RECURSE = (1 << 0),
  ACTION_FOLLOWLINKS = (1 << 1),
  ACTION_FOLLOWLINKS_L0 = (1 << 2),
  ACTION_DEPTHFIRST = (1 << 3),
  ACTION_QUIET = (1 << 5),
  ACTION_DANGLING_OK = (1 << 6)
} ;
typedef uint8_t recurse_flags_t;
extern int recursive_action(const  char *fileName , unsigned flags , int ( *fileAction)(const  char *fileName , struct  stat   *statbuf , void *userData , int depth ) , int ( *dirAction)(const  char *fileName , struct  stat   *statbuf , void *userData , int depth ) , void *userData , unsigned depth );
extern int device_open(const  char *device , int mode );
enum  {
  GETPTY_BUFSIZE = 16
} ;
extern int xgetpty(char *line );
extern int get_console_fd_or_die(void );
extern void console_make_active(int fd , const  int vt_num );
extern char *find_block_device(const  char *path );
extern off_t bb_copyfd_eof(int fd1 , int fd2 );
extern off_t bb_copyfd_size(int fd1 , int fd2 , off_t size );
extern void bb_copyfd_exact_size(int fd1 , int fd2 , off_t size );
extern void complain_copyfd_and_die(off_t sz ) __attribute__((__noreturn__));
extern char bb_process_escape_sequence(const  char **ptr );
char *strcpy_and_process_escape_sequences(char *dst , const  char *src );
extern char *bb_get_last_path_component_strip(char *path );
extern char *bb_get_last_path_component_nostrip(const  char *path );
int ndelay_on(int fd );
int ndelay_off(int fd );
int close_on_exec_on(int fd );
void xdup2(int , int );
void xmove_fd(int , int );
DIR *xopendir(const  char *path );
DIR *warn_opendir(const  char *path );
char *xmalloc_realpath(const  char *path ) __attribute__((malloc));
char *xmalloc_readlink(const  char *path ) __attribute__((malloc));
char *xmalloc_readlink_or_warn(const  char *path ) __attribute__((malloc));
char *xrealloc_getcwd_or_warn(char *cwd );
char *xmalloc_follow_symlinks(const  char *path ) __attribute__((malloc));
enum  {
  BB_FATAL_SIGS = ((int ) (0 + (1LL << 1) + (1LL << 2) + (1LL << 15) + (1LL << 13) + (1LL << 3) + (1LL << 6) + (1LL << 14) + (1LL << 26) + (1LL << 24) + (1LL << 25) + (1LL << 10) + (1LL << 12) + 0))
} ;
void bb_signals(int sigs , void ( *f)(int ) );
void bb_signals_recursive_norestart(int sigs , void ( *f)(int ) );
void signal_no_SA_RESTART_empty_mask(int sig , void ( *handler)(int ) );
void signal_SA_RESTART_empty_mask(int sig , void ( *handler)(int ) );
void wait_for_any_sig(void );
void kill_myself_with_sig(int sig ) __attribute__((__noreturn__));
void sig_block(int sig );
void sig_unblock(int sig );
int sigaction_set(int sig , const  struct  sigaction   *act );
int sigprocmask_allsigs(int how );
extern smallint bb_got_signal;
void record_signo(int signo );
void xsetgid(gid_t gid );
void xsetuid(uid_t uid );
void xchdir(const  char *path );
void xchroot(const  char *path );
void xsetenv(const  char *key , const  char *value );
void bb_unsetenv(const  char *key );
void bb_unsetenv_and_free(char *key );
void xunlink(const  char *pathname );
void xstat(const  char *pathname , struct  stat   *buf );
void xfstat(int fd , struct  stat   *buf , const  char *errmsg );
int xopen(const  char *pathname , int flags );
int xopen_nonblocking(const  char *pathname );
int xopen3(const  char *pathname , int flags , int mode );
int open_or_warn(const  char *pathname , int flags );
int open3_or_warn(const  char *pathname , int flags , int mode );
int open_or_warn_stdin(const  char *pathname );
int xopen_stdin(const  char *pathname );
void xrename(const  char *oldpath , const  char *newpath );
int rename_or_warn(const  char *oldpath , const  char *newpath );
off_t xlseek(int fd , off_t offset , int whence );
int xmkstemp(char *template );
off_t fdlength(int fd );
_6_uoff_t _6_get_volume_size_in_bytes(int fd , const  char *override , unsigned override_units , int extend );
_7_uoff_t _7_get_volume_size_in_bytes(int fd , const  char *override , unsigned override_units , int extend );
void xpipe(int filedes[2] );
struct  fd_pair {
  int rd ;
  int wr ;
}  ;
typedef int8_t socktype_t;
typedef int8_t family_t;
struct  BUG_too_small {
  char BUG_socktype_t_too_small[(((0 | SOCK_STREAM | SOCK_DGRAM | SOCK_RDM | SOCK_SEQPACKET | SOCK_RAW) <= 127) ? 1 : (- 1))] ;
  char BUG_family_t_too_small[(((0 | 0 | 2 | 10 | 1 | 17 | 16) <= 127) ? 1 : (- 1))] ;
}  ;
void parse_datestr(const  char *date_str , struct  tm   *ptm );
time_t validate_tm_time(const  char *date_str , struct  tm   *ptm );
int xsocket(int domain , int type , int protocol );
void xbind(int sockfd , struct  sockaddr   *my_addr , socklen_t addrlen );
void xlisten(int s , int backlog );
void xconnect(int s , const  struct  sockaddr   *s_addr , socklen_t addrlen );
ssize_t xsendto(int s , const  void *buf , size_t len , const  struct  sockaddr   *to , socklen_t tolen );
void setsockopt_reuseaddr(int fd );
int setsockopt_broadcast(int fd );
int setsockopt_bindtodevice(int fd , const  char *iface );
unsigned bb_lookup_port(const  char *port , const  char *protocol , unsigned default_port );
typedef struct  len_and_sockaddr {
  socklen_t len ;
  union   {
    struct  sockaddr   sa ;
    struct  sockaddr_in   sin ;
    struct  sockaddr_in6   _8_sin6 ;
  }  u ;
}  len_and_sockaddr;
enum  {
  LSA_LEN_SIZE = __builtin_offsetof(len_and_sockaddr , u),
  LSA_SIZEOF_SA = sizeof(union   {
    struct  sockaddr   sa ;
    struct  sockaddr_in   sin ;
    struct  sockaddr_in6   _8_sin6 ;
  }  )
} ;
int _8_xsocket_type(len_and_sockaddr **lsap , int af , int sock_type );
int _9_xsocket_type(len_and_sockaddr **lsap , int sock_type );
int xsocket_stream(len_and_sockaddr **lsap );
int create_and_bind_stream_or_die(const  char *bindaddr , int port );
int create_and_bind_dgram_or_die(const  char *bindaddr , int port );
int create_and_connect_stream_or_die(const  char *peer , int port );
int xconnect_stream(const  len_and_sockaddr *lsa );
len_and_sockaddr *get_sock_lsa(int fd ) __attribute__((malloc));
len_and_sockaddr *get_peer_lsa(int fd ) __attribute__((malloc));
len_and_sockaddr *host2sockaddr(const  char *host , int port ) __attribute__((malloc));
len_and_sockaddr *xhost2sockaddr(const  char *host , int port ) __attribute__((malloc));
len_and_sockaddr *xdotted2sockaddr(const  char *host , int port ) __attribute__((malloc));
len_and_sockaddr *_8_host_and_af2sockaddr(const  char *host , int port , sa_family_t af ) __attribute__((malloc));
len_and_sockaddr *_8_xhost_and_af2sockaddr(const  char *host , int port , sa_family_t af ) __attribute__((malloc));
void set_nport(len_and_sockaddr *lsa , unsigned port );
int get_nport(const  struct  sockaddr   *sa );
char *xmalloc_sockaddr2host(const  struct  sockaddr   *sa ) __attribute__((malloc));
char *xmalloc_sockaddr2host_noport(const  struct  sockaddr   *sa ) __attribute__((malloc));
char *xmalloc_sockaddr2hostonly_noport(const  struct  sockaddr   *sa ) __attribute__((malloc));
char *xmalloc_sockaddr2dotted(const  struct  sockaddr   *sa ) __attribute__((malloc));
char *xmalloc_sockaddr2dotted_noport(const  struct  sockaddr   *sa ) __attribute__((malloc));
struct  hostent   *xgethostbyname(const  char *name );
void socket_want_pktinfo(int fd );
ssize_t send_to_from(int fd , void *buf , size_t len , int flags , const  struct  sockaddr   *to , const  struct  sockaddr   *from , socklen_t tolen );
ssize_t recv_from_to(int fd , void *buf , size_t len , int flags , struct  sockaddr   *from , struct  sockaddr   *to , socklen_t sa_size );
char *xstrdup(const  char *s ) __attribute__((malloc));
char *xstrndup(const  char *s , int n ) __attribute__((malloc));
void overlapping_strcpy(char *dst , const  char *src );
char *safe_strncpy(char *dst , const  char *src , size_t size );
char *strncpy_IFNAMSIZ(char *dst , const  char *src );
int bb_putchar(int ch );
int bb_putchar_stderr(char ch );
char *xasprintf(const  char *format , ...) __attribute__((format (printf, 1, 2))) __attribute__((malloc));
typedef struct  uni_stat_t {
  unsigned byte_count ;
  unsigned unicode_count ;
  unsigned unicode_width ;
}  uni_stat_t;
const char *printable_string(uni_stat_t *stats , const  char *str );
enum  {
  PRINTABLE_META = 0x100
} ;
void fputc_printable(int ch , FILE *file );
void *malloc_or_warn(size_t size ) __attribute__((malloc));
void *xmalloc(size_t size ) __attribute__((malloc));
void *xzalloc(size_t size ) __attribute__((malloc));
void *xrealloc(void *old , size_t size );
void *xrealloc_vector_helper(void *vector , unsigned sizeof_and_shift , int idx );
extern ssize_t safe_read(int fd , void *buf , size_t count );
extern ssize_t nonblock_safe_read(int fd , void *buf , size_t count );
extern ssize_t full_read(int fd , void *buf , size_t count );
extern void xread(int fd , void *buf , size_t count );
extern unsigned char xread_char(int fd );
extern ssize_t read_close(int fd , void *buf , size_t maxsz );
extern ssize_t open_read_close(const  char *filename , void *buf , size_t maxsz );
extern char *xmalloc_reads(int fd , char *pfx , size_t *maxsz_p );
extern void *xmalloc_read(int fd , size_t *maxsz_p ) __attribute__((malloc));
extern void *xmalloc_open_read_close(const  char *filename , size_t *maxsz_p ) __attribute__((malloc));
extern void _10_setup_unzip_on_fd(int fd );
extern int open_zipped(const  char *fname );
extern void *xmalloc_open_zipped_read_close(const  char *fname , size_t *maxsz_p ) __attribute__((malloc));
extern void *xmalloc_xopen_read_close(const  char *filename , size_t *maxsz_p ) __attribute__((malloc));
extern ssize_t safe_write(int fd , const  void *buf , size_t count );
extern ssize_t full_write(int fd , const  void *buf , size_t count );
extern void xwrite(int fd , const  void *buf , size_t count );
extern void xwrite_str(int fd , const  char *str );
extern ssize_t full_write1_str(const  char *str );
extern ssize_t full_write2_str(const  char *str );
extern void xopen_xwrite_close(const  char *file , const  char *str );
extern void xclose(int fd );
extern void xprint_and_close_file(FILE *file );
extern char *bb_get_chunk_from_file(FILE *file , int *end );
extern char *bb_get_chunk_with_continuation(FILE *file , int *end , int *lineno );
extern char *xmalloc_fgets_str(FILE *file , const  char *terminating_string ) __attribute__((malloc));
extern char *xmalloc_fgets_str_len(FILE *file , const  char *terminating_string , size_t *maxsz_p ) __attribute__((malloc));
extern char *xmalloc_fgetline_str(FILE *file , const  char *terminating_string ) __attribute__((malloc));
extern char *xmalloc_fgets(FILE *file ) __attribute__((malloc));
extern char *xmalloc_fgetline(FILE *file ) __attribute__((malloc));
void die_if_ferror(FILE *file , const  char *msg );
void die_if_ferror_stdout(void );
int fflush_all(void );
void fflush_stdout_and_exit(int retval ) __attribute__((__noreturn__));
int fclose_if_not_stdin(FILE *file );
FILE *xfopen(const  char *filename , const  char *mode );
FILE *fopen_or_warn(const  char *filename , const  char *mode );
FILE *xfopen_stdin(const  char *filename );
FILE *fopen_or_warn_stdin(const  char *filename );
FILE *fopen_for_read(const  char *path );
FILE *xfopen_for_read(const  char *path );
FILE *fopen_for_write(const  char *path );
FILE *xfopen_for_write(const  char *path );
FILE *xfdopen_for_read(int fd );
FILE *xfdopen_for_write(int fd );
int bb_pstrcmp(const  void *a , const  void *b );
void qsort_string_vector(char **sv , unsigned count );
int safe_poll(struct  pollfd   *ufds , nfds_t nfds , int timeout_ms );
char *safe_gethostname(void );
char *safe_getdomainname(void );
char *str_tolower(char *str );
char *utoa(unsigned n );
char *itoa(int n );
char *utoa_to_buf(unsigned n , char *buf , unsigned buflen );
char *itoa_to_buf(int n , char *buf , unsigned buflen );
void smart_ulltoa4(unsigned  long  long ul , char buf[4] , const  char *scale );
void smart_ulltoa5(unsigned  long  long ul , char buf[5] , const  char *scale );
const char *make_human_readable_str(unsigned  long  long size , unsigned  long block_size , unsigned  long display_unit );
char *bin2hex(char *buf , const  char *cp , int count );
char *hex2bin(char *dst , const  char *str , int count );
void generate_uuid(uint8_t *buf );
struct  suffix_mult {
  char suffix[4] ;
  unsigned mult ;
}  ;
_Pragma("GCC visibility push(hidden)")
unsigned long long xstrtoull_range_sfx(const  char *str , int b , unsigned  long  long l , unsigned  long  long u , const  struct  suffix_mult   *sfx );
unsigned long long xstrtoull_range(const  char *str , int b , unsigned  long  long l , unsigned  long  long u );
unsigned long long xstrtoull_sfx(const  char *str , int b , const  struct  suffix_mult   *sfx );
unsigned long long xstrtoull(const  char *str , int b );
unsigned long long xatoull_range_sfx(const  char *str , unsigned  long  long l , unsigned  long  long u , const  struct  suffix_mult   *sfx );
unsigned long long xatoull_range(const  char *str , unsigned  long  long l , unsigned  long  long u );
unsigned long long xatoull_sfx(const  char *str , const  struct  suffix_mult   *sfx );
unsigned long long xatoull(const  char *str );
long long xstrtoll_range_sfx(const  char *str , int b , long  long l , long  long u , const  struct  suffix_mult   *sfx );
long long xstrtoll_range(const  char *str , int b , long  long l , long  long u );
long long xstrtoll(const  char *str , int b );
long long xatoll_range_sfx(const  char *str , long  long l , long  long u , const  struct  suffix_mult   *sfx );
long long xatoll_range(const  char *str , long  long l , long  long u );
long long xatoll_sfx(const  char *str , const  struct  suffix_mult   *sfx );
long long xatoll(const  char *str );
static  inline  unsigned  long xstrtoul_range_sfx(const  char *str , int b , unsigned  long l , unsigned  long u , const  struct  suffix_mult   *sfx )  {
  return xstrtoull_range_sfx(str, b, l, u, sfx);
}
static  inline  unsigned  long xstrtoul_range(const  char *str , int b , unsigned  long l , unsigned  long u )  {
  return xstrtoull_range(str, b, l, u);
}
static  inline  unsigned  long xstrtoul_sfx(const  char *str , int b , const  struct  suffix_mult   *sfx )  {
  return xstrtoull_sfx(str, b, sfx);
}
static  inline  unsigned  long xstrtoul(const  char *str , int b )  {
  return xstrtoull(str, b);
}
static  inline  unsigned  long xatoul_range_sfx(const  char *str , unsigned  long l , unsigned  long u , const  struct  suffix_mult   *sfx )  {
  return xatoull_range_sfx(str, l, u, sfx);
}
static  inline  unsigned  long xatoul_range(const  char *str , unsigned  long l , unsigned  long u )  {
  return xatoull_range(str, l, u);
}
static  inline  unsigned  long xatoul_sfx(const  char *str , const  struct  suffix_mult   *sfx )  {
  return xatoull_sfx(str, sfx);
}
static  inline  unsigned  long xatoul(const  char *str )  {
  return xatoull(str);
}
static  inline  long xstrtol_range_sfx(const  char *str , int b , long l , long u , const  struct  suffix_mult   *sfx )  {
  return xstrtoll_range_sfx(str, b, l, u, sfx);
}
static  inline  long xstrtol_range(const  char *str , int b , long l , long u )  {
  return xstrtoll_range(str, b, l, u);
}
static  inline  long xstrtol(const  char *str , int b )  {
  return xstrtoll(str, b);
}
static  inline  long xatol_range_sfx(const  char *str , long l , long u , const  struct  suffix_mult   *sfx )  {
  return xatoll_range_sfx(str, l, u, sfx);
}
static  inline  long xatol_range(const  char *str , long l , long u )  {
  return xatoll_range(str, l, u);
}
static  inline  long xatol_sfx(const  char *str , const  struct  suffix_mult   *sfx )  {
  return xatoll_sfx(str, sfx);
}
static  inline  long xatol(const  char *str )  {
  return xatoll(str);
}
unsigned int xstrtou_range_sfx(const  char *str , int b , unsigned  int l , unsigned  int u , const  struct  suffix_mult   *sfx );
unsigned int xstrtou_range(const  char *str , int b , unsigned  int l , unsigned  int u );
unsigned int xstrtou_sfx(const  char *str , int b , const  struct  suffix_mult   *sfx );
unsigned int xstrtou(const  char *str , int b );
unsigned int xatou_range_sfx(const  char *str , unsigned  int l , unsigned  int u , const  struct  suffix_mult   *sfx );
unsigned int xatou_range(const  char *str , unsigned  int l , unsigned  int u );
unsigned int xatou_sfx(const  char *str , const  struct  suffix_mult   *sfx );
unsigned int xatou(const  char *str );
int xstrtoi_range_sfx(const  char *str , int b , int l , int u , const  struct  suffix_mult   *sfx );
int xstrtoi_range(const  char *str , int b , int l , int u );
int xstrtoi(const  char *str , int b );
int xatoi_range_sfx(const  char *str , int l , int u , const  struct  suffix_mult   *sfx );
int xatoi_range(const  char *str , int l , int u );
int xatoi_sfx(const  char *str , const  struct  suffix_mult   *sfx );
int xatoi(const  char *str );
uint32_t BUG_xatou32_unimplemented(void );
static  inline  uint32_t xatou32(const  char *numstr )  {
  if ((((2147483647 * 2U) + 1U) == 0xffffffff)) {
    return xatou(numstr);
  }  
  if ((((9223372036854775807L * 2UL) + 1UL) == 0xffffffff)) {
    return xatoul(numstr);
  }  
  return BUG_xatou32_unimplemented();
}
unsigned long long bb_strtoull(const  char *arg , char **endp , int base );
long long bb_strtoll(const  char *arg , char **endp , int base );
static  inline  unsigned  long bb_strtoul(const  char *arg , char **endp , int base )  {
  return bb_strtoull(arg, endp, base);
}
static  inline  long bb_strtol(const  char *arg , char **endp , int base )  {
  return bb_strtoll(arg, endp, base);
}
unsigned bb_strtou(const  char *arg , char **endp , int base );
int bb_strtoi(const  char *arg , char **endp , int base );
uint32_t BUG_bb_strtou32_unimplemented(void );
static  inline  uint32_t bb_strtou32(const  char *arg , char **endp , int base )  {
  if ((sizeof(uint32_t ) == sizeof(unsigned ))) {
    return bb_strtou(arg, endp, base);
  }  
  if ((sizeof(uint32_t ) == sizeof(unsigned  long ))) {
    return bb_strtoul(arg, endp, base);
  }  
  return BUG_bb_strtou32_unimplemented();
}
double bb_strtod(const  char *arg , char **endp );
_Pragma("GCC visibility pop")
int xatoi_positive(const  char *numstr );
uint16_t xatou16(const  char *numstr );
long xuname2uid(const  char *name );
long xgroup2gid(const  char *name );
unsigned long get_ug_id(const  char *s , long ( *xname2id)(const  char * ) );
struct  bb_uidgid_t {
  uid_t uid ;
  gid_t gid ;
}  ;
int get_uidgid(struct  bb_uidgid_t   * , const  char * , int numeric_ok );
void xget_uidgid(struct  bb_uidgid_t   * , const  char * );
void parse_chown_usergroup_or_die(struct  bb_uidgid_t   *u , char *user_group );
struct  passwd   *xgetpwnam(const  char *name );
struct  group   *xgetgrnam(const  char *name );
struct  passwd   *xgetpwuid(uid_t uid );
struct  group   *xgetgrgid(gid_t gid );
char *xuid2uname(uid_t uid );
char *xgid2group(gid_t gid );
char *uid2uname(uid_t uid );
char *gid2group(gid_t gid );
char *uid2uname_utoa(long uid );
char *gid2group_utoa(long gid );
const char *get_cached_username(uid_t uid );
const char *get_cached_groupname(gid_t gid );
void clear_username_cache(void );
enum  {
  USERNAME_MAX_SIZE = (16 - sizeof(int ))
} ;
void _11_die_if_bad_username(const  char *name );
void write_new_utmp(pid_t pid , int new_type , const  char *tty_name , const  char *username , const  char *hostname );
void update_utmp(pid_t pid , int new_type , const  char *tty_name , const  char *username , const  char *hostname );
int execable_file(const  char *name );
char *find_execable(const  char *filename , char **PATHp );
int exists_execable(const  char *filename );
int _12_bb_execvp(const  char *file , char *const argv[] );
int BB_EXECVP_or_die(char **argv ) __attribute__((__noreturn__));
pid_t _13_xfork(void );
pid_t spawn(char **argv );
pid_t xspawn(char **argv );
pid_t safe_waitpid(pid_t pid , int *wstat , int options );
pid_t wait_any_nohang(int *wstat );
int wait4pid(pid_t pid );
int spawn_and_wait(char **argv );
struct  nofork_save_area {
  jmp_buf die_jmp ;
  const  char *applet_name ;
  uint32_t option_mask32 ;
  int die_sleep ;
  uint8_t xfunc_error_retval ;
  smallint saved ;
}  ;
void save_nofork_data(struct  nofork_save_area   *save );
void restore_nofork_data(struct  nofork_save_area   *save );
int run_nofork_applet(int applet_no , char **argv );
int run_nofork_applet_prime(struct  nofork_save_area   *old , int applet_no , char **argv );
enum  {
  DAEMON_CHDIR_ROOT = 1,
  DAEMON_DEVNULL_STDIO = 2,
  DAEMON_CLOSE_EXTRA_FDS = 4,
  DAEMON_ONLY_SANITIZE = 8
} ;
enum  {
  _13_re_execed = 0
} ;
extern _Bool _14_re_execed;
void _14_re_exec(char **argv ) __attribute__((__noreturn__));
pid_t _14_fork_or_rexec(char **argv );
int _14_BUG_fork_is_unavailable_on_nommu(void );
int _14_BUG_daemon_is_unavailable_on_nommu(void );
void _14_BUG_bb_daemonize_is_unavailable_on_nommu(void );
void _14_bb_daemonize_or_rexec(int flags , char **argv );
void _13_bb_daemonize_or_rexec(int flags );
void bb_sanitize_stdio(void );
int sanitize_env_if_suid(void );
char *single_argv(char **argv );
extern const char *const bb_argv_dash[];
extern const char *opt_complementary;
extern const char *_15_applet_long_options;
extern uint32_t option_mask32;
extern uint32_t getopt32(char **argv , const  char *applet_opts , ...);
typedef struct  llist_t {
  char *data ;
  struct  llist_t   *link ;
}  llist_t;
void llist_add_to(llist_t **old_head , void *data );
void llist_add_to_end(llist_t **list_head , void *data );
void *llist_pop(llist_t **elm );
void llist_unlink(llist_t **head , llist_t *elm );
void llist_free(llist_t *elm , void ( *freeit)(void *data ) );
llist_t *llist_rev(llist_t *list );
llist_t *llist_find_str(llist_t *first , const  char *str );
extern smallint _16_wrote_pidfile;
void _16_write_pidfile(const  char *path );
enum  {
  _17_wrote_pidfile = 0
} ;
enum  {
  LOGMODE_NONE = 0,
  LOGMODE_STDIO = (1 << 0),
  LOGMODE_SYSLOG = (((id2i.config_feature_syslog ) ) ? ((1 << 1) * 1) : ((1 << 1) * 0)),
  LOGMODE_BOTH = (LOGMODE_SYSLOG + LOGMODE_STDIO)
} ;
extern const char *msg_eol;
extern smallint logmode;
extern int die_sleep;
extern uint8_t xfunc_error_retval;
extern jmp_buf die_jmp;
extern void xfunc_die(void ) __attribute__((__noreturn__));
extern void bb_show_usage(void ) __attribute__((__noreturn__));
extern void bb_error_msg(const  char *s , ...) __attribute__((format (printf, 1, 2)));
extern void bb_error_msg_and_die(const  char *s , ...) __attribute__((noreturn, format (printf, 1, 2)));
extern void bb_perror_msg(const  char *s , ...) __attribute__((format (printf, 1, 2)));
extern void bb_simple_perror_msg(const  char *s );
extern void bb_perror_msg_and_die(const  char *s , ...) __attribute__((noreturn, format (printf, 1, 2)));
extern void bb_simple_perror_msg_and_die(const  char *s ) __attribute__((__noreturn__));
extern void bb_herror_msg(const  char *s , ...) __attribute__((format (printf, 1, 2)));
extern void bb_herror_msg_and_die(const  char *s , ...) __attribute__((noreturn, format (printf, 1, 2)));
extern void bb_perror_nomsg_and_die(void ) __attribute__((__noreturn__));
extern void bb_perror_nomsg(void );
extern void bb_info_msg(const  char *s , ...) __attribute__((format (printf, 1, 2)));
extern void bb_verror_msg(const  char *s , va_list p , const  char *strerr );
int bb_cat(char **argv );
int _18_echo_main(int argc , char **argv );
int _19_echo_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _20_printf_main(int argc , char **argv );
int _21_printf_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _22_test_main(int argc , char **argv );
int _23_test_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _24_kill_main(int argc , char **argv );
int _25_kill_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _26_chown_main(int argc , char **argv );
int _27_chown_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _28_ls_main(int argc , char **argv );
int _29_ls_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _30_gunzip_main(int argc , char **argv );
int _31_gunzip_main(int argc , char **argv ) __attribute__((visibility ("default")));
int _30_bunzip2_main(int argc , char **argv );
int _31_bunzip2_main(int argc , char **argv ) __attribute__((visibility ("default")));
void _32_bb_displayroutes(int noresolve , int netstatfmt );
int create_icmp_socket(void );
int create_icmp6_socket(void );
struct  aftype {
  const  char *name ;
  const  char *title ;
  int af ;
  int alen ;
  char *( *print)(unsigned  char * ) ;
  const  char *( *sprint)(struct  sockaddr   * , int numeric ) ;
  int ( *input)(const  char *bufp , struct  sockaddr   * ) ;
  void ( *herror)(char *text ) ;
  int ( *rprint)(int options ) ;
  int ( *rinput)(int typ , int ext , char **argv ) ;
  int ( *getmask)(char *src , struct  sockaddr   *mask , char *name ) ;
}  ;
struct  hwtype {
  const  char *name ;
  const  char *title ;
  int type ;
  int alen ;
  char *( *print)(unsigned  char * ) ;
  int ( *input)(const  char * , struct  sockaddr   * ) ;
  int ( *activate)(int fd ) ;
  int suppress_null_addr ;
}  ;
extern smallint interface_opt_a;
int display_interfaces(char *ifname );
int _33_in_ib(const  char *bufp , struct  sockaddr   *sap );
const struct  aftype   *get_aftype(const  char *name );
const struct  hwtype   *get_hwtype(const  char *name );
const struct  hwtype   *get_hwntype(int type );
extern int find_applet_by_name(const  char *name );
extern void run_applet_and_exit(const  char *name , char **argv );
extern void run_applet_no_and_exit(int a , char **argv ) __attribute__((__noreturn__));
extern int match_fstype(const  struct  mntent   *mt , const  char *fstypes );
extern struct  mntent   *find_mount_point(const  char *name , int subdir_too );
extern void erase_mtab(const  char *name );
extern unsigned int tty_baud_to_value(speed_t speed );
extern speed_t tty_value_to_baud(unsigned  int value );
extern void _34_bb_warn_ignoring_args(char *arg );
extern int get_linux_version_code(void );
extern char *query_loop(const  char *device );
extern int del_loop(const  char *device );
extern int set_loop(char **devname , const  char *file , unsigned  long  long offset );
char *bb_ask_stdin(const  char *prompt );
char *bb_ask(const  int fd , int timeout , const  char *prompt );
int bb_ask_confirmation(void );
int bb_parse_mode(const  char *s , mode_t *theMode );
enum  {
  PARSE_COLLAPSE = 0x00010000,
  PARSE_TRIM = 0x00020000,
  PARSE_GREEDY = 0x00040000,
  PARSE_MIN_DIE = 0x00100000,
  PARSE_KEEP_COPY = (((id2i.config_feature_crond_d ) ) ? (0x00200000 * 1) : (0x00200000 * 0)),
  PARSE_NORMAL = (PARSE_COLLAPSE | PARSE_TRIM | PARSE_GREEDY)
} ;
typedef struct  parser_t {
  FILE *fp ;
  char *line ;
  char *data ;
  int lineno ;
}  parser_t;
parser_t *config_open(const  char *filename );
parser_t *config_open2(const  char *filename , FILE *( *fopen_func)(const  char *path ) );
int config_read(parser_t *parser , char **tokens , unsigned flags , const  char *delims );
void config_close(parser_t *parser );
char *concat_path_file(const  char *path , const  char *filename );
char *concat_subpath_file(const  char *path , const  char *filename );
const char *bb_basename(const  char *name );
char *last_char_is(const  char *s , int c );
int bb_make_directory(char *path , long mode , int flags );
int get_signum(const  char *name );
const char *get_signame(int number );
void print_signames(void );
char *bb_simplify_path(const  char *path );
char *bb_simplify_abs_path_inplace(char *path );
extern void bb_do_delay(int seconds );
extern void change_identity(const  struct  passwd   *pw );
extern void run_shell(const  char *shell , int loginshell , const  char *command , const  char **additional_args ) __attribute__((__noreturn__));
extern void _1_renew_current_security_context(void );
extern void _1_set_current_security_context(_1_security_context_t sid );
extern _1_context_t _1_set_security_context_component(_1_security_context_t cur_context , char *user , char *role , char *type , char *range );
extern void _1_setfscreatecon_or_die(_1_security_context_t scontext );
extern void _1_selinux_preserve_fcontext(int fdesc );
extern void selinux_or_die(void );
extern void setup_environment(const  char *shell , int flags , const  struct  passwd   *pw );
extern int correct_password(const  struct  passwd   *pw );
extern char *_35_pw_encrypt(const  char *clear , const  char *salt , int cleanup );
extern char *_36_pw_encrypt(const  char *clear , const  char *salt );
extern int obscure(const  char *old , const  char *newval , const  struct  passwd   *pwdp );
extern int crypt_make_salt(char *p , int cnt , int rnd );
extern int _37_update_passwd(const  char *filename , const  char *username , const  char *data , const  char *member );
extern int _38_update_passwd(const  char *filename , const  char *username , const  char *data );
int index_in_str_array(const  char *const string_array[] , const  char *key );
int index_in_strings(const  char *strings , const  char *key );
int index_in_substr_array(const  char *const string_array[] , const  char *key );
int index_in_substrings(const  char *strings , const  char *key );
const char *nth_string(const  char *strings , int n );
extern void print_login_issue(const  char *issue_file , const  char *tty );
extern void print_login_prompt(void );
char *xmalloc_ttyname(int fd ) __attribute__((malloc));
int get_terminal_width_height(int fd , unsigned *width , unsigned *height );
int tcsetattr_stdin_TCSANOW(const  struct  termios   *tp );
int ioctl_or_perror(int fd , unsigned request , void *argp , const  char *fmt , ...) __attribute__((format (printf, 4, 5)));
int ioctl_or_perror_and_die(int fd , unsigned request , void *argp , const  char *fmt , ...) __attribute__((format (printf, 4, 5)));
int _39_bb_ioctl_or_warn(int fd , unsigned request , void *argp , const  char *ioctl_name );
int _39_bb_xioctl(int fd , unsigned request , void *argp , const  char *ioctl_name );
int _40_bb_ioctl_or_warn(int fd , unsigned request , void *argp );
int _40_bb_xioctl(int fd , unsigned request , void *argp );
char *is_in_ino_dev_hashtable(const  struct  stat   *statbuf );
void add_to_ino_dev_hashtable(const  struct  stat   *statbuf , const  char *name );
void reset_ino_dev_hashtable(void );
unsigned long long bb_makedev(unsigned  int major , unsigned  int minor );
enum  {
  KEYCODE_UP = (- 2),
  KEYCODE_DOWN = (- 3),
  KEYCODE_RIGHT = (- 4),
  KEYCODE_LEFT = (- 5),
  KEYCODE_HOME = (- 6),
  KEYCODE_END = (- 7),
  KEYCODE_INSERT = (- 8),
  KEYCODE_DELETE = (- 9),
  KEYCODE_PAGEUP = (- 10),
  KEYCODE_PAGEDOWN = (- 11),
  KEYCODE_CTRL_UP = (KEYCODE_UP & (~ 0x40)),
  KEYCODE_CTRL_DOWN = (KEYCODE_DOWN & (~ 0x40)),
  KEYCODE_CTRL_RIGHT = (KEYCODE_RIGHT & (~ 0x40)),
  KEYCODE_CTRL_LEFT = (KEYCODE_LEFT & (~ 0x40)),
  KEYCODE_CURSOR_POS = (- 0x100),
  KEYCODE_BUFFER_SIZE = 16
} ;
int64_t read_key(int fd , char *buffer , int timeout );
void read_key_ungets(char *buffer , const  char *str , unsigned len );
typedef struct  line_input_t {
  int flags ;
  const  char *path_lookup ;
  int cnt_history ;
  int cur_history ;
  unsigned _41_cnt_history_in_file ;
  const  char *_41_hist_file ;
  char *history[((255 + 0) + 1)] ;
}  line_input_t;
enum  {
  DO_HISTORY = (1 * ((255 + 0) > 0)),
  SAVE_HISTORY = (((id2i.config_feature_editing_savehistory ) ) ? (2 * ((255 + 0) > 0) * 1) : (2 * ((255 + 0) > 0) * 0)),
  TAB_COMPLETION = (((id2i.config_feature_tab_completion ) ) ? (4 * 1) : (4 * 0)),
  USERNAME_COMPLETION = (((id2i.config_feature_username_completion ) ) ? (8 * 1) : (8 * 0)),
  VI_MODE = (((id2i.config_feature_editing_vi ) ) ? (0x10 * 1) : (0x10 * 0)),
  WITH_PATH_LOOKUP = 0x20,
  FOR_SHELL = (DO_HISTORY | SAVE_HISTORY | TAB_COMPLETION | USERNAME_COMPLETION)
} ;
line_input_t *new_line_input_t(int flags );
int read_line_input(const  char *prompt , char *command , int maxsize , line_input_t *state );
enum  {
  COMM_LEN = 16
} ;
struct  smaprec {
  unsigned  long mapped_rw ;
  unsigned  long mapped_ro ;
  unsigned  long shared_clean ;
  unsigned  long shared_dirty ;
  unsigned  long private_clean ;
  unsigned  long private_dirty ;
  unsigned  long stack ;
  unsigned  long smap_pss , smap_swap ;
  unsigned  long smap_size ;
  unsigned  long smap_start ;
  char smap_mode[5] ;
  char *smap_name ;
}  ;
int _42_procps_read_smaps(pid_t pid , struct  smaprec   *total , void ( *cb)(struct  smaprec   * , void * ) , void *data );
int _43_procps_read_smaps(pid_t pid , struct  smaprec   *total );
typedef struct  procps_status_t {
  DIR *dir ;
  DIR *_44_task_dir ;
  uint8_t shift_pages_to_bytes ;
  uint8_t shift_pages_to_kb ;
  uint16_t argv_len ;
  char *argv0 ;
  char *exe ;
  char *_1_context ;
  unsigned  long vsz , rss ;
  unsigned  long stime , utime ;
  unsigned  long start_time ;
  unsigned pid ;
  unsigned ppid ;
  unsigned pgid ;
  unsigned sid ;
  unsigned uid ;
  unsigned gid ;
  unsigned _45_ruid ;
  unsigned _45_rgid ;
  int _45_niceness ;
  unsigned tty_major , tty_minor ;
  struct  smaprec   _46_smaps ;
  char state[4] ;
  char comm[COMM_LEN] ;
  int _47_last_seen_on_cpu ;
}  procps_status_t;
enum  {
  PSSCAN_PID = (1 << 0),
  PSSCAN_PPID = (1 << 1),
  PSSCAN_PGID = (1 << 2),
  PSSCAN_SID = (1 << 3),
  PSSCAN_UIDGID = (1 << 4),
  PSSCAN_COMM = (1 << 5),
  PSSCAN_ARGV0 = (1 << 7),
  PSSCAN_EXE = (1 << 8),
  PSSCAN_STATE = (1 << 9),
  PSSCAN_VSZ = (1 << 10),
  PSSCAN_RSS = (1 << 11),
  PSSCAN_STIME = (1 << 12),
  PSSCAN_UTIME = (1 << 13),
  PSSCAN_TTY = (1 << 14),
  PSSCAN_SMAPS = (((id2i.config_feature_topmem ) ) ? ((1 << 15) * 1) : ((1 << 15) * 0)),
  PSSCAN_ARGVN = ((((! id2i.config_killall) && (! id2i.config_pgrep) && (! id2i.config_pidof) && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 0 || 0 || 0 || 0)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && (! id2i.config_pidof) && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 0 || 0 || 0 || 1)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && id2i.config_pidof && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 0 || 0 || 1 || 0)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && id2i.config_pidof && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 0 || 0 || 1 || 1)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && (! id2i.config_pidof) && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 0 || 1 || 0 || 0)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && (! id2i.config_pidof) && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 0 || 1 || 0 || 1)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && id2i.config_pidof && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 0 || 1 || 1 || 0)) : ((((! id2i.config_killall) && (! id2i.config_pgrep) && id2i.config_pidof && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 0 || 1 || 1 || 1)) : ((((! id2i.config_killall) && id2i.config_pgrep && (! id2i.config_pidof) && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 1 || 0 || 0 || 0)) : ((((! id2i.config_killall) && id2i.config_pgrep && (! id2i.config_pidof) && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 1 || 0 || 0 || 1)) : ((((! id2i.config_killall) && id2i.config_pgrep && id2i.config_pidof && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 1 || 0 || 1 || 0)) : ((((! id2i.config_killall) && id2i.config_pgrep && id2i.config_pidof && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 1 || 0 || 1 || 1)) : ((((! id2i.config_killall) && id2i.config_pgrep && (! id2i.config_pidof) && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 1 || 1 || 0 || 0)) : ((((! id2i.config_killall) && id2i.config_pgrep && (! id2i.config_pidof) && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 1 || 1 || 0 || 1)) : ((((! id2i.config_killall) && id2i.config_pgrep && id2i.config_pidof && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (0 || 1 || 1 || 1 || 0)) : ((((! id2i.config_killall) && id2i.config_pgrep && id2i.config_pidof && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (0 || 1 || 1 || 1 || 1)) : (((id2i.config_killall && (! id2i.config_pgrep) && (! id2i.config_pidof) && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 0 || 0 || 0 || 0)) : (((id2i.config_killall && (! id2i.config_pgrep) && (! id2i.config_pidof) && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 0 || 0 || 0 || 1)) : (((id2i.config_killall && (! id2i.config_pgrep) && id2i.config_pidof && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 0 || 0 || 1 || 0)) : (((id2i.config_killall && (! id2i.config_pgrep) && id2i.config_pidof && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 0 || 0 || 1 || 1)) : (((id2i.config_killall && (! id2i.config_pgrep) && (! id2i.config_pidof) && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 0 || 1 || 0 || 0)) : (((id2i.config_killall && (! id2i.config_pgrep) && (! id2i.config_pidof) && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 0 || 1 || 0 || 1)) : (((id2i.config_killall && (! id2i.config_pgrep) && id2i.config_pidof && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 0 || 1 || 1 || 0)) : (((id2i.config_killall && (! id2i.config_pgrep) && id2i.config_pidof && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 0 || 1 || 1 || 1)) : (((id2i.config_killall && id2i.config_pgrep && (! id2i.config_pidof) && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 1 || 0 || 0 || 0)) : (((id2i.config_killall && id2i.config_pgrep && (! id2i.config_pidof) && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 1 || 0 || 0 || 1)) : (((id2i.config_killall && id2i.config_pgrep && id2i.config_pidof && (! id2i.config_pkill) && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 1 || 0 || 1 || 0)) : (((id2i.config_killall && id2i.config_pgrep && id2i.config_pidof && (! id2i.config_pkill) && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 1 || 0 || 1 || 1)) : (((id2i.config_killall && id2i.config_pgrep && (! id2i.config_pidof) && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 1 || 1 || 0 || 0)) : (((id2i.config_killall && id2i.config_pgrep && (! id2i.config_pidof) && id2i.config_pkill && id2i.config_sestatus) ) ? ((1 << 16) * (1 || 1 || 1 || 0 || 1)) : (((id2i.config_killall && id2i.config_pgrep && id2i.config_pidof && id2i.config_pkill && (! id2i.config_sestatus)) ) ? ((1 << 16) * (1 || 1 || 1 || 1 || 0)) : ((1 << 16) * (1 || 1 || 1 || 1 || 1))))))))))))))))))))))))))))))))),
  PSSCAN_CONTEXT = ((((! id2i.config_feature_find_context) && id2i.config_selinux) || (id2i.config_feature_find_context )) ? ((1 << 17) * 1) : ((1 << 17) * 0)),
  PSSCAN_START_TIME = (1 << 18),
  PSSCAN_CPU = (((id2i.config_feature_top_smp_process ) ) ? ((1 << 19) * 1) : ((1 << 19) * 0)),
  PSSCAN_NICE = (((id2i.config_feature_ps_additional_columns ) ) ? ((1 << 20) * 1) : ((1 << 20) * 0)),
  PSSCAN_RUIDGID = (((id2i.config_feature_ps_additional_columns ) ) ? ((1 << 21) * 1) : ((1 << 21) * 0)),
  PSSCAN_TASKS = (((id2i.config_feature_show_threads ) ) ? ((1 << 22) * 1) : ((1 << 22) * 0)),
  PSSCAN_STAT = (PSSCAN_PPID | PSSCAN_PGID | PSSCAN_SID | PSSCAN_COMM | PSSCAN_STATE | PSSCAN_VSZ | PSSCAN_RSS | PSSCAN_STIME | PSSCAN_UTIME | PSSCAN_START_TIME | PSSCAN_TTY | PSSCAN_NICE | PSSCAN_CPU)
} ;
void free_procps_scan(procps_status_t *sp );
procps_status_t *procps_scan(procps_status_t *sp , int flags );
void read_cmdline(char *buf , int size , unsigned pid , const  char *comm );
pid_t *find_pid_by_name(const  char *procName );
pid_t *pidlist_reverse(pid_t *pidList );
int starts_with_cpu(const  char *str );
unsigned get_cpu_count(void );
extern const char bb_uuenc_tbl_base64[];
extern const char bb_uuenc_tbl_std[];
void bb_uuencode(char *store , const  void *s , int length , const  char *tbl );
enum  {
  BASE64_FLAG_UU_STOP = 0x100,
  BASE64_FLAG_NO_STOP_CHAR = 0x80
} ;
void read_base64(FILE *src_stream , FILE *dst_stream , int flags );
typedef struct  md5_ctx_t {
  uint8_t wbuffer[64] ;
  void ( *process_block)(struct  md5_ctx_t   * ) ;
  uint64_t total64 ;
  uint32_t hash[8] ;
}  md5_ctx_t;
typedef struct  md5_ctx_t   sha1_ctx_t;
typedef struct  md5_ctx_t   sha256_ctx_t;
typedef struct  sha512_ctx_t {
  uint64_t total64[2] ;
  uint64_t hash[8] ;
  uint8_t wbuffer[128] ;
}  sha512_ctx_t;
void md5_begin(md5_ctx_t *ctx );
void md5_hash(md5_ctx_t *ctx , const  void *data , size_t length );
void md5_end(md5_ctx_t *ctx , void *resbuf );
void sha1_begin(sha1_ctx_t *ctx );
void sha1_end(sha1_ctx_t *ctx , void *resbuf );
void sha256_begin(sha256_ctx_t *ctx );
void sha512_begin(sha512_ctx_t *ctx );
void sha512_hash(sha512_ctx_t *ctx , const  void *buffer , size_t len );
void sha512_end(sha512_ctx_t *ctx , void *resbuf );
extern uint32_t *global_crc32_table;
uint32_t *crc32_filltable(uint32_t *tbl256 , int endian );
uint32_t crc32_block_endian1(uint32_t val , const  void *buf , unsigned len , uint32_t *crc_table );
uint32_t crc32_block_endian0(uint32_t val , const  void *buf , unsigned len , uint32_t *crc_table );
typedef struct  masks_labels_t {
  const  char *labels ;
  const  int masks[] ;
}  masks_labels_t;
int print_flags_separated(const  int *masks , const  char *labels , int flags , const  char *separator );
int print_flags(const  masks_labels_t *ml , int flags );
typedef struct  bb_progress_t {
  off_t lastsize ;
  unsigned lastupdate_sec ;
  unsigned start_sec ;
  smallint inited ;
}  bb_progress_t;
void bb_progress_init(bb_progress_t *p );
void bb_progress_update(bb_progress_t *p , const  char *curfile , off_t beg_range , off_t transferred , off_t totalsize );
extern const char *applet_name;
extern const char bb_banner[];
extern const char bb_msg_memory_exhausted[];
extern const char bb_msg_invalid_date[];
extern const char bb_msg_unknown[];
extern const char bb_msg_can_not_create_raw_socket[];
extern const char bb_msg_perm_denied_are_you_root[];
extern const char bb_msg_you_must_be_root[];
extern const char bb_msg_requires_arg[];
extern const char bb_msg_invalid_arg[];
extern const char bb_msg_standard_input[];
extern const char bb_msg_standard_output[];
extern const char bb_hexdigits_upcase[];
extern const char bb_path_wtmp_file[];
extern const char bb_busybox_exec_path[];
extern const char bb_PATH_root_path[];
extern const int const_int_0;
extern const int const_int_1;
enum  {
  COMMON_BUFSIZE = ((8192 >= (256 * sizeof(void *))) ? (8192 + 1) : (256 * sizeof(void *)))
} ;
extern char bb_common_bufsiz1[COMMON_BUFSIZE];
struct  globals   ;
extern struct  globals   *const ptr_to_globals;
extern const char bb_default_login_shell[];
static  inline  int bb_ascii_isalnum(unsigned  char a )  {
  unsigned char b =  (a - '0');
  if ((b <= 9)) {
    return (b <= 9);
  }  
  (b = ((a | 0x20) - 'a'));
  return (b <= ('z' - 'a'));
}
static  inline  int bb_ascii_isxdigit(unsigned  char a )  {
  unsigned char b =  (a - '0');
  if ((b <= 9)) {
    return (b <= 9);
  }  
  (b = ((a | 0x20) - 'a'));
  return (b <= ('f' - 'a'));
}
static  inline  unsigned  char bb_ascii_toupper(unsigned  char a )  {
  unsigned char b =  (a - 'a');
  if ((b <= ('z' - 'a'))) {
    (a -= ('a' - 'A'));
  }  
  return a;
}
static  inline  unsigned  char bb_ascii_tolower(unsigned  char a )  {
  unsigned char b =  (a - 'A');
  if ((b <= ('Z' - 'A'))) {
    (a += ('a' - 'A'));
  }  
  return a;
}
_Pragma("GCC visibility pop")
extern ssize_t _2976_sendfile(int __out_fd , int __in_fd , off_t *__offset , size_t __count ) __attribute__((__nothrow__));
extern ssize_t _2976_sendfile64(int __out_fd , int __in_fd , __off64_t *__offset , size_t __count ) __attribute__((__nothrow__));
static const char DEFAULT_PATH_HTTPD_CONF[] __attribute__((aligned (1))) =  "/etc";
static const char HTTPD_CONF[] __attribute__((aligned (1))) =  "httpd.conf";
static const char HTTP_200[] __attribute__((aligned (1))) =  "HTTP/1.0 200 OK\r\n";
static const char index_html[] __attribute__((aligned (1))) =  "index.html";
typedef struct  has_next_ptr {
  struct  has_next_ptr   *next ;
}  has_next_ptr;
typedef struct  Htaccess {
  struct  Htaccess   *next ;
  char *after_colon ;
  char before_colon[1] ;
}  Htaccess;
typedef struct  Htaccess_IP {
  struct  Htaccess_IP   *next ;
  unsigned ip ;
  unsigned mask ;
  int allow_deny ;
}  Htaccess_IP;
typedef struct  Htaccess_Proxy {
  struct  Htaccess_Proxy   *next ;
  char *url_from ;
  char *host_port ;
  char *url_to ;
}  Htaccess_Proxy;
enum  {
  HTTP_OK = 200,
  HTTP_PARTIAL_CONTENT = 206,
  HTTP_MOVED_TEMPORARILY = 302,
  HTTP_BAD_REQUEST = 400,
  HTTP_UNAUTHORIZED = 401,
  HTTP_NOT_FOUND = 404,
  HTTP_FORBIDDEN = 403,
  HTTP_REQUEST_TIMEOUT = 408,
  HTTP_NOT_IMPLEMENTED = 501,
  HTTP_INTERNAL_SERVER_ERROR = 500,
  HTTP_CONTINUE = 100
} ;
static const uint16_t _2977_http_response_type[] __attribute__((aligned (2))) =  { HTTP_OK,  HTTP_MOVED_TEMPORARILY,  HTTP_REQUEST_TIMEOUT,  HTTP_NOT_IMPLEMENTED,  HTTP_NOT_FOUND,  HTTP_BAD_REQUEST,  HTTP_FORBIDDEN,  HTTP_INTERNAL_SERVER_ERROR};
static const uint16_t _2978_http_response_type[] __attribute__((aligned (2))) =  { HTTP_OK,  HTTP_MOVED_TEMPORARILY,  HTTP_REQUEST_TIMEOUT,  HTTP_NOT_IMPLEMENTED,  HTTP_UNAUTHORIZED,  HTTP_NOT_FOUND,  HTTP_BAD_REQUEST,  HTTP_FORBIDDEN,  HTTP_INTERNAL_SERVER_ERROR};
static const uint16_t _2979_http_response_type[] __attribute__((aligned (2))) =  { HTTP_OK,  HTTP_PARTIAL_CONTENT,  HTTP_MOVED_TEMPORARILY,  HTTP_REQUEST_TIMEOUT,  HTTP_NOT_IMPLEMENTED,  HTTP_NOT_FOUND,  HTTP_BAD_REQUEST,  HTTP_FORBIDDEN,  HTTP_INTERNAL_SERVER_ERROR};
static const uint16_t _2980_http_response_type[] __attribute__((aligned (2))) =  { HTTP_OK,  HTTP_PARTIAL_CONTENT,  HTTP_MOVED_TEMPORARILY,  HTTP_REQUEST_TIMEOUT,  HTTP_NOT_IMPLEMENTED,  HTTP_UNAUTHORIZED,  HTTP_NOT_FOUND,  HTTP_BAD_REQUEST,  HTTP_FORBIDDEN,  HTTP_INTERNAL_SERVER_ERROR};
static const struct   {
  const  char *name ;
  const  char *info ;
}  _2977_http_response[((unsigned ) (sizeof(_2977_http_response_type) / sizeof(_2977_http_response_type[0])))] =  { { "OK",  ((void *) 0)},  { "Found",  ((void *) 0)},  { "Request Timeout",  "No request appeared within 60 seconds"},  { "Not Implemented",  "The requested method is not recognized"},  { "Not Found",  "The requested URL was not found"},  { "Bad Request",  "Unsupported method"},  { "Forbidden",  ""},  { "Internal Server Error",  "Internal Server Error"}};
static const struct   {
  const  char *name ;
  const  char *info ;
}  _2978_http_response[((unsigned ) (sizeof(_2978_http_response_type) / sizeof(_2978_http_response_type[0])))] =  { { "OK",  ((void *) 0)},  { "Found",  ((void *) 0)},  { "Request Timeout",  "No request appeared within 60 seconds"},  { "Not Implemented",  "The requested method is not recognized"},  { "Unauthorized",  ""},  { "Not Found",  "The requested URL was not found"},  { "Bad Request",  "Unsupported method"},  { "Forbidden",  ""},  { "Internal Server Error",  "Internal Server Error"}};
static const struct   {
  const  char *name ;
  const  char *info ;
}  _2979_http_response[((unsigned ) (sizeof(_2979_http_response_type) / sizeof(_2979_http_response_type[0])))] =  { { "OK",  ((void *) 0)},  { "Partial Content",  ((void *) 0)},  { "Found",  ((void *) 0)},  { "Request Timeout",  "No request appeared within 60 seconds"},  { "Not Implemented",  "The requested method is not recognized"},  { "Not Found",  "The requested URL was not found"},  { "Bad Request",  "Unsupported method"},  { "Forbidden",  ""},  { "Internal Server Error",  "Internal Server Error"}};
static const struct   {
  const  char *name ;
  const  char *info ;
}  _2980_http_response[((unsigned ) (sizeof(_2980_http_response_type) / sizeof(_2980_http_response_type[0])))] =  { { "OK",  ((void *) 0)},  { "Partial Content",  ((void *) 0)},  { "Found",  ((void *) 0)},  { "Request Timeout",  "No request appeared within 60 seconds"},  { "Not Implemented",  "The requested method is not recognized"},  { "Unauthorized",  ""},  { "Not Found",  "The requested URL was not found"},  { "Bad Request",  "Unsupported method"},  { "Forbidden",  ""},  { "Internal Server Error",  "Internal Server Error"}};
struct  globals {
  int verbose ;
  smallint flg_deny_all ;
  unsigned rmt_ip ;
  time_t last_mod ;
  char *rmt_ip_str ;
  const  char *bind_addr_or_port ;
  const  char *g_query ;
  const  char *opt_c_configFile ;
  const  char *home_httpd ;
  const  char *index_page ;
  const  char *found_mime_type ;
  const  char *found_moved_temporarily ;
  Htaccess_IP *ip_a_d ;
  const  char *_2981_g_realm ;
  char *_2981_remoteuser ;
  char *_2982_referer ;
  char *_2982_user_agent ;
  char *_2982_host ;
  char *_2982_http_accept ;
  char *_2982_http_accept_language ;
  off_t file_size ;
  off_t _2983_range_start ;
  off_t _2983_range_end ;
  off_t _2983_range_len ;
  Htaccess *_2981_g_auth ;
  Htaccess *mime_a ;
  Htaccess *_2984_script_i ;
  char *iobuf ;
  char *hdr_ptr ;
  int hdr_cnt ;
  const  char *_2985_http_error_page[((unsigned ) (sizeof(_2977_http_response_type) / sizeof(_2977_http_response_type[0])))] ;
  const  char *_2986_http_error_page[((unsigned ) (sizeof(_2978_http_response_type) / sizeof(_2978_http_response_type[0])))] ;
  const  char *_2987_http_error_page[((unsigned ) (sizeof(_2979_http_response_type) / sizeof(_2979_http_response_type[0])))] ;
  const  char *_2988_http_error_page[((unsigned ) (sizeof(_2980_http_response_type) / sizeof(_2980_http_response_type[0])))] ;
  Htaccess_Proxy *_2989_proxy ;
  smallint _2990_content_gzip ;
}  ;
enum  {
  _2991_range_start = 0,
  _2991_range_end = (((off_t ) ((((off_t ) (- 1)) > 0) ? ((off_t ) (- 1)) : ((off_t ) (~ (((off_t ) 1) << ((sizeof(off_t ) * 8) - 1)))))) - 1),
  _2991_range_len = ((off_t ) ((((off_t ) (- 1)) > 0) ? ((off_t ) (- 1)) : ((off_t ) (~ (((off_t ) 1) << ((sizeof(off_t ) * 8) - 1))))))
} ;
enum  {
  SEND_HEADERS = (1 << 0),
  SEND_BODY = (1 << 1),
  SEND_HEADERS_AND_BODY = (SEND_HEADERS + SEND_BODY)
} ;
static void send_file_and_exit(const  char *url , int what ) __attribute__((__noreturn__));
static  void free_llist(has_next_ptr **pptr )  {
  has_next_ptr *cur =  (*pptr);
  while (cur) {
    has_next_ptr *t =  cur;
    (cur = cur->next);
    free(t);
  }
  ((*pptr) = ((void *) 0));
}
static  inline  void free_Htaccess_list(Htaccess **pptr )  {
  free_llist(((has_next_ptr **) pptr));
}
static  inline  void free_Htaccess_IP_list(Htaccess_IP **pptr )  {
  free_llist(((has_next_ptr **) pptr));
}
static  int scan_ip(const  char **strp , unsigned *ipp , unsigned  char endc )  {
  const char *p =  (*strp);
  int auto_mask =  8;
  unsigned ip =  0;
  int j;
  if (((*p) == '/')) {
    return (- auto_mask);
  }  
  for ((j = 0); (j < 4); j++) {
    unsigned octet;
    if (((((*p) < '0') || ((*p) > '9')) && ((*p) != '/') && (*p))) {
      return (- auto_mask);
    }  
    (octet = 0);
    while ((((*p) >= '0') && ((*p) <= '9'))) {
      (octet *= 10);
      (octet += ((*p) - '0'));
      if ((octet > 255)) {
        return (- auto_mask);
      }  
      p++;
    }
    if (((*p) == '.')) {
      p++;
    }  
    if ((((*p) != '/') && (*p))) {
      (auto_mask += 8);
    }  
    (ip = ((ip << 8) | octet));
  }
  if ((*p)) {
    if (((*p) != endc)) {
      return (- auto_mask);
    }  
    p++;
    if (((*p) == '\0')) {
      return (- auto_mask);
    }  
  }  
  ((*ipp) = ip);
  ((*strp) = p);
  return auto_mask;
}
static  int scan_ip_mask(const  char *str , unsigned *ipp , unsigned *maskp )  {
  int i;
  unsigned mask;
  char *p;
  (i = scan_ip((&str), ipp, '/'));
  if ((i < 0)) {
    return i;
  }  
  if ((*str)) {
    (i = bb_strtou(str, (&p), 10));
    if (((*p) == '.')) {
      return (scan_ip((&str), maskp, '\0') - 32);
    }  
    if ((*p)) {
      return (- 1);
    }  
  }  
  if ((i > 32)) {
    return (- 1);
  }  
  if (((sizeof(unsigned ) == 4) && (i == 32))) {
    (mask = 0);
  }  
  ((*maskp) = ((uint32_t ) (~ mask)));
  return 0;
}
enum  {
  FIRST_PARSE = 0,
  SIGNALED_PARSE = 1,
  SUBDIR_PARSE = 2
} ;
static  void parse_conf(const  char *path , int flag )  {
  enum  {
    TRY_CURDIR_PARSE = 3
  } ;
  FILE *f;
  const char *filename;
  char buf[160];
  free_Htaccess_IP_list((&(*ptr_to_globals).ip_a_d));
  ((*ptr_to_globals).flg_deny_all = 0);
  if ((flag != SUBDIR_PARSE)) {
    free_Htaccess_list((&(*ptr_to_globals).mime_a));
    if (((id2i.config_feature_httpd_basic_auth ) )) {
      free_Htaccess_list((&(*ptr_to_globals)._2981_g_auth));
    }  
    if (((id2i.config_feature_httpd_config_with_script_interpr ) )) {
      free_Htaccess_list((&(*ptr_to_globals)._2984_script_i));
    }  
  }  
  (filename = (*ptr_to_globals).opt_c_configFile);
  if (((flag == SUBDIR_PARSE) || (filename == ((void *) 0)))) {
    (filename = __builtin_alloca((strlen(path) + sizeof(HTTPD_CONF) + 2)));
    sprintf(((char *) filename), "%s/%s", path, HTTPD_CONF);
  }  
  while (((f = fopen_for_read(filename)) == ((void *) 0))) {
    if ((flag >= SUBDIR_PARSE)) {
      return;
    }  
    if ((flag == FIRST_PARSE)) {
      if ((*ptr_to_globals).opt_c_configFile) {
        bb_simple_perror_msg_and_die((*ptr_to_globals).opt_c_configFile);
      }  
    }  
    (flag = TRY_CURDIR_PARSE);
    (filename = HTTPD_CONF);
  }
  if (((id2i.config_feature_httpd_basic_auth ) )) {
    if ((flag != SUBDIR_PARSE)) {
      (path = "");
    }  
  }  
  while ((fgets(buf, sizeof(buf), f) != ((void *) 0))) {
    unsigned strlen_buf;
    unsigned char ch;
    char *after_colon;
    if (1) {
      char *p, *p0;
      (p0 = buf);
      while ((((ch = (*p0)) != '\0') && (ch != '\n') && (ch != '#') && (ch != ' ') && (ch != '\t'))) {
        p0++;
      }
      (p = p0);
      while (((ch != '\0') && (ch != '\n') && (ch != '#'))) {
        if (((ch != ' ') && (ch != '\t'))) {
          ((*p++) = ch);
        }  
        (ch = (*++p0));
      }
      ((*p) = '\0');
      (strlen_buf = (p - buf));
      if ((strlen_buf == 0)) {
        continue;
      }  
    }  
    (after_colon = strchr(buf, ':'));
    if (((after_colon == ((void *) 0)) || ((*++after_colon) == '\0'))) {
      goto config_error;
    }  
    (ch = (buf[0] & (~ 0x20)));
    if ((ch == 'I')) {
      if (((*ptr_to_globals).index_page != index_html)) {
        free(((char *) (*ptr_to_globals).index_page));
      }  
      ((*ptr_to_globals).index_page = xstrdup(after_colon));
      continue;
    }  
    if (((flag == FIRST_PARSE) && (ch == 'H'))) {
      ((*ptr_to_globals).home_httpd = xstrdup(after_colon));
      xchdir((*ptr_to_globals).home_httpd);
      continue;
    }  
    if (((ch == 'A') || (ch == 'D'))) {
      Htaccess_IP *pip;
      if (((*after_colon) == '*')) {
        if ((ch == 'D')) {
          ((*ptr_to_globals).flg_deny_all = 1);
        }  
        continue;
      }  
      (pip = xzalloc(sizeof((*pip))));
      if (scan_ip_mask(after_colon, (&pip->ip), (&pip->mask))) {
        (ch = 'D');
        (pip->mask = 0);
      }  
      (pip->allow_deny = ch);
      if ((ch == 'D')) {
        (pip->next = (*ptr_to_globals).ip_a_d);
        ((*ptr_to_globals).ip_a_d = pip);
      }  
      continue;
    }  
    if (((id2i.config_feature_httpd_error_pages ) )) {
      if (((flag == FIRST_PARSE) && (ch == 'E'))) {
        unsigned i;
        int status =  atoi((buf + 1));
        if ((status < HTTP_CONTINUE)) {
          goto config_error;
        }  
        for ((i = 0); (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) ) ? (i < ((unsigned ) (sizeof(_2980_http_response_type) / sizeof(_2980_http_response_type[0])))) : (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) ) ? (i < ((unsigned ) (sizeof(_2979_http_response_type) / sizeof(_2979_http_response_type[0])))) : ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) ) ? (i < ((unsigned ) (sizeof(_2978_http_response_type) / sizeof(_2978_http_response_type[0])))) : (i < ((unsigned ) (sizeof(_2977_http_response_type) / sizeof(_2977_http_response_type[0]))))))); i++) {
          if ((((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) ) ? (_2980_http_response_type[i] == status) : (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) ) ? (_2979_http_response_type[i] == status) : ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) ) ? (_2978_http_response_type[i] == status) : (_2977_http_response_type[i] == status))))) {
            if ((((! id2i.config_feature_httpd_ranges) && (! id2i.config_feature_httpd_basic_auth)) )) {
              ((*ptr_to_globals)._2985_http_error_page[i] = xstrdup(after_colon));
            }  
            if ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) )) {
              ((*ptr_to_globals)._2986_http_error_page[i] = xstrdup(after_colon));
            }  
            if (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) )) {
              ((*ptr_to_globals)._2987_http_error_page[i] = xstrdup(after_colon));
            }  
            if (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) )) {
              ((*ptr_to_globals)._2988_http_error_page[i] = xstrdup(after_colon));
            }  
            break;
          }  
        }
        continue;
      }  
    }  
    if (((id2i.config_feature_httpd_proxy ) )) {
      if (((flag == FIRST_PARSE) && (ch == 'P'))) {
        char *url_from, *host_port, *url_to;
        Htaccess_Proxy *proxy_entry;
        (url_from = after_colon);
        (host_port = strchr(after_colon, ':'));
        if ((host_port == ((void *) 0))) {
          goto config_error;
        }  
        ((*host_port++) = '\0');
        if ((strncmp(host_port, "http://", 7) == 0)) {
          (host_port += 7);
        }  
        if (((*host_port) == '\0')) {
          goto config_error;
        }  
        (url_to = strchr(host_port, '/'));
        if ((url_to == ((void *) 0))) {
          goto config_error;
        }  
        ((*url_to) = '\0');
        (proxy_entry = xzalloc(sizeof((*proxy_entry))));
        (proxy_entry->url_from = xstrdup(url_from));
        (proxy_entry->host_port = xstrdup(host_port));
        ((*url_to) = '/');
        (proxy_entry->url_to = xstrdup(url_to));
        (proxy_entry->next = (*ptr_to_globals)._2989_proxy);
        ((*ptr_to_globals)._2989_proxy = proxy_entry);
        continue;
      }  
    }  
    (ch = buf[0]);
    if ((((id2i.config_feature_httpd_config_with_script_interpr ) ) ? ((ch == '.') || ((ch == '*') && (buf[1] == '.'))) : ((ch == '.') ))) {
      char *p;
      Htaccess *cur;
      (cur = xzalloc((sizeof((*cur)) + strlen_buf)));
      strcpy(cur->before_colon, buf);
      (p = (cur->before_colon + (after_colon - buf)));
      (p[(- 1)] = '\0');
      (cur->after_colon = p);
      if (((id2i.config_feature_httpd_config_with_script_interpr ) )) {
        if ((ch == '.')) {
          (cur->next = (*ptr_to_globals).mime_a);
          ((*ptr_to_globals).mime_a = cur);
        }  
      }  
      if ((((! id2i.config_feature_httpd_config_with_script_interpr) ) )) {
        if ((ch == '.')) {
          (cur->next = (*ptr_to_globals).mime_a);
          ((*ptr_to_globals).mime_a = cur);
        }  
      }  
      continue;
    }  
    if (((id2i.config_feature_httpd_basic_auth ) )) {
      if ((ch == '/')) {
        char *p;
        Htaccess *cur;
        unsigned file_len;
        (cur = xzalloc((sizeof((*cur)) + 1 + strlen(path) + strlen_buf)));
        sprintf(cur->before_colon, "/%s%.*s", path, ((int ) (after_colon - buf - 1)), buf);
        (p = bb_simplify_abs_path_inplace(cur->before_colon));
        (file_len = (p - cur->before_colon));
        strcpy(++p, after_colon);
        (cur->after_colon = p);
        if (1) {
          Htaccess *auth, **authp;
          (authp = (&(*ptr_to_globals)._2981_g_auth));
          while (((auth = (*authp)) != ((void *) 0))) {
            if ((file_len >= strlen(auth->before_colon))) {
              (cur->next = auth);
              break;
            }  
            (authp = (&auth->next));
          }
          ((*authp) = cur);
        }  
        continue;
      }  
    }  
    config_error:
    bb_error_msg("config error '%s' in '%s'", buf, filename);
  }
  fclose(f);
}
static  char *_2993_encodeString(const  char *string )  {
  int len =  strlen(string);
  char *out =  xmalloc(((len * 6) + 1));
  char *p =  out;
  char ch;
  while (((ch = (*string++)) != '\0')) {
    if (bb_ascii_isalnum(ch)) {
      ((*p++) = ch);
    }  
  }
  ((*p) = '\0');
  return out;
}
static  unsigned hex_to_bin(unsigned  char c )  {
  unsigned v;
  (v = (c - '0'));
  if ((v <= 9)) {
    return v;
  }  
  (v = (((unsigned ) (c | 0x20)) - 'a'));
  if ((v <= 5)) {
    return (v + 10);
  }  
  return (~ 0);
}
static  char *decodeString(char *orig , int option_d )  {
  char *string =  orig;
  char *ptr =  string;
  char c;
  while (((c = (*ptr++)) != '\0')) {
    unsigned v;
    if ((option_d && (c == '+'))) {
      ((*string++) = ' ');
      continue;
    }  
    if ((c != '%')) {
      ((*string++) = c);
      continue;
    }  
    (v = hex_to_bin(ptr[0]));
    if ((v > 15)) {
      bad_hex:
      if ((! option_d)) {
        return ((void *) 0);
      }  
      ((*string++) = '%');
      continue;
    }  
    (v = ((v * 16) | hex_to_bin(ptr[1])));
    if ((v > 255)) {
      goto bad_hex;
    }  
    if (((! option_d) && ((v == '/') || (v == '\0')))) {
      return (orig + 1);
    }  
    ((*string++) = v);
    (ptr += 2);
  }
  ((*string) = '\0');
  return orig;
}
static  void _2981_decodeBase64(char *Data )  {
  const unsigned char *in =  ((const  unsigned  char *) Data);
  unsigned ch =  0;
  int i =  0;
  while ((*in)) {
    int t =  (*in++);
    if (((t >= '0') && (t <= '9'))) {
      (t = (t - '0' + 52));
    } 
    else if (((t >= 'A') && (t <= 'Z'))) {
      (t = (t - 'A'));
    }
    
    else if (((t >= 'a') && (t <= 'z'))) {
      (t = (t - 'a' + 26));
    }
    
    else if ((t == '+')) {
      (t = 62);
    }
    
    else if ((t == '/')) {
      (t = 63);
    }
    
    else if ((t == '=')) {
      (t = 0);
    } 
    (ch = ((ch << 6) | t));
    i++;
    if ((i == 4)) {
      ((*Data++) = ((char ) (ch >> 16)));
      ((*Data++) = ((char ) (ch >> 8)));
      ((*Data++) = ((char ) ch));
      (i = 0);
    }  
  }
  ((*Data) = '\0');
}
static  int openServer(void )  {
  unsigned n =  bb_strtou((*ptr_to_globals).bind_addr_or_port, ((void *) 0), 10);
  if (((! (*bb_errno)) && n && (n <= 0xffff))) {
    (n = create_and_bind_stream_or_die(((void *) 0), n));
  }  
  xlisten(n, 9);
  return n;
}
static void log_and_exit(void ) __attribute__((__noreturn__));
static  void log_and_exit(void )  {
  shutdown(1, SHUT_WR);
  if (((*ptr_to_globals).verbose > 2)) {
    bb_error_msg("closed");
  }  
  _exit(xfunc_error_retval);
}
static  void send_headers(int responseNum )  {
  static const char RFC1123FMT[] __attribute__((aligned (1))) =  "%a, %d %b %Y %H:%M:%S GMT";
  const char *responseString =  "";
  const char *infoString =  ((void *) 0);
  const char *mime_type;
  const char *_2992_error_page =  ((void *) 0);
  unsigned i;
  time_t timer =  time(((void *) 0));
  char tmp_str[80];
  int len;
  for ((i = 0); (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) ) ? (i < ((unsigned ) (sizeof(_2980_http_response_type) / sizeof(_2980_http_response_type[0])))) : (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) ) ? (i < ((unsigned ) (sizeof(_2979_http_response_type) / sizeof(_2979_http_response_type[0])))) : ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) ) ? (i < ((unsigned ) (sizeof(_2978_http_response_type) / sizeof(_2978_http_response_type[0])))) : (i < ((unsigned ) (sizeof(_2977_http_response_type) / sizeof(_2977_http_response_type[0]))))))); i++) {
    if ((((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) ) ? (_2980_http_response_type[i] == responseNum) : (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) ) ? (_2979_http_response_type[i] == responseNum) : ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) ) ? (_2978_http_response_type[i] == responseNum) : (_2977_http_response_type[i] == responseNum))))) {
      if ((((! id2i.config_feature_httpd_ranges) && (! id2i.config_feature_httpd_basic_auth)) )) {
        (responseString = _2977_http_response[i].name);
      }  
      if ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) )) {
        (responseString = _2978_http_response[i].name);
      }  
      if (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) )) {
        (responseString = _2979_http_response[i].name);
      }  
      if (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) )) {
        (responseString = _2980_http_response[i].name);
      }  
      if ((((! id2i.config_feature_httpd_ranges) && (! id2i.config_feature_httpd_basic_auth)) )) {
        (infoString = _2977_http_response[i].info);
      }  
      if ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth) )) {
        (infoString = _2978_http_response[i].info);
      }  
      if (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth)) )) {
        (infoString = _2979_http_response[i].info);
      }  
      if (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth) )) {
        (infoString = _2980_http_response[i].info);
      }  
      if ((((! id2i.config_feature_httpd_ranges) && (! id2i.config_feature_httpd_basic_auth) && id2i.config_feature_httpd_error_pages) )) {
        (_2992_error_page = (*ptr_to_globals)._2985_http_error_page[i]);
      }  
      if ((((! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_error_pages) )) {
        (_2992_error_page = (*ptr_to_globals)._2986_http_error_page[i]);
      }  
      if (((id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_basic_auth) && id2i.config_feature_httpd_error_pages) )) {
        (_2992_error_page = (*ptr_to_globals)._2987_http_error_page[i]);
      }  
      if (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_error_pages) )) {
        (_2992_error_page = (*ptr_to_globals)._2988_http_error_page[i]);
      }  
      break;
    }  
  }
  (mime_type = ((responseNum == HTTP_OK) ? (*ptr_to_globals).found_mime_type : "text/html"));
  if ((*ptr_to_globals).verbose) {
    bb_error_msg("response:%u", responseNum);
  }  
  strftime(tmp_str, sizeof(tmp_str), RFC1123FMT, gmtime((&timer)));
  (len = sprintf((*ptr_to_globals).iobuf, "HTTP/1.0 %d %s\r\nContent-type: %s\r\n" "Date: %s\r\nConnection: close\r\n", responseNum, responseString, mime_type, tmp_str));
  if (((id2i.config_feature_httpd_basic_auth ) )) {
    if ((responseNum == HTTP_UNAUTHORIZED)) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "WWW-Authenticate: Basic realm=\"%s\"\r\n", (*ptr_to_globals)._2981_g_realm));
    }  
  }  
  if ((responseNum == HTTP_MOVED_TEMPORARILY)) {
    (len += sprintf(((*ptr_to_globals).iobuf + len), "Location: %s/%s%s\r\n", (*ptr_to_globals).found_moved_temporarily, ((*ptr_to_globals).g_query ? "?" : ""), ((*ptr_to_globals).g_query ? (*ptr_to_globals).g_query : "")));
  }  
  if (((id2i.config_feature_httpd_error_pages ) )) {
    if ((_2992_error_page && (access(_2992_error_page, 4) == 0))) {
      strcat((*ptr_to_globals).iobuf, "\r\n");
      (len += 2);
      if (0) {
        fprintf(stderr, "headers: '%s'\n", (*ptr_to_globals).iobuf);
      }  
      full_write(1, (*ptr_to_globals).iobuf, len);
      if (0) {
        fprintf(stderr, "writing error page: '%s'\n", _2992_error_page);
      }  
      return send_file_and_exit(_2992_error_page, SEND_BODY);
    }  
  }  
  if (((*ptr_to_globals).file_size != (- 1))) {
    strftime(tmp_str, sizeof(tmp_str), RFC1123FMT, gmtime((&(*ptr_to_globals).last_mod)));
    if (((id2i.config_feature_httpd_ranges ) )) {
      if ((responseNum == HTTP_PARTIAL_CONTENT)) {
        if ((((! id2i.config_lfs) ) )) {
          (len += sprintf(((*ptr_to_globals).iobuf + len), "Content-Range: bytes %" "l" "u-%" "l" "u/%" "l" "u\r\n", (*ptr_to_globals)._2983_range_start, (*ptr_to_globals)._2983_range_end, (*ptr_to_globals).file_size));
        }  
        if (((id2i.config_lfs ) )) {
          (len += sprintf(((*ptr_to_globals).iobuf + len), "Content-Range: bytes %" "ll" "u-%" "ll" "u/%" "ll" "u\r\n", (*ptr_to_globals)._2983_range_start, (*ptr_to_globals)._2983_range_end, (*ptr_to_globals).file_size));
        }  
        ((*ptr_to_globals).file_size = ((*ptr_to_globals)._2983_range_end - (*ptr_to_globals)._2983_range_start + 1));
      }  
    }  
    if (((id2i.config_lfs && id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_gzip) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Accept-Ranges: bytes\r\n" "Last-Modified: %s\r\n%s %" "ll" "u\r\n", tmp_str, ((*ptr_to_globals)._2990_content_gzip ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if (((id2i.config_lfs && id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_gzip)) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Accept-Ranges: bytes\r\n" "Last-Modified: %s\r\n%s %" "ll" "u\r\n", tmp_str, (0 ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if ((((! id2i.config_lfs) && id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_gzip) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Accept-Ranges: bytes\r\n" "Last-Modified: %s\r\n%s %" "l" "u\r\n", tmp_str, ((*ptr_to_globals)._2990_content_gzip ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if ((((! id2i.config_lfs) && id2i.config_feature_httpd_ranges && (! id2i.config_feature_httpd_gzip)) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Accept-Ranges: bytes\r\n" "Last-Modified: %s\r\n%s %" "l" "u\r\n", tmp_str, (0 ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if (((id2i.config_lfs && (! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_gzip) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Last-Modified: %s\r\n%s %" "ll" "u\r\n", tmp_str, ((*ptr_to_globals)._2990_content_gzip ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if (((id2i.config_lfs && (! id2i.config_feature_httpd_ranges) && (! id2i.config_feature_httpd_gzip)) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Last-Modified: %s\r\n%s %" "ll" "u\r\n", tmp_str, (0 ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if ((((! id2i.config_lfs) && (! id2i.config_feature_httpd_ranges) && id2i.config_feature_httpd_gzip) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Last-Modified: %s\r\n%s %" "l" "u\r\n", tmp_str, ((*ptr_to_globals)._2990_content_gzip ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
    if ((((! id2i.config_lfs) && (! id2i.config_feature_httpd_ranges) && (! id2i.config_feature_httpd_gzip)) )) {
      (len += sprintf(((*ptr_to_globals).iobuf + len), "Last-Modified: %s\r\n%s %" "l" "u\r\n", tmp_str, (0 ? "Transfer-length:" : "Content-length:"), (*ptr_to_globals).file_size));
    }  
  }  
  if (((((! id2i.config_feature_httpd_gzip) ) ) ? 0 : (*ptr_to_globals)._2990_content_gzip)) {
    (len += sprintf(((*ptr_to_globals).iobuf + len), "Content-Encoding: gzip\r\n"));
  }  
  ((*ptr_to_globals).iobuf[len++] = '\r');
  ((*ptr_to_globals).iobuf[len++] = '\n');
  if (infoString) {
    (len += sprintf(((*ptr_to_globals).iobuf + len), "<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\n" "<BODY><H1>%d %s</H1>\n%s\n</BODY></HTML>\n", responseNum, responseString, responseNum, responseString, infoString));
  }  
  if (0) {
    fprintf(stderr, "headers: '%s'\n", (*ptr_to_globals).iobuf);
  }  
  if ((full_write(1, (*ptr_to_globals).iobuf, len) != len)) {
    if (((*ptr_to_globals).verbose > 1)) {
      bb_perror_msg("error");
    }  
    log_and_exit();
  }  
}
static void send_headers_and_exit(int responseNum ) __attribute__((__noreturn__));
static  void send_headers_and_exit(int responseNum )  {
  send_headers(responseNum);
  log_and_exit();
}
static  int get_line(void )  {
  int count =  0;
  char c;
  alarm(60);
  while (1) {
    if (((*ptr_to_globals).hdr_cnt <= 0)) {
      ((*ptr_to_globals).hdr_cnt = safe_read(0, bb_common_bufsiz1, sizeof(bb_common_bufsiz1)));
      if (((*ptr_to_globals).hdr_cnt <= 0)) {
        break;
      }  
      ((*ptr_to_globals).hdr_ptr = bb_common_bufsiz1);
    }  
    ((*ptr_to_globals).iobuf[count] = (c = (*(*ptr_to_globals).hdr_ptr++)));
    (*ptr_to_globals).hdr_cnt--;
    if ((c == '\r')) {
      continue;
    }  
    if ((c == '\n')) {
      ((*ptr_to_globals).iobuf[count] = '\0');
      break;
    }  
    if ((count < (8192 - 1))) {
      count++;
    }  
  }
  return count;
}
static void _2998_cgi_io_loop_and_exit(int fromCgi_rd , int toCgi_wr , int post_len ) __attribute__((__noreturn__));
static  void _2998_cgi_io_loop_and_exit(int fromCgi_rd , int toCgi_wr , int post_len )  {
  enum  {
    FROM_CGI = 1,
    TO_CGI = 2
  } ;
  struct  pollfd   pfd[3];
  int out_cnt;
  int count;
  signal(13, ((__sighandler_t ) 1));
  (post_len -= (*ptr_to_globals).hdr_cnt);
  (out_cnt = 0);
  while (1) {
    memset(pfd, 0, sizeof(pfd));
    (pfd[FROM_CGI].fd = fromCgi_rd);
    (pfd[FROM_CGI].events = 0x001);
    if (toCgi_wr) {
      (pfd[TO_CGI].fd = toCgi_wr);
      if (((*ptr_to_globals).hdr_cnt > 0)) {
        (pfd[TO_CGI].events = 0x004);
      } 
      else if ((post_len > 0)) {
        (pfd[0].events = 0x001);
      } 
    }  
    (count = safe_poll(pfd, (toCgi_wr ? (TO_CGI + 1) : (FROM_CGI + 1)), (- 1)));
    if ((count <= 0)) {
      break;
    }  
    if (pfd[TO_CGI].revents) {
      (count = safe_write(toCgi_wr, (*ptr_to_globals).hdr_ptr, (*ptr_to_globals).hdr_cnt));
      if ((count > 0)) {
        ((*ptr_to_globals).hdr_ptr += count);
        ((*ptr_to_globals).hdr_cnt -= count);
      }  
    }  
    if (pfd[0].revents) {
      (count = safe_read(0, bb_common_bufsiz1, sizeof(bb_common_bufsiz1)));
      if ((count > 0)) {
        ((*ptr_to_globals).hdr_cnt = count);
        ((*ptr_to_globals).hdr_ptr = bb_common_bufsiz1);
        (post_len -= count);
      }  
    }  
    if (pfd[FROM_CGI].revents) {
      char *rbuf =  (*ptr_to_globals).iobuf;
      if ((out_cnt >= 0)) {
        (count = safe_read(fromCgi_rd, (rbuf + out_cnt), (4096 - 8)));
        if ((count <= 0)) {
          if (out_cnt) {
            full_write(1, HTTP_200, (sizeof(HTTP_200) - 1));
            full_write(1, rbuf, out_cnt);
          }  
          break;
        }  
        (out_cnt += count);
        (count = 0);
        if (((out_cnt >= 8) && (memcmp(rbuf, "Status: ", 8) == 0))) {
          if ((full_write(1, HTTP_200, 9) != 9)) {
            break;
          }  
          (rbuf += 8);
          (count = (out_cnt - 8));
          (out_cnt = (- 1));
        } 
        else if ((out_cnt >= 4)) {
          if ((memcmp(rbuf, HTTP_200, 4) != 0)) {
            if ((full_write(1, HTTP_200, (sizeof(HTTP_200) - 1)) != (sizeof(HTTP_200) - 1))) {
              break;
            }  
          }  
          (count = out_cnt);
          (out_cnt = (- 1));
        } 
      }  
      if ((full_write(1, rbuf, count) != count)) {
        break;
      }  
      if (0) {
        fprintf(stderr, "cgi read %d bytes: '%.*s'\n", count, count, rbuf);
      }  
    }  
  }
  log_and_exit();
}
static  void _2982_setenv1(const  char *name , const  char *value )  {
  setenv(name, (value ? value : ""), 1);
}
static void _2982_send_cgi_and_exit(const  char *url , const  char *request , int post_len , const  char *cookie , const  char *content_type ) __attribute__((__noreturn__));
static  void _2982_send_cgi_and_exit(const  char *url , const  char *request , int post_len , const  char *cookie , const  char *content_type )  {
  struct  fd_pair   fromCgi;
  struct  fd_pair   toCgi;
  char *script;
  int pid;
  (url = xstrdup(url));
  (script = ((char *) url));
  while (((script = strchr((script + 1), '/')) != ((void *) 0))) {
    ((*script) = '\0');
    if ((! is_directory((url + 1), 1, ((void *) 0)))) {
      ((*script) = '/');
      break;
    }  
    ((*script) = '/');
  }
  _2982_setenv1("PATH_INFO", script);
  _2982_setenv1("REQUEST_METHOD", request);
  if ((*ptr_to_globals).g_query) {
    putenv(xasprintf("%s=%s?%s", "REQUEST_URI", url, (*ptr_to_globals).g_query));
  }  
  if ((script != ((void *) 0))) {
    ((*script) = '\0');
  }  
  if (((*ptr_to_globals).home_httpd[0] == '/')) {
    char *fullpath =  concat_path_file((*ptr_to_globals).home_httpd, url);
    _2982_setenv1("SCRIPT_FILENAME", fullpath);
  }  
  _2982_setenv1("SCRIPT_NAME", url);
  _2982_setenv1("QUERY_STRING", (*ptr_to_globals).g_query);
  putenv(((char *) "SERVER_SOFTWARE=busybox httpd/" "1.8.5"));
  putenv(((char *) "SERVER_PROTOCOL=HTTP/1.0"));
  putenv(((char *) "GATEWAY_INTERFACE=CGI/1.1"));
  if (1) {
    char *p =  ((*ptr_to_globals).rmt_ip_str ? (*ptr_to_globals).rmt_ip_str : ((char *) ""));
    char *cp =  strrchr(p, ':');
    if (((((! id2i.config_feature_ipv6) ) || (id2i.config_feature_ipv6 && (! id2i.config_feature_httpd_cgi))) ? ((((! id2i.config_feature_ipv6) && id2i.config_feature_httpd_cgi) ) ? (0 && cp && strchr(cp, ']')) : (0 && cp && strchr())) : (1 && cp && strchr(cp, ']')))) {
      (cp = ((void *) 0));
    }  
    if (cp) {
      ((*cp) = '\0');
    }  
    _2982_setenv1("REMOTE_ADDR", p);
    if (cp) {
      ((*cp) = ':');
      if (((id2i.config_feature_httpd_cgi && id2i.config_feature_httpd_set_remote_port_to_env) )) {
        _2982_setenv1("REMOTE_PORT", (cp + 1));
      }  
    }  
  }  
  _2982_setenv1("HTTP_USER_AGENT", (*ptr_to_globals)._2982_user_agent);
  if ((*ptr_to_globals)._2982_http_accept) {
    _2982_setenv1("HTTP_ACCEPT", (*ptr_to_globals)._2982_http_accept);
  }  
  if ((*ptr_to_globals)._2982_http_accept_language) {
    _2982_setenv1("HTTP_ACCEPT_LANGUAGE", (*ptr_to_globals)._2982_http_accept_language);
  }  
  if (post_len) {
    putenv(xasprintf("CONTENT_LENGTH=%d", post_len));
  }  
  if (cookie) {
    _2982_setenv1("HTTP_COOKIE", cookie);
  }  
  if (content_type) {
    _2982_setenv1("CONTENT_TYPE", content_type);
  }  
  if (((id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_cgi) )) {
    if ((*ptr_to_globals)._2981_remoteuser) {
      _2982_setenv1("REMOTE_USER", (*ptr_to_globals)._2981_remoteuser);
      putenv(((char *) "AUTH_TYPE=Basic"));
    }  
  }  
  if ((*ptr_to_globals)._2982_referer) {
    _2982_setenv1("HTTP_REFERER", (*ptr_to_globals)._2982_referer);
  }  
  _2982_setenv1("HTTP_HOST", (*ptr_to_globals)._2982_host);
  xpipe((&fromCgi.rd));
  xpipe((&toCgi.rd));
  (pid = vfork());
  if ((pid < 0)) {
    log_and_exit();
  }  
  if ((! pid)) {
    char *argv[3];
    (xfunc_error_retval = 242);
    close(toCgi.wr);
    close(fromCgi.rd);
    xmove_fd(toCgi.rd, 0);
    xmove_fd(fromCgi.wr, 1);
    (script = strrchr(url, '/'));
    if ((script != url)) {
      ((*script) = '\0');
      if ((chdir((url + 1)) != 0)) {
        bb_perror_msg("chdir(%s)", (url + 1));
        goto error_execing_cgi;
      }  
    }  
    script++;
    (argv[0] = script);
    (argv[1] = ((void *) 0));
    if (((id2i.config_feature_httpd_cgi && id2i.config_feature_httpd_config_with_script_interpr) )) {
      char *suffix =  strrchr(script, '.');
      if (suffix) {
        Htaccess *cur;
        for ((cur = (*ptr_to_globals)._2984_script_i); cur; (cur = cur->next)) {
          if ((strcmp((cur->before_colon + 1), suffix) == 0)) {
            (argv[0] = cur->after_colon);
            (argv[1] = script);
            (argv[2] = ((void *) 0));
            break;
          }  
        }
      }  
    }  
    bb_signals((0 | (1 << 17) | (1 << 13) | (1 << 1)), ((__sighandler_t ) 0));
    execv(argv[0], argv);
    if ((*ptr_to_globals).verbose) {
      bb_perror_msg("can't execute '%s'", argv[0]);
    }  
    error_execing_cgi:
    send_headers_and_exit(HTTP_NOT_FOUND);
  }  
  (xfunc_error_retval = 0);
  close(fromCgi.wr);
  close(toCgi.rd);
  _2998_cgi_io_loop_and_exit(fromCgi.rd, toCgi.wr, post_len);
}
static  void send_file_and_exit(const  char *url , int what )  {
  char *suffix;
  int fd;
  ssize_t count;
  if (((((! id2i.config_feature_httpd_gzip) ) ) ? 0 : (*ptr_to_globals)._2990_content_gzip)) {
    char *gzurl =  xasprintf("%s.gz", url);
    (fd = open(gzurl, 00));
    free(gzurl);
    if ((fd != (- 1))) {
      struct  stat   sb;
      fstat(fd, (&sb));
      ((*ptr_to_globals).file_size = sb.st_size);
      ((*ptr_to_globals).last_mod = sb.st_mtim.tv_sec);
    }  
  }  
  if ((fd < 0)) {
    if (0) {
      bb_perror_msg("can't open '%s'", url);
    }  
    if ((what != SEND_BODY)) {
      send_headers_and_exit(HTTP_NOT_FOUND);
    }  
    log_and_exit();
  }  
  signal(13, ((__sighandler_t ) 1));
  ((*ptr_to_globals).found_mime_type = "application/octet-stream");
  (suffix = strrchr(url, '.'));
  if (suffix) {
    static const char suffixTable[] __attribute__((aligned (1))) =  ".txt.h.c.cc.cpp\0" "text/plain\0" ".htm.html\0" "text/html\0" ".jpg.jpeg\0" "image/jpeg\0" ".gif\0" "image/gif\0" ".png\0" "image/png\0" ".css\0" "text/css\0" ".wav\0" "audio/wav\0" ".avi\0" "video/x-msvideo\0" ".qt.mov\0" "video/quicktime\0" ".mpe.mpeg\0" "video/mpeg\0" ".mid.midi\0" "audio/midi\0" ".mp3\0" "audio/mpeg\0";
    Htaccess *cur;
    const char *table =  suffixTable;
    const char *table_next;
    for (; (*table); (table = table_next)) {
      const char *try_suffix;
      const char *mime_type;
      (mime_type = (table + strlen(table) + 1));
      (table_next = (mime_type + strlen(mime_type) + 1));
      (try_suffix = strstr(table, suffix));
      if ((! try_suffix)) {
        continue;
      }  
      (try_suffix += strlen(suffix));
      if ((((*try_suffix) == '\0') || ((*try_suffix) == '.'))) {
        ((*ptr_to_globals).found_mime_type = mime_type);
        break;
      }  
      break;
    }
    for ((cur = (*ptr_to_globals).mime_a); cur; (cur = cur->next)) {
      if ((strcmp(cur->before_colon, suffix) == 0)) {
        ((*ptr_to_globals).found_mime_type = cur->after_colon);
        break;
      }  
    }
  }  
  if (0) {
    bb_error_msg("sending file '%s' content-type: %s", url, (*ptr_to_globals).found_mime_type);
  }  
  if (((id2i.config_feature_httpd_ranges ) )) {
    if ((((id2i.config_feature_httpd_gzip ) ) ? ((what == SEND_BODY) || (*ptr_to_globals)._2990_content_gzip) : ((what == SEND_BODY) || 0))) {
      ((*ptr_to_globals)._2983_range_start = 0);
    }  
  }  
  if (((id2i.config_feature_httpd_ranges ) )) {
    ((*ptr_to_globals)._2983_range_len = ((off_t ) ((((off_t ) (- 1)) > 0) ? ((off_t ) (- 1)) : ((off_t ) (~ (((off_t ) 1) << ((sizeof(off_t ) * 8) - 1)))))));
  }  
  if (((id2i.config_feature_httpd_ranges ) )) {
    if ((*ptr_to_globals)._2983_range_start) {
      if ((! (*ptr_to_globals)._2983_range_end)) {
        ((*ptr_to_globals)._2983_range_end = ((*ptr_to_globals).file_size - 1));
      }  
      if ((((*ptr_to_globals)._2983_range_end < (*ptr_to_globals)._2983_range_start) || (lseek(fd, (*ptr_to_globals)._2983_range_start, 0) != (*ptr_to_globals)._2983_range_start))) {
        lseek(fd, 0, 0);
        ((*ptr_to_globals)._2983_range_start = 0);
      }  
    }  
  }  
  if ((what & SEND_HEADERS)) {
    send_headers(HTTP_OK);
  }  
  if (((id2i.config_feature_httpd_use_sendfile ) )) {
    off_t _3002_offset =  _2991_range_start;
    off_t _3003_offset =  (*ptr_to_globals)._2983_range_start;
    while (1) {
      ssize_t sz =  (((ssize_t ) ((((ssize_t ) (- 1)) > 0) ? ((ssize_t ) (- 1)) : ((ssize_t ) (~ (((ssize_t ) 1) << ((sizeof(ssize_t ) * 8) - 1)))))) - 0xffff);
      if (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_use_sendfile) )) {
        if ((sz > (*ptr_to_globals)._2983_range_len)) {
          (sz = (*ptr_to_globals)._2983_range_len);
        }  
      }  
      if ((((! id2i.config_feature_httpd_ranges) ) )) {
        (count = _2976_sendfile(1, fd, (&_3002_offset), sz));
      }  
      if (((id2i.config_feature_httpd_ranges ) )) {
        (count = _2976_sendfile(1, fd, (&_3003_offset), sz));
      }  
      if ((count < 0)) {
        if ((((id2i.config_feature_httpd_ranges ) ) ? (_3003_offset == (*ptr_to_globals)._2983_range_start) : (_3002_offset == _2991_range_start))) {
          break;
        }  
        goto fin;
      }  
      if (((id2i.config_feature_httpd_ranges && id2i.config_feature_httpd_use_sendfile) )) {
        ((*ptr_to_globals)._2983_range_len -= sz);
      }  
      if ((((id2i.config_feature_httpd_ranges ) ) ? ((count == 0) || ((*ptr_to_globals)._2983_range_len == 0)) : ((count == 0) || (_2991_range_len == 0)))) {
        log_and_exit();
      }  
    }
  }  
  while (((count = safe_read(fd, (*ptr_to_globals).iobuf, 8192)) > 0)) {
    ssize_t n;
    if (((id2i.config_feature_httpd_ranges ) )) {
      if ((count > (*ptr_to_globals)._2983_range_len)) {
        (count = (*ptr_to_globals)._2983_range_len);
      }  
    }  
    (n = full_write(1, (*ptr_to_globals).iobuf, count));
    if ((count != n)) {
      break;
    }  
    if (((id2i.config_feature_httpd_ranges ) )) {
      ((*ptr_to_globals)._2983_range_len -= count);
    }  
    if (((((! id2i.config_feature_httpd_ranges) ) ) ? (_2991_range_len == 0) : ((*ptr_to_globals)._2983_range_len == 0))) {
      break;
    }  
  }
  if ((count < 0)) {
    if (((id2i.config_feature_httpd_use_sendfile ) )) {
      fin:
    }  
    if (((*ptr_to_globals).verbose > 1)) {
      bb_perror_msg("error");
    }  
  }  
  log_and_exit();
}
static  int checkPermIP(void )  {
  Htaccess_IP *cur;
  for ((cur = (*ptr_to_globals).ip_a_d); cur; (cur = cur->next)) {
    if ((((*ptr_to_globals).rmt_ip & cur->mask) == cur->ip)) {
      return (cur->allow_deny == 'A');
    }  
  }
  return (! (*ptr_to_globals).flg_deny_all);
}
static  int _2981_check_user_passwd(const  char *path , const  char *user_and_passwd )  {
  Htaccess *cur;
  const char *prev =  ((void *) 0);
  for ((cur = (*ptr_to_globals)._2981_g_auth); cur; (cur = cur->next)) {
    const char *dir_prefix;
    size_t len;
    (dir_prefix = cur->before_colon);
    if ((prev && (strcmp(prev, dir_prefix) != 0))) {
      continue;
    }  
    if (0) {
      fprintf(stderr, "checkPerm: '%s' ? '%s'\n", dir_prefix, user_and_passwd);
    }  
    (len = strlen(dir_prefix));
    if (((len != 1) && ((strncmp(dir_prefix, path, len) != 0) || ((path[len] != '/') && (path[len] != '\0'))))) {
      continue;
    }  
    (prev = dir_prefix);
    if (((((! id2i.config_feature_httpd_auth_md5) ) ) ? 0 : 1)) {
      char *md5_passwd;
      (md5_passwd = strchr(cur->after_colon, ':'));
      if ((md5_passwd && (md5_passwd[1] == '$') && (md5_passwd[2] == '1') && (md5_passwd[3] == '$') && md5_passwd[4])) {
        char *encrypted;
        int r, user_len_p1;
        md5_passwd++;
        (user_len_p1 = (md5_passwd - cur->after_colon));
        if ((strncmp(cur->after_colon, user_and_passwd, user_len_p1) != 0)) {
          continue;
        }  
        if ((((! id2i.config_use_bb_crypt) && id2i.config_feature_httpd_basic_auth) )) {
          (encrypted = _36_pw_encrypt((user_and_passwd + user_len_p1), md5_passwd));
        }  
        if (((id2i.config_use_bb_crypt && id2i.config_feature_httpd_basic_auth) )) {
          (encrypted = _35_pw_encrypt((user_and_passwd + user_len_p1), md5_passwd, 1));
        }  
        (r = strcmp(encrypted, md5_passwd));
        free(encrypted);
        if ((r == 0)) {
          goto set_remoteuser_var;
        }  
        continue;
      }  
    }  
    if ((strcmp(cur->after_colon, user_and_passwd) == 0)) {
      set_remoteuser_var:
      ((*ptr_to_globals)._2981_remoteuser = xstrndup(user_and_passwd, (strchrnul(user_and_passwd, ':') - user_and_passwd)));
      return 1;
    }  
  }
  return (prev == ((void *) 0));
}
static  Htaccess_Proxy *_2989_find_proxy_entry(const  char *url )  {
  Htaccess_Proxy *p;
  for ((p = (*ptr_to_globals)._2989_proxy); p; (p = p->next)) {
    if ((strncmp(url, p->url_from, strlen(p->url_from)) == 0)) {
      return p;
    }  
  }
  return ((void *) 0);
}
static void send_REQUEST_TIMEOUT_and_exit(int sig ) __attribute__((__noreturn__));
static  void send_REQUEST_TIMEOUT_and_exit(int sig __attribute__((__unused__)))  {
  send_headers_and_exit(HTTP_REQUEST_TIMEOUT);
}
static void handle_incoming_and_exit(const  len_and_sockaddr *fromAddr ) __attribute__((__noreturn__));
static  void handle_incoming_and_exit(const  len_and_sockaddr *fromAddr )  {
  static const char request_GET[] __attribute__((aligned (1))) =  "GET";
  struct  stat   sb;
  char *urlcopy;
  char *urlp;
  char *tptr;
  static const char _2982_request_HEAD[] __attribute__((aligned (1))) =  "HEAD";
  const char *_2982_prequest;
  char *_2982_cookie =  ((void *) 0);
  char *_2982_content_type =  ((void *) 0);
  unsigned long _2982_length =  0;
  unsigned long _3006_length =  0;
  smallint _3007_ip_allowed;
  smallint _3008_authorized =  (- 1);
  smallint _3009_authorized =  (- 1);
  smallint _3010_ip_allowed;
  char http_major_version;
  char _2989_http_minor_version;
  char *_2989_header_buf =  _2989_header_buf;
  char *_2989_header_ptr =  _2989_header_ptr;
  Htaccess_Proxy *_2989_proxy_entry;
  ((*ptr_to_globals).iobuf = xmalloc(8192));
  ((*ptr_to_globals).rmt_ip = 0);
  if ((fromAddr->u.sa.sa_family == 2)) {
    ((*ptr_to_globals).rmt_ip = ntohl(fromAddr->u.sin.sin_addr.s_addr));
  }  
  if (((id2i.config_feature_ipv6 ) )) {
    if (((fromAddr->u.sa.sa_family == 10) && (fromAddr->u._8_sin6.sin6_addr.__in6_u.__u6_addr32[0] == 0) && (fromAddr->u._8_sin6.sin6_addr.__in6_u.__u6_addr32[1] == 0) && (ntohl(fromAddr->u._8_sin6.sin6_addr.__in6_u.__u6_addr32[2]) == 0xffff))) {
      ((*ptr_to_globals).rmt_ip = ntohl(fromAddr->u._8_sin6.sin6_addr.__in6_u.__u6_addr32[3]));
    }  
  }  
  if (((((! id2i.config_feature_httpd_cgi) ) ) ? (0 || 0 || (*ptr_to_globals).verbose) : (1 || 0 || (*ptr_to_globals).verbose))) {
    ((*ptr_to_globals).rmt_ip_str = xmalloc_sockaddr2dotted((&fromAddr->u.sa)));
  }  
  if ((*ptr_to_globals).verbose) {
    if ((*ptr_to_globals).rmt_ip_str) {
      (applet_name = (*ptr_to_globals).rmt_ip_str);
    }  
    if (((*ptr_to_globals).verbose > 2)) {
      bb_error_msg("connected");
    }  
  }  
  signal(14, send_REQUEST_TIMEOUT_and_exit);
  if ((! get_line())) {
    send_headers_and_exit(HTTP_BAD_REQUEST);
  }  
  (urlp = strpbrk((*ptr_to_globals).iobuf, " \t"));
  if ((urlp == ((void *) 0))) {
    send_headers_and_exit(HTTP_BAD_REQUEST);
  }  
  ((*urlp++) = '\0');
  if (((id2i.config_feature_httpd_cgi ) )) {
    (_2982_prequest = request_GET);
  }  
  if (((id2i.config_feature_httpd_cgi ) )) {
    if ((strcasecmp((*ptr_to_globals).iobuf, _2982_prequest) != 0)) {
      (_2982_prequest = _2982_request_HEAD);
      if ((strcasecmp((*ptr_to_globals).iobuf, _2982_prequest) != 0)) {
        (_2982_prequest = "POST");
        if ((strcasecmp((*ptr_to_globals).iobuf, _2982_prequest) != 0)) {
          send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
        }  
      }  
    }  
  }  
  if ((((! id2i.config_feature_httpd_cgi) ) )) {
    if ((strcasecmp((*ptr_to_globals).iobuf, request_GET) != 0)) {
      send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
    }  
  }  
  (urlp = skip_whitespace(urlp));
  if ((urlp[0] != '/')) {
    send_headers_and_exit(HTTP_BAD_REQUEST);
  }  
  (http_major_version = '0');
  if (((id2i.config_feature_httpd_proxy ) )) {
    (_2989_http_minor_version = '0');
  }  
  (tptr = strchrnul(urlp, ' '));
  if ((tptr[0] && (strncmp((tptr + 1), HTTP_200, 5) == 0))) {
    (http_major_version = tptr[6]);
    if (((id2i.config_feature_httpd_proxy ) )) {
      (_2989_http_minor_version = tptr[8]);
    }  
  }  
  ((*tptr) = '\0');
  (urlcopy = __builtin_alloca(((tptr - urlp) + 2 + strlen((*ptr_to_globals).index_page))));
  strcpy(urlcopy, urlp);
  ((*ptr_to_globals).g_query = ((void *) 0));
  (tptr = strchr(urlcopy, '?'));
  if (tptr) {
    ((*tptr++) = '\0');
    ((*ptr_to_globals).g_query = tptr);
  }  
  (tptr = decodeString(urlcopy, 0));
  if ((tptr == ((void *) 0))) {
    send_headers_and_exit(HTTP_BAD_REQUEST);
  }  
  if ((tptr == (urlcopy + 1))) {
    send_headers_and_exit(HTTP_NOT_FOUND);
  }  
  (urlp = (tptr = urlcopy));
  do {
    if (((*urlp) == '/')) {
      if (((*tptr) == '/')) {
        continue;
      }  
      if (((*tptr) == '.')) {
        if (((tptr[1] == '/') || (! tptr[1]))) {
          continue;
        }  
        if (((tptr[1] == '.') && ((tptr[2] == '/') || (! tptr[2])))) {
          ++tptr;
          if ((urlp == urlcopy)) {
            send_headers_and_exit(HTTP_BAD_REQUEST);
          }  
          while (((*--urlp) != '/')) {
            
          }
          continue;
        }  
      }  
    }  
    ((*++urlp) = (*tptr));
  } while ((*++tptr));
  ((*++urlp) = '\0');
  if ((urlp[(- 1)] != '/')) {
    if (is_directory((urlcopy + 1), 1, ((void *) 0))) {
      ((*ptr_to_globals).found_moved_temporarily = urlcopy);
    }  
  }  
  if (((*ptr_to_globals).verbose > 1)) {
    bb_error_msg("url:%s", urlcopy);
  }  
  (tptr = urlcopy);
  if ((((! id2i.config_feature_httpd_basic_auth) && (! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || ((! id2i.config_feature_httpd_basic_auth) && id2i.config_feature_httpd_cgi) || (id2i.config_feature_httpd_basic_auth ))) {
    (_3010_ip_allowed = checkPermIP());
  }  
  while ((_3010_ip_allowed && ((tptr = strchr((tptr + 1), '/')) != ((void *) 0)))) {
    ((*tptr) = '\0');
    if (is_directory((urlcopy + 1), 1, ((void *) 0))) {
      parse_conf((urlcopy + 1), SUBDIR_PARSE);
      if ((((! id2i.config_feature_httpd_basic_auth) && (! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || ((! id2i.config_feature_httpd_basic_auth) && id2i.config_feature_httpd_cgi) || (id2i.config_feature_httpd_basic_auth ))) {
        (_3010_ip_allowed = checkPermIP());
      }  
    }  
    ((*tptr) = '/');
  }
  if (((id2i.config_feature_httpd_proxy ) )) {
    (_2989_proxy_entry = _2989_find_proxy_entry(urlcopy));
  }  
  if (((id2i.config_feature_httpd_proxy ) )) {
    if (_2989_proxy_entry) {
      (_2989_header_buf = (_2989_header_ptr = xmalloc(8192)));
    }  
  }  
  if ((http_major_version >= '0')) {
    while (1) {
      if ((! get_line())) {
        break;
      }  
      if (0) {
        bb_error_msg("header: '%s'", (*ptr_to_globals).iobuf);
      }  
      if (((id2i.config_feature_httpd_proxy ) )) {
        if ((_2989_proxy_entry && ((_2989_header_ptr - _2989_header_buf) < (8192 - 2)))) {
          int len =  strlen((*ptr_to_globals).iobuf);
          if ((len > (8192 - (_2989_header_ptr - _2989_header_buf) - 4))) {
            (len = (8192 - (_2989_header_ptr - _2989_header_buf) - 4));
          }  
          memcpy(_2989_header_ptr, (*ptr_to_globals).iobuf, len);
          (_2989_header_ptr += len);
          (_2989_header_ptr[0] = '\r');
          (_2989_header_ptr[1] = '\n');
          (_2989_header_ptr += 2);
        }  
      }  
      if ((((! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || (id2i.config_feature_httpd_cgi ))) {
        if ((strncasecmp((*ptr_to_globals).iobuf, "Content-length:", (sizeof("Content-length:") - 1)) == 0)) {
          if ((((id2i.config_feature_httpd_cgi ) ) ? ((_2982_prequest != request_GET) && (_2982_prequest != _2982_request_HEAD)) : (request_GET != request_GET))) {
            (tptr = skip_whitespace(((*ptr_to_globals).iobuf + sizeof("Content-length:") - 1)));
            if ((! tptr[0])) {
              send_headers_and_exit(HTTP_BAD_REQUEST);
            }  
            if (((id2i.config_feature_httpd_cgi ) )) {
              (_2982_length = bb_strtou(tptr, ((void *) 0), 10));
            }  
            if ((((! id2i.config_feature_httpd_cgi) ) )) {
              (_3006_length = bb_strtou(tptr, ((void *) 0), 10));
            }  
            if (((((! id2i.config_feature_httpd_cgi) ) ) ? ((*bb_errno) || (_3006_length > 2147483647)) : ((*bb_errno) || (_2982_length > 2147483647)))) {
              send_headers_and_exit(HTTP_BAD_REQUEST);
            }  
          }  
        }  
      }  
      if (((id2i.config_feature_httpd_basic_auth ) )) {
        if ((strncasecmp((*ptr_to_globals).iobuf, "Authorization:", (sizeof("Authorization:") - 1)) == 0)) {
          (tptr = skip_whitespace(((*ptr_to_globals).iobuf + sizeof("Authorization:") - 1)));
          if ((strncasecmp(tptr, "Basic", (sizeof("Basic") - 1)) != 0)) {
            continue;
          }  
          (tptr += (sizeof("Basic") - 1));
          _2981_decodeBase64(tptr);
          if ((((! id2i.config_feature_httpd_cgi) && (! id2i.config_feature_httpd_proxy)) )) {
            (_3008_authorized = _2981_check_user_passwd(urlcopy, tptr));
          }  
          if ((((! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || (id2i.config_feature_httpd_cgi ))) {
            (_3009_authorized = _2981_check_user_passwd(urlcopy, tptr));
          }  
        }  
      }  
      if (((id2i.config_feature_httpd_ranges ) )) {
        if ((strncasecmp((*ptr_to_globals).iobuf, "Range:", (sizeof("Range:") - 1)) == 0)) {
          char *s =  skip_whitespace(((*ptr_to_globals).iobuf + sizeof("Range:") - 1));
          if ((strncmp(s, "bytes=", 6) == 0)) {
            (s += (sizeof("bytes=") - 1));
            if (((id2i.config_lfs && id2i.config_feature_httpd_ranges) )) {
              ((*ptr_to_globals)._2983_range_start = bb_strtoull(s, (&s), 10));
            }  
            if ((((! id2i.config_lfs) && id2i.config_feature_httpd_ranges) )) {
              ((*ptr_to_globals)._2983_range_start = bb_strtou(s, (&s), 10));
            }  
            if (((s[0] != '-') || ((*ptr_to_globals)._2983_range_start < 0))) {
              ((*ptr_to_globals)._2983_range_start = 0);
            } 
            else if (s[1]) {
              if (((id2i.config_lfs && id2i.config_feature_httpd_ranges) )) {
                ((*ptr_to_globals)._2983_range_end = bb_strtoull((s + 1), ((void *) 0), 10));
              }  
              if ((((! id2i.config_lfs) && id2i.config_feature_httpd_ranges) )) {
                ((*ptr_to_globals)._2983_range_end = bb_strtou((s + 1), ((void *) 0), 10));
              }  
              if (((*bb_errno) || ((*ptr_to_globals)._2983_range_end < (*ptr_to_globals)._2983_range_start))) {
                ((*ptr_to_globals)._2983_range_start = 0);
              }  
            } 
          }  
        }  
      }  
      if (((id2i.config_feature_httpd_gzip ) )) {
        if ((strncasecmp((*ptr_to_globals).iobuf, "Accept-Encoding:", (sizeof("Accept-Encoding:") - 1)) == 0)) {
          const char *s =  strstr((*ptr_to_globals).iobuf, "gzip");
          if (s) {
            ((*ptr_to_globals)._2990_content_gzip = 1);
          }  
        }  
      }  
    }
  }  
  alarm(0);
  if (((strcmp(bb_basename(urlcopy), HTTPD_CONF) == 0) || (! _3010_ip_allowed))) {
    send_headers_and_exit(HTTP_FORBIDDEN);
  }  
  if (((id2i.config_feature_httpd_basic_auth ) )) {
    if (((((! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || (id2i.config_feature_httpd_cgi )) ? (_3009_authorized < 0) : (_3008_authorized < 0))) {
      if ((((! id2i.config_feature_httpd_cgi) && (! id2i.config_feature_httpd_proxy)) )) {
        (_3008_authorized = _2981_check_user_passwd(urlcopy, ":"));
      }  
      if ((((! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || (id2i.config_feature_httpd_cgi ))) {
        (_3009_authorized = _2981_check_user_passwd(urlcopy, ":"));
      }  
    }  
  }  
  if (((id2i.config_feature_httpd_basic_auth ) )) {
    if (((((! id2i.config_feature_httpd_cgi) && id2i.config_feature_httpd_proxy) || (id2i.config_feature_httpd_cgi )) ? (! _3009_authorized) : (! _3008_authorized))) {
      send_headers_and_exit(HTTP_UNAUTHORIZED);
    }  
  }  
  if ((*ptr_to_globals).found_moved_temporarily) {
    send_headers_and_exit(HTTP_MOVED_TEMPORARILY);
  }  
  if (((id2i.config_feature_httpd_proxy ) )) {
    if ((_2989_proxy_entry != ((void *) 0))) {
      int proxy_fd;
      len_and_sockaddr *lsa;
      (proxy_fd = socket(2, SOCK_STREAM, 0));
      if ((proxy_fd < 0)) {
        send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
      }  
      (lsa = host2sockaddr(_2989_proxy_entry->host_port, 80));
      if ((lsa == ((void *) 0))) {
        send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
      }  
      if ((connect(proxy_fd, (&lsa->u.sa), lsa->len) < 0)) {
        send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
      }  
      if (((id2i.config_feature_httpd_cgi ) )) {
        dprintf(proxy_fd, "%s %s%s%s%s HTTP/%c.%c\r\n", _2982_prequest, _2989_proxy_entry->url_to, (urlcopy + strlen(_2989_proxy_entry->url_from)), ((*ptr_to_globals).g_query ? "?" : ""), ((*ptr_to_globals).g_query ? (*ptr_to_globals).g_query : ""), http_major_version, _2989_http_minor_version);
      }  
      if ((((! id2i.config_feature_httpd_cgi) ) )) {
        dprintf(proxy_fd, "%s %s%s%s%s HTTP/%c.%c\r\n", request_GET, _2989_proxy_entry->url_to, (urlcopy + strlen(_2989_proxy_entry->url_from)), ((*ptr_to_globals).g_query ? "?" : ""), ((*ptr_to_globals).g_query ? (*ptr_to_globals).g_query : ""), http_major_version, _2989_http_minor_version);
      }  
      (_2989_header_ptr[0] = '\r');
      (_2989_header_ptr[1] = '\n');
      (_2989_header_ptr += 2);
      write(proxy_fd, _2989_header_buf, (_2989_header_ptr - _2989_header_buf));
      free(_2989_header_buf);
      if (((id2i.config_feature_httpd_cgi ) )) {
        _2998_cgi_io_loop_and_exit(proxy_fd, proxy_fd, _2982_length);
      }  
      if ((((! id2i.config_feature_httpd_cgi) ) )) {
        _2998_cgi_io_loop_and_exit(proxy_fd, proxy_fd, _3006_length);
      }  
    }  
  }  
  (tptr = (urlcopy + 1));
  if (((id2i.config_feature_httpd_cgi ) )) {
    if ((strncmp(tptr, "cgi-bin/", 8) == 0)) {
      if ((tptr[8] == '\0')) {
        send_headers_and_exit(HTTP_FORBIDDEN);
      }  
      _2982_send_cgi_and_exit(urlcopy, _2982_prequest, _2982_length, _2982_cookie, _2982_content_type);
    }  
  }  
  if ((urlp[(- 1)] == '/')) {
    strcpy(urlp, (*ptr_to_globals).index_page);
  }  
  if ((stat(tptr, (&sb)) == 0)) {
    char *_2984_suffix =  strrchr(tptr, '.');
    if (((id2i.config_feature_httpd_config_with_script_interpr ) )) {
      if (_2984_suffix) {
        Htaccess *cur;
        for ((cur = (*ptr_to_globals)._2984_script_i); cur; (cur = cur->next)) {
          if ((strcmp((cur->before_colon + 1), _2984_suffix) == 0)) {
            _2982_send_cgi_and_exit(urlcopy, _2982_prequest, _2982_length, _2982_cookie, _2982_content_type);
          }  
        }
      }  
    }  
    ((*ptr_to_globals).file_size = sb.st_size);
    ((*ptr_to_globals).last_mod = sb.st_mtim.tv_sec);
  }  
  if (((id2i.config_feature_httpd_cgi ) )) {
    if (((_2982_prequest != request_GET) && (_2982_prequest != _2982_request_HEAD))) {
      send_headers_and_exit(HTTP_NOT_IMPLEMENTED);
    }  
  }  
  if (((id2i.config_feature_httpd_cgi ) )) {
    send_file_and_exit(tptr, ((_2982_prequest != _2982_request_HEAD) ? SEND_HEADERS_AND_BODY : SEND_HEADERS));
  }  
  if ((((! id2i.config_feature_httpd_cgi) ) )) {
    send_file_and_exit(tptr, SEND_HEADERS_AND_BODY);
  }  
}
static void _13_mini_httpd(int server_socket ) __attribute__((__noreturn__));
static  void _13_mini_httpd(int server_socket )  {
  while (1) {
    int n;
    len_and_sockaddr fromAddr;
    (fromAddr.len = LSA_SIZEOF_SA);
    (n = accept(server_socket, (&fromAddr.u.sa), (&fromAddr.len)));
    if ((n < 0)) {
      continue;
    }  
    setsockopt(n, 1, 9, (&const_int_1), sizeof(const_int_1));
    if ((fork() == 0)) {
      signal(1, ((__sighandler_t ) 1));
      close(server_socket);
      xmove_fd(n, 0);
      xdup2(0, 1);
      handle_incoming_and_exit((&fromAddr));
    }  
    close(n);
  }
}
static void _14_mini_httpd_nommu(int server_socket , int argc , char **argv ) __attribute__((__noreturn__));
static  void _14_mini_httpd_nommu(int server_socket , int argc , char **argv )  {
  char *argv_copy[(argc + 2)];
  (argv_copy[0] = argv[0]);
  (argv_copy[1] = ((char *) "-i"));
  memcpy((&argv_copy[2]), (&argv[1]), (argc * sizeof(argv[0])));
  while (1) {
    int n;
    len_and_sockaddr fromAddr;
    (fromAddr.len = LSA_SIZEOF_SA);
    (n = accept(server_socket, (&fromAddr.u.sa), (&fromAddr.len)));
    if ((n < 0)) {
      continue;
    }  
    setsockopt(n, 1, 9, (&const_int_1), sizeof(const_int_1));
    if ((vfork() == 0)) {
      signal(1, ((__sighandler_t ) 1));
      close(server_socket);
      xmove_fd(n, 0);
      xdup2(0, 1);
      _14_re_exec(argv_copy);
    }  
    close(n);
  }
}
static void mini_httpd_inetd(void ) __attribute__((__noreturn__));
static  void mini_httpd_inetd(void )  {
  len_and_sockaddr fromAddr;
  memset((&fromAddr), 0, sizeof(fromAddr));
  (fromAddr.len = LSA_SIZEOF_SA);
  getpeername(0, (&fromAddr.u.sa), (&fromAddr.len));
  handle_incoming_and_exit((&fromAddr));
}
static  void sighup_handler(int sig __attribute__((__unused__)))  {
  parse_conf(DEFAULT_PATH_HTTPD_CONF, SIGNALED_PARSE);
}
enum  {
  c_opt_config_file = 0,
  d_opt_decode_url,
  h_opt_home_httpd,
  _2993_e_opt_encode_url,
  _2981_r_opt_realm,
  _3012_m_opt_md5,
  _3013_u_opt_setuid,
  p_opt_port,
  p_opt_inetd,
  p_opt_foreground,
  p_opt_verbose,
  OPT_CONFIG_FILE = (1 << c_opt_config_file),
  OPT_DECODE_URL = (1 << d_opt_decode_url),
  OPT_HOME_HTTPD = (1 << h_opt_home_httpd),
  _2993_OPT_ENCODE_URL = ((1 << _2993_e_opt_encode_url) + 0),
  _3014_OPT_ENCODE_URL = (+ 0),
  _2981_OPT_REALM = ((1 << _2981_r_opt_realm) + 0),
  _3015_OPT_REALM = (+ 0),
  _3012_OPT_MD5 = ((1 << _3012_m_opt_md5) + 0),
  _3016_OPT_MD5 = (+ 0),
  _3013_OPT_SETUID = ((1 << _3013_u_opt_setuid) + 0),
  _3017_OPT_SETUID = (+ 0),
  OPT_PORT = (1 << p_opt_port),
  OPT_INETD = (1 << p_opt_inetd),
  OPT_FOREGROUND = (1 << p_opt_foreground),
  OPT_VERBOSE = (1 << p_opt_verbose)
} ;
int httpd_main(int argc , char **argv );
int httpd_main(int argc , char **argv ) __attribute__((visibility ("default")));
int httpd_main(int argc __attribute__((__unused__)), char **argv )  {
  id2i_init();
  id2i_init();
  int server_socket =  server_socket;
  unsigned opt;
  char *url_for_decode;
  const char *_2993_url_for_encode;
  const char *_3013_s_ugid =  ((void *) 0);
  struct  bb_uidgid_t   _3013_ugid;
  const char *_3012_pass;
  do {
    do {
      ((*((struct  globals   **) (&ptr_to_globals))) = ((void *) xzalloc(sizeof((*ptr_to_globals)))));
      asm volatile ("":::"memory");
    } while (0);
    if (((id2i.config_feature_httpd_basic_auth ) )) {
      ((*ptr_to_globals)._2981_g_realm = "Web Server Authentication");
    }  
    ((*ptr_to_globals).bind_addr_or_port = "80");
    ((*ptr_to_globals).index_page = index_html);
    ((*ptr_to_globals).file_size = (- 1));
  } while (0);
  if (((id2i.config_locale_support ) )) {
    _2_setlocale(_2___LC_TIME, "C");
  }  
  ((*ptr_to_globals).home_httpd = xrealloc_getcwd_or_warn(((void *) 0)));
  (opt_complementary = "vv:if");
  if ((((! id2i.config_feature_httpd_setuid) && (! id2i.config_feature_httpd_basic_auth) && (! id2i.config_feature_httpd_auth_md5) && (! id2i.config_feature_httpd_encode_url_str)) )) {
    (opt = getopt32(argv, "c:d:h:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if (((id2i.config_feature_httpd_setuid && (! id2i.config_feature_httpd_basic_auth) && (! id2i.config_feature_httpd_auth_md5) && (! id2i.config_feature_httpd_encode_url_str)) )) {
    (opt = getopt32(argv, "c:d:h:" "u:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_3013_s_ugid), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if ((((! id2i.config_feature_httpd_setuid) && id2i.config_feature_httpd_basic_auth && (! id2i.config_feature_httpd_auth_md5) && (! id2i.config_feature_httpd_encode_url_str)) )) {
    (opt = getopt32(argv, "c:d:h:" "r:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&(*ptr_to_globals)._2981_g_realm), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if (((id2i.config_feature_httpd_setuid && id2i.config_feature_httpd_basic_auth && (! id2i.config_feature_httpd_auth_md5) && (! id2i.config_feature_httpd_encode_url_str)) )) {
    (opt = getopt32(argv, "c:d:h:" "r:" "u:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&(*ptr_to_globals)._2981_g_realm), (&_3013_s_ugid), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if ((((! id2i.config_feature_httpd_setuid) && id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_auth_md5 && (! id2i.config_feature_httpd_encode_url_str)) )) {
    (opt = getopt32(argv, "c:d:h:" "r:" "m:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&(*ptr_to_globals)._2981_g_realm), (&_3012_pass), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if (((id2i.config_feature_httpd_setuid && id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_auth_md5 && (! id2i.config_feature_httpd_encode_url_str)) )) {
    (opt = getopt32(argv, "c:d:h:" "r:" "m:" "u:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&(*ptr_to_globals)._2981_g_realm), (&_3012_pass), (&_3013_s_ugid), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if ((((! id2i.config_feature_httpd_setuid) && (! id2i.config_feature_httpd_basic_auth) && (! id2i.config_feature_httpd_auth_md5) && id2i.config_feature_httpd_encode_url_str) )) {
    (opt = getopt32(argv, "c:d:h:" "e:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_2993_url_for_encode), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if (((id2i.config_feature_httpd_setuid && (! id2i.config_feature_httpd_basic_auth) && (! id2i.config_feature_httpd_auth_md5) && id2i.config_feature_httpd_encode_url_str) )) {
    (opt = getopt32(argv, "c:d:h:" "e:" "u:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_2993_url_for_encode), (&_3013_s_ugid), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if ((((! id2i.config_feature_httpd_setuid) && id2i.config_feature_httpd_basic_auth && (! id2i.config_feature_httpd_auth_md5) && id2i.config_feature_httpd_encode_url_str) )) {
    (opt = getopt32(argv, "c:d:h:" "e:" "r:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_2993_url_for_encode), (&(*ptr_to_globals)._2981_g_realm), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if (((id2i.config_feature_httpd_setuid && id2i.config_feature_httpd_basic_auth && (! id2i.config_feature_httpd_auth_md5) && id2i.config_feature_httpd_encode_url_str) )) {
    (opt = getopt32(argv, "c:d:h:" "e:" "r:" "u:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_2993_url_for_encode), (&(*ptr_to_globals)._2981_g_realm), (&_3013_s_ugid), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if ((((! id2i.config_feature_httpd_setuid) && id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_auth_md5 && id2i.config_feature_httpd_encode_url_str) )) {
    (opt = getopt32(argv, "c:d:h:" "e:" "r:" "m:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_2993_url_for_encode), (&(*ptr_to_globals)._2981_g_realm), (&_3012_pass), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if (((id2i.config_feature_httpd_setuid && id2i.config_feature_httpd_basic_auth && id2i.config_feature_httpd_auth_md5 && id2i.config_feature_httpd_encode_url_str) )) {
    (opt = getopt32(argv, "c:d:h:" "e:" "r:" "m:" "u:" "p:ifv", (&(*ptr_to_globals).opt_c_configFile), (&url_for_decode), (&(*ptr_to_globals).home_httpd), (&_2993_url_for_encode), (&(*ptr_to_globals)._2981_g_realm), (&_3012_pass), (&_3013_s_ugid), (&(*ptr_to_globals).bind_addr_or_port), (&(*ptr_to_globals).verbose)));
  }  
  if ((opt & OPT_DECODE_URL)) {
    fputs(decodeString(url_for_decode, 1), stdout);
    return 0;
  }  
  if (((id2i.config_feature_httpd_encode_url_str ) )) {
    if ((opt & _2993_OPT_ENCODE_URL)) {
      fputs(_2993_encodeString(_2993_url_for_encode), stdout);
      return 0;
    }  
  }  
  if (((id2i.config_feature_httpd_auth_md5 ) )) {
    if ((opt & _3012_OPT_MD5)) {
      char salt[sizeof("$1$XXXXXXXX")];
      (salt[0] = '$');
      (salt[1] = '1');
      (salt[2] = '$');
      crypt_make_salt((salt + 3), 4, 0);
      if (((id2i.config_use_bb_crypt ) )) {
        puts(_35_pw_encrypt(_3012_pass, salt, 1));
      }  
      if ((((! id2i.config_use_bb_crypt) ) )) {
        puts(_36_pw_encrypt(_3012_pass, salt));
      }  
      return 0;
    }  
  }  
  if (((id2i.config_feature_httpd_setuid ) )) {
    if ((opt & _3013_OPT_SETUID)) {
      xget_uidgid((&_3013_ugid), _3013_s_ugid);
    }  
  }  
  if (((id2i.config_nommu ) )) {
    if ((! (opt & OPT_FOREGROUND))) {
      _14_bb_daemonize_or_rexec(0, argv);
    }  
  }  
  xchdir((*ptr_to_globals).home_httpd);
  if ((! (opt & OPT_INETD))) {
    signal(17, ((__sighandler_t ) 1));
    (server_socket = openServer());
    if (((id2i.config_feature_httpd_setuid ) )) {
      if ((opt & _3013_OPT_SETUID)) {
        if ((_3013_ugid.gid != ((gid_t ) (- 1)))) {
          if ((setgroups(1, (&_3013_ugid.gid)) == (- 1))) {
            bb_perror_msg_and_die("setgroups");
          }  
          xsetgid(_3013_ugid.gid);
        }  
        xsetuid(_3013_ugid.uid);
      }  
    }  
  }  
  parse_conf(DEFAULT_PATH_HTTPD_CONF, FIRST_PARSE);
  if ((! (opt & OPT_INETD))) {
    signal(1, sighup_handler);
  }  
  (xfunc_error_retval = 0);
  if ((opt & OPT_INETD)) {
    mini_httpd_inetd();
  }  
  if ((((! id2i.config_nommu) ) )) {
    if ((! (opt & OPT_FOREGROUND))) {
      _13_bb_daemonize_or_rexec(0);
    }  
  }  
  if ((((! id2i.config_nommu) ) )) {
    _13_mini_httpd(server_socket);
  }  
  if (((id2i.config_nommu ) )) {
    _14_mini_httpd_nommu(server_socket, argc, argv);
  }  
}